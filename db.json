{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"source/CNANE","path":"CNANE","modified":1,"renderable":0},{"_id":"source/images/concurrency.png","path":"images/concurrency.png","modified":1,"renderable":0},{"_id":"source/images/demo1.gif","path":"images/demo1.gif","modified":1,"renderable":0},{"_id":"source/images/demo3.gif","path":"images/demo3.gif","modified":1,"renderable":0},{"_id":"source/images/git_move_file.png","path":"images/git_move_file.png","modified":1,"renderable":0},{"_id":"source/images/image-20191128113937513.png","path":"images/image-20191128113937513.png","modified":1,"renderable":0},{"_id":"source/images/image-20191128142021000.png","path":"images/image-20191128142021000.png","modified":1,"renderable":0},{"_id":"source/images/image-20191128140108874.png","path":"images/image-20191128140108874.png","modified":1,"renderable":0},{"_id":"source/images/image-20191128142447611.png","path":"images/image-20191128142447611.png","modified":1,"renderable":0},{"_id":"source/images/image-20191128142917368.png","path":"images/image-20191128142917368.png","modified":1,"renderable":0},{"_id":"source/images/image-20191128182507434.png","path":"images/image-20191128182507434.png","modified":1,"renderable":0},{"_id":"source/images/image-20191128182813621.png","path":"images/image-20191128182813621.png","modified":1,"renderable":0},{"_id":"source/images/jeninks_image6.png","path":"images/jeninks_image6.png","modified":1,"renderable":0},{"_id":"source/images/jenkins_image1.png","path":"images/jenkins_image1.png","modified":1,"renderable":0},{"_id":"source/images/jenkins_image10.png","path":"images/jenkins_image10.png","modified":1,"renderable":0},{"_id":"source/images/jenkins_image11.png","path":"images/jenkins_image11.png","modified":1,"renderable":0},{"_id":"source/images/jenkins_image2.png","path":"images/jenkins_image2.png","modified":1,"renderable":0},{"_id":"source/images/jenkins_image3.png","path":"images/jenkins_image3.png","modified":1,"renderable":0},{"_id":"source/images/jenkins_image4.png","path":"images/jenkins_image4.png","modified":1,"renderable":0},{"_id":"source/images/jenkins_image5.png","path":"images/jenkins_image5.png","modified":1,"renderable":0},{"_id":"source/images/jenkins_image7.png","path":"images/jenkins_image7.png","modified":1,"renderable":0},{"_id":"source/images/jenkins_image8.png","path":"images/jenkins_image8.png","modified":1,"renderable":0},{"_id":"source/images/jenkins_image9.png","path":"images/jenkins_image9.png","modified":1,"renderable":0},{"_id":"source/images/parallelism.png","path":"images/parallelism.png","modified":1,"renderable":0},{"_id":"source/images/pic1.png","path":"images/pic1.png","modified":1,"renderable":0},{"_id":"source/images/pic2.png","path":"images/pic2.png","modified":1,"renderable":0},{"_id":"source/images/pic3.png","path":"images/pic3.png","modified":1,"renderable":0},{"_id":"source/images/pic4.png","path":"images/pic4.png","modified":1,"renderable":0},{"_id":"source/images/pic5.png","path":"images/pic5.png","modified":1,"renderable":0},{"_id":"source/images/pic6.jpg","path":"images/pic6.jpg","modified":1,"renderable":0},{"_id":"source/images/processing_image.gif","path":"images/processing_image.gif","modified":1,"renderable":0},{"_id":"source/images/processing_image.gif.png","path":"images/processing_image.gif.png","modified":1,"renderable":0},{"_id":"themes/obsidian/source/aplayer/package.json","path":"aplayer/package.json","modified":1,"renderable":1},{"_id":"themes/obsidian/source/aplayer/LICENSE","path":"aplayer/LICENSE","modified":1,"renderable":1},{"_id":"themes/obsidian/source/js/Meting.min.js","path":"js/Meting.min.js","modified":1,"renderable":1},{"_id":"themes/obsidian/source/js/busuanzi.min.js","path":"js/busuanzi.min.js","modified":1,"renderable":1},{"_id":"themes/obsidian/source/aplayer/README.md","path":"aplayer/README.md","modified":1,"renderable":1},{"_id":"themes/obsidian/source/js/busuanzi.js","path":"js/busuanzi.js","modified":1,"renderable":1},{"_id":"themes/obsidian/source/js/jquery.truncate.js","path":"js/jquery.truncate.js","modified":1,"renderable":1},{"_id":"themes/obsidian/source/js/loadaplayer.js","path":"js/loadaplayer.js","modified":1,"renderable":1},{"_id":"themes/obsidian/source/js/obsidian.js","path":"js/obsidian.js","modified":1,"renderable":1},{"_id":"themes/obsidian/source/js/jquery.min.js","path":"js/jquery.min.js","modified":1,"renderable":1},{"_id":"themes/obsidian/source/js/jquery.truncate.min.js","path":"js/jquery.truncate.min.js","modified":1,"renderable":1},{"_id":"themes/obsidian/source/js/obsidian.min.js","path":"js/obsidian.min.js","modified":1,"renderable":1},{"_id":"themes/obsidian/source/js/search.js","path":"js/search.js","modified":1,"renderable":1},{"_id":"themes/obsidian/source/js/plugin.js","path":"js/plugin.js","modified":1,"renderable":1},{"_id":"themes/obsidian/source/statics/chengdu.mp3","path":"statics/chengdu.mp3","modified":1,"renderable":1},{"_id":"themes/obsidian/source/css/ball-atom.min.css","path":"css/ball-atom.min.css","modified":1,"renderable":1},{"_id":"themes/obsidian/source/css/obsidian.styl","path":"css/obsidian.styl","modified":1,"renderable":1},{"_id":"themes/obsidian/source/aplayer/yarn.lock","path":"aplayer/yarn.lock","modified":1,"renderable":1},{"_id":"themes/obsidian/source/css/codemirror.styl","path":"css/codemirror.styl","modified":1,"renderable":1},{"_id":"themes/obsidian/source/css/theme.styl","path":"css/theme.styl","modified":1,"renderable":1},{"_id":"themes/obsidian/source/img/favicon.png","path":"img/favicon.png","modified":1,"renderable":1},{"_id":"themes/obsidian/source/img/logo.png","path":"img/logo.png","modified":1,"renderable":1},{"_id":"themes/obsidian/source/img/welcome-cover.jpg","path":"img/welcome-cover.jpg","modified":1,"renderable":1},{"_id":"themes/obsidian/source/img/logo_icon.png","path":"img/logo_icon.png","modified":1,"renderable":1},{"_id":"themes/obsidian/source/img/profile.jpg","path":"img/profile.jpg","modified":1,"renderable":1},{"_id":"themes/obsidian/source/img/cover.jpg","path":"img/cover.jpg","modified":1,"renderable":1},{"_id":"themes/obsidian/source/font/Rubik-Bold-kern-latin.woff2","path":"font/Rubik-Bold-kern-latin.woff2","modified":1,"renderable":1},{"_id":"themes/obsidian/source/font/Rubik-Regular-kern-latin.woff2","path":"font/Rubik-Regular-kern-latin.woff2","modified":1,"renderable":1},{"_id":"themes/obsidian/source/aplayer/demo/demo.js","path":"aplayer/demo/demo.js","modified":1,"renderable":1},{"_id":"themes/obsidian/source/aplayer/webpack/dev.config.js","path":"aplayer/webpack/dev.config.js","modified":1,"renderable":1},{"_id":"themes/obsidian/source/aplayer/demo/index.html","path":"aplayer/demo/index.html","modified":1,"renderable":1},{"_id":"themes/obsidian/source/aplayer/webpack/prod.config.js","path":"aplayer/webpack/prod.config.js","modified":1,"renderable":1},{"_id":"themes/obsidian/source/aplayer/dist/APlayer.min.js","path":"aplayer/dist/APlayer.min.js","modified":1,"renderable":1},{"_id":"themes/obsidian/source/aplayer/dist/APlayer.min.css","path":"aplayer/dist/APlayer.min.css","modified":1,"renderable":1},{"_id":"themes/obsidian/source/aplayer/dist/APlayer.min.css.map","path":"aplayer/dist/APlayer.min.css.map","modified":1,"renderable":1},{"_id":"themes/obsidian/source/aplayer/dist/APlayer.js","path":"aplayer/dist/APlayer.js","modified":1,"renderable":1},{"_id":"themes/obsidian/source/aplayer/dist/APlayer.min.js.map","path":"aplayer/dist/APlayer.min.js.map","modified":1,"renderable":1},{"_id":"themes/obsidian/source/aplayer/docs/config.js","path":"aplayer/docs/config.js","modified":1,"renderable":1},{"_id":"themes/obsidian/source/aplayer/docs/README.md","path":"aplayer/docs/README.md","modified":1,"renderable":1},{"_id":"themes/obsidian/source/aplayer/docs/ecosystem.md","path":"aplayer/docs/ecosystem.md","modified":1,"renderable":1},{"_id":"themes/obsidian/source/aplayer/docs/index.html","path":"aplayer/docs/index.html","modified":1,"renderable":1},{"_id":"themes/obsidian/source/aplayer/docs/landing.html","path":"aplayer/docs/landing.html","modified":1,"renderable":1},{"_id":"themes/obsidian/source/aplayer/docs/support.md","path":"aplayer/docs/support.md","modified":1,"renderable":1},{"_id":"themes/obsidian/source/aplayer/src/assets/loading.svg","path":"aplayer/src/assets/loading.svg","modified":1,"renderable":1},{"_id":"themes/obsidian/source/aplayer/src/assets/loop-one.svg","path":"aplayer/src/assets/loop-one.svg","modified":1,"renderable":1},{"_id":"themes/obsidian/source/aplayer/src/assets/loop-none.svg","path":"aplayer/src/assets/loop-none.svg","modified":1,"renderable":1},{"_id":"themes/obsidian/source/aplayer/src/assets/lrc.svg","path":"aplayer/src/assets/lrc.svg","modified":1,"renderable":1},{"_id":"themes/obsidian/source/aplayer/src/assets/order-list.svg","path":"aplayer/src/assets/order-list.svg","modified":1,"renderable":1},{"_id":"themes/obsidian/source/aplayer/src/assets/order-random.svg","path":"aplayer/src/assets/order-random.svg","modified":1,"renderable":1},{"_id":"themes/obsidian/source/aplayer/src/assets/menu.svg","path":"aplayer/src/assets/menu.svg","modified":1,"renderable":1},{"_id":"themes/obsidian/source/aplayer/src/assets/pause.svg","path":"aplayer/src/assets/pause.svg","modified":1,"renderable":1},{"_id":"themes/obsidian/source/aplayer/src/assets/play.svg","path":"aplayer/src/assets/play.svg","modified":1,"renderable":1},{"_id":"themes/obsidian/source/aplayer/src/assets/right.svg","path":"aplayer/src/assets/right.svg","modified":1,"renderable":1},{"_id":"themes/obsidian/source/aplayer/src/assets/loop-all.svg","path":"aplayer/src/assets/loop-all.svg","modified":1,"renderable":1},{"_id":"themes/obsidian/source/aplayer/src/assets/skip.svg","path":"aplayer/src/assets/skip.svg","modified":1,"renderable":1},{"_id":"themes/obsidian/source/aplayer/src/assets/volume-off.svg","path":"aplayer/src/assets/volume-off.svg","modified":1,"renderable":1},{"_id":"themes/obsidian/source/aplayer/src/assets/volume-down.svg","path":"aplayer/src/assets/volume-down.svg","modified":1,"renderable":1},{"_id":"themes/obsidian/source/aplayer/src/js/bar.js","path":"aplayer/src/js/bar.js","modified":1,"renderable":1},{"_id":"themes/obsidian/source/aplayer/src/css/index.scss","path":"aplayer/src/css/index.scss","modified":1,"renderable":1},{"_id":"themes/obsidian/source/aplayer/src/js/events.js","path":"aplayer/src/js/events.js","modified":1,"renderable":1},{"_id":"themes/obsidian/source/aplayer/src/js/controller.js","path":"aplayer/src/js/controller.js","modified":1,"renderable":1},{"_id":"themes/obsidian/source/aplayer/src/js/icons.js","path":"aplayer/src/js/icons.js","modified":1,"renderable":1},{"_id":"themes/obsidian/source/aplayer/src/js/index.js","path":"aplayer/src/js/index.js","modified":1,"renderable":1},{"_id":"themes/obsidian/source/aplayer/src/js/list.js","path":"aplayer/src/js/list.js","modified":1,"renderable":1},{"_id":"themes/obsidian/source/aplayer/src/js/lrc.js","path":"aplayer/src/js/lrc.js","modified":1,"renderable":1},{"_id":"themes/obsidian/source/aplayer/src/assets/volume-up.svg","path":"aplayer/src/assets/volume-up.svg","modified":1,"renderable":1},{"_id":"themes/obsidian/source/aplayer/src/js/options.js","path":"aplayer/src/js/options.js","modified":1,"renderable":1},{"_id":"themes/obsidian/source/aplayer/src/js/player.js","path":"aplayer/src/js/player.js","modified":1,"renderable":1},{"_id":"themes/obsidian/source/aplayer/src/js/storage.js","path":"aplayer/src/js/storage.js","modified":1,"renderable":1},{"_id":"themes/obsidian/source/aplayer/src/js/timer.js","path":"aplayer/src/js/timer.js","modified":1,"renderable":1},{"_id":"themes/obsidian/source/aplayer/src/js/utils.js","path":"aplayer/src/js/utils.js","modified":1,"renderable":1},{"_id":"themes/obsidian/source/aplayer/src/js/template.js","path":"aplayer/src/js/template.js","modified":1,"renderable":1},{"_id":"themes/obsidian/source/aplayer/src/template/list-item.art","path":"aplayer/src/template/list-item.art","modified":1,"renderable":1},{"_id":"themes/obsidian/source/aplayer/src/template/lrc.art","path":"aplayer/src/template/lrc.art","modified":1,"renderable":1},{"_id":"themes/obsidian/source/aplayer/src/template/player.art","path":"aplayer/src/template/player.art","modified":1,"renderable":1},{"_id":"themes/obsidian/source/aplayer/docs/zh-Hans/ecosystem.md","path":"aplayer/docs/zh-Hans/ecosystem.md","modified":1,"renderable":1},{"_id":"themes/obsidian/source/aplayer/docs/zh-Hans/README.md","path":"aplayer/docs/zh-Hans/README.md","modified":1,"renderable":1},{"_id":"themes/obsidian/source/aplayer/docs/zh-Hans/support.md","path":"aplayer/docs/zh-Hans/support.md","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"b48c4f7d61a5928be717d4bd654481ff1eab36ee","modified":1681183519105},{"_id":"source/about/index.md","hash":"648821e10cb9432a03dec7e4611b48495038d3f1","modified":1681183827142},{"_id":"source/CNANE","hash":"b08d663432b1212b15f0baf6f992105bce5af6cb","modified":1681183827108},{"_id":"source/categories/index.html","hash":"f35cfd543f0ef2ac91601b303efd6d573c8a5523","modified":1681183827142},{"_id":"source/_posts/Automaticly-Build-Personal-Website-Via-Jenkins.md","hash":"9a9d9a9cf52cc171ada986cf9bbccea41882f5ad","modified":1681183827109},{"_id":"source/_posts/0to1-build-vue-project.md","hash":"c1aa812815802df894dd44f9cd12ffb09cbe0b11","modified":1681183827108},{"_id":"source/_posts/Database-Relationship.md","hash":"0ae43c6701329e131841bbb1d0389e072a676f87","modified":1681183827109},{"_id":"source/_posts/Build-Your-Own-Cli-Tool-Via-Nodejs.md","hash":"c2021696d76d330ce00388a760efb92fe9f449e9","modified":1681183827109},{"_id":"source/_posts/Database-Key-and-Index.md","hash":"92d864429b0cf9b4b7409539d241edc81188efc7","modified":1681183827109},{"_id":"source/_posts/Developer-Git-Situation-Solutions.md","hash":"55bb9b1a3629d1dbec7a4293f71a556a630156e1","modified":1681183827110},{"_id":"source/_posts/Difference-Between-Concurrency-And-Parallelism.md","hash":"e266c7c6ebf577638c2fe5c2609d149b661e4ff0","modified":1681183827110},{"_id":"source/_posts/Frequently-Used-Docker-Container-Or-Image-Command.md","hash":"df1f0b52cd97b4b167cbd1dc5588548a35db8ed3","modified":1681183827110},{"_id":"source/_posts/Frequently-Used-Docker-Container-Network-Command.md","hash":"f55adc3ff6767bfcae5b77e05ab66229b6499437","modified":1681183827110},{"_id":"source/_posts/Javascript-data-structure.md","hash":"5b6df4a62577abc7513651d74c0dfb2d1392981d","modified":1681183827111},{"_id":"source/_posts/JavaScript-Design-Patterns-and-Development-Practice.md","hash":"83c9aa7f6f3e43e30c0dc859e5e005910586021d","modified":1681183827111},{"_id":"source/_posts/Frequently-Used-Git-Command.md","hash":"9c65e22bd5759cc8c14cd5aec15e781371940886","modified":1681183827111},{"_id":"source/_posts/SoftwareTesting.md","hash":"5ddb3d8ce5b0851d7a2d71e15f5578017ec1933a","modified":1681183827111},{"_id":"source/_posts/JavascriptDataType.md","hash":"048bad6f5095d912f01b9e5ea676ad6558f5cd5a","modified":1681183827111},{"_id":"source/_posts/Frequently-Used-Docker-Repository-Command.md","hash":"c034f19313242e17831ba0eba8a14ad54407605f","modified":1681183827110},{"_id":"source/_posts/The-problem-of-mobile-web-developing.md","hash":"4de012f99b691be2f553f53bfdba972da4d7ecfc","modified":1681183827111},{"_id":"source/_posts/interestingCSS.md","hash":"5e0bb3c9c8692f6cfbf0ff4e3c321f2d95f51d5d","modified":1681183827115},{"_id":"source/_posts/manage-Node-js-version-via-mvn.md","hash":"d41c1b48fbe4dd7a34b1c69b67b802c3cbc89c0e","modified":1681183827124},{"_id":"source/_posts/mongodb-command.md","hash":"579171940f2297c73071b83c34be09a81541e3ef","modified":1681183827124},{"_id":"source/_posts/mediaMatch.md","hash":"b7f390af2dfabad6a16846b2973f6768e654672e","modified":1681183827124},{"_id":"source/_posts/nginx-commmand-record.md","hash":"6b7446c6b31d3c521f242f075c09c154877e220c","modified":1681183827125},{"_id":"source/_posts/processing-medium-effect.md","hash":"cd9c2214489ef9a9037ced2a236a1ec2ff405848","modified":1681183827125},{"_id":"source/links/index.md","hash":"85684cb36ce99a65eb113782d242072c56b78198","modified":1681183827225},{"_id":"source/tags/index.html","hash":"a4fae07428ee2724e36437fd5ba6d1b743f87f5d","modified":1681183827225},{"_id":"source/_posts/wechat-share-and-single-page-summary.md","hash":"e9b7ef621ba37c3ec632301cd90355d29a7bbc34","modified":1681183827142},{"_id":"source/images/pic1.png","hash":"0c416e6f0a1aa48c6104152a71cf8f54d58f1e6c","modified":1681183827209},{"_id":"source/images/pic2.png","hash":"0731b5925237aea7ce27a0e952f4c2bc8ee79a94","modified":1681183827210},{"_id":"source/images/pic3.png","hash":"8b0bdbf27dd7495464ba86b6c41b4c16d420b8aa","modified":1681183827210},{"_id":"source/_posts/The-problem-of-mobile-web-developing/pic1.png","hash":"0c416e6f0a1aa48c6104152a71cf8f54d58f1e6c","modified":1681183827111},{"_id":"source/_posts/The-problem-of-mobile-web-developing/pic2.png","hash":"0731b5925237aea7ce27a0e952f4c2bc8ee79a94","modified":1681183827112},{"_id":"source/_posts/The-problem-of-mobile-web-developing/pic3.png","hash":"8b0bdbf27dd7495464ba86b6c41b4c16d420b8aa","modified":1681183827113},{"_id":"source/images/image-20191128142021000.png","hash":"fbbdc2d962f0c43a04b293c1d9d50fa64059f243","modified":1681183827169},{"_id":"source/images/image-20191128140108874.png","hash":"99cf1fa47bb28b03f00ac4241debcd3deba184f9","modified":1681183827169},{"_id":"source/images/image-20191128142917368.png","hash":"90d71470936f55c844f58d68cc9de10435a7d5c7","modified":1681183827171},{"_id":"source/images/image-20191128142447611.png","hash":"281583de43a2c8b0ad0c97c5a188f3776a2c4054","modified":1681183827170},{"_id":"source/images/pic4.png","hash":"0ee043d7b403a0ffa07283ef2618883243d4245a","modified":1681183827210},{"_id":"source/images/pic5.png","hash":"3e5c49f032b80a0a55cca22b11235b54f64bf0cf","modified":1681183827211},{"_id":"source/images/processing_image.gif.png","hash":"72960bb981d375188c0178bda5ceef09fe049963","modified":1681183827225},{"_id":"source/images/pic6.jpg","hash":"ad9ef3d29d77c3c7d5d03561e2ec0e83ee9ba53b","modified":1681183827212},{"_id":"source/_posts/The-problem-of-mobile-web-developing/pic4.png","hash":"0ee043d7b403a0ffa07283ef2618883243d4245a","modified":1681183827113},{"_id":"source/_posts/The-problem-of-mobile-web-developing/pic6.jpg","hash":"ad9ef3d29d77c3c7d5d03561e2ec0e83ee9ba53b","modified":1681183827115},{"_id":"source/_posts/The-problem-of-mobile-web-developing/pic5.png","hash":"3e5c49f032b80a0a55cca22b11235b54f64bf0cf","modified":1681183827114},{"_id":"source/images/git_move_file.png","hash":"ea6003667e7731e9294b2ec6447e3ff7b070a632","modified":1681183827166},{"_id":"source/images/image-20191128113937513.png","hash":"252bb2c1faa1c8e7c76b83632bf8a0d4d01e14ed","modified":1681183827168},{"_id":"source/images/jeninks_image6.png","hash":"a7ecc6c6f62cac2db1bcfeae7e9c1d156043972a","modified":1681183827176},{"_id":"source/images/image-20191128182813621.png","hash":"9e62e3470296534b1efe730285ee0a0d86e4783e","modified":1681183827174},{"_id":"source/images/image-20191128182507434.png","hash":"216bb0e00d6d1f8ce39225f3efdefdd8f57a8160","modified":1681183827173},{"_id":"source/images/jenkins_image1.png","hash":"6287a174e0f73e27ca0abd89f6e14f0c6fabbbee","modified":1681183827178},{"_id":"source/images/jenkins_image2.png","hash":"c82549d43c05d60b4f53053a1facf420e0463873","modified":1681183827183},{"_id":"source/images/jenkins_image3.png","hash":"e968a59230332c62041dd40179717f19465049a4","modified":1681183827185},{"_id":"source/images/jenkins_image4.png","hash":"d1783f515c009d5fc47202c40e649e8cf8e90205","modified":1681183827186},{"_id":"source/images/jenkins_image5.png","hash":"155a8b5614cf6105f0317f9b7d42c9a308423398","modified":1681183827188},{"_id":"source/images/jenkins_image11.png","hash":"83dbc032f52d3a3e99aaea70499446db2152522c","modified":1681183827182},{"_id":"source/images/jenkins_image10.png","hash":"3941ebe016aed3b5fffe8d98027513a615ddb713","modified":1681183827180},{"_id":"source/images/jenkins_image8.png","hash":"6ab0c7666982a7c39c9c74344e9d57b3345f88ba","modified":1681183827193},{"_id":"source/images/jenkins_image9.png","hash":"a9f12936b972c5ad017ac7ed0a52219bc97fa9f8","modified":1681183827196},{"_id":"source/images/jenkins_image7.png","hash":"8fae648c0eaa78946bf1ad76b0545cbea131481a","modified":1681183827191},{"_id":"source/images/demo3.gif","hash":"5272b4ebaab2e81080d962821efc5ad7dd98464b","modified":1681183827164},{"_id":"source/_posts/interestingCSS/demo3.gif","hash":"5272b4ebaab2e81080d962821efc5ad7dd98464b","modified":1681183827124},{"_id":"themes/obsidian/source/aplayer/docs/.nojekyll","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1668313311812},{"_id":"themes/obsidian/CHANGELOG.md","hash":"021caad135c1789fb8fade816fc9b04230b4b223","modified":1668313311805},{"_id":"themes/obsidian/.prettierignore","hash":"36612689c3688127ca3a5fdfba0d22dfc306b386","modified":1668313311805},{"_id":"themes/obsidian/.gitignore","hash":"0163bc6198f408db68e8223186b1ee6cfc58dbfd","modified":1668313311804},{"_id":"themes/obsidian/README.md","hash":"b2fbefd5cc1486384f8afe686b1f2729a796b5f4","modified":1668313311805},{"_id":"themes/obsidian/README_CN.md","hash":"a0c3aab64e0c4b712728fa6e2b468e8625367647","modified":1668313311805},{"_id":"themes/obsidian/_config_template_cn.yml","hash":"01b6fff31c1a1ce2164f3a8b6077b85e0ea4b7f5","modified":1668313311805},{"_id":"themes/obsidian/package.json","hash":"58dff57dc13b339fe6d749f97dbfb4828375f3a8","modified":1668313311808},{"_id":"themes/obsidian/LICENSE","hash":"5433bef2c6c055447443802b3538cf37adabd705","modified":1668313311805},{"_id":"themes/obsidian/CHANGELOG_CN.md","hash":"c75f1b799c1d6cd8526d2d1f8950e95ab381e45e","modified":1668313311805},{"_id":"themes/obsidian/languages/default.yml","hash":"64f341736b8cfa05a0cc6cce51b0722dbf0ad32b","modified":1668313311805},{"_id":"themes/obsidian/package-lock.json","hash":"65b2d05eeab89fbb11dea248835d2e5c58659a9e","modified":1668313311808},{"_id":"themes/obsidian/languages/fr.yml","hash":"a3bc76db5b6a644d3f777220fe7af395441b1c11","modified":1668313311806},{"_id":"themes/obsidian/languages/it.yml","hash":"edd4a16f80f2ae83ef8e537cecf2fc0d7fab89c8","modified":1668313311806},{"_id":"themes/obsidian/languages/no.yml","hash":"d972e7bef0630528747e66ac3a79d4a1dc0bf543","modified":1668313311806},{"_id":"themes/obsidian/_config.yml","hash":"c2edcac3a86a54148a632bcd73729121358dd4bb","modified":1669057448448},{"_id":"themes/obsidian/languages/ru.yml","hash":"a2f6020c6a4f687a1d6a9b582a134f72a0381c62","modified":1668313311806},{"_id":"themes/obsidian/_config_template_en.yml","hash":"6b982e23f30dcb13488dc2fae04fa270818b74f6","modified":1668313311805},{"_id":"themes/obsidian/languages/nl.yml","hash":"3344fbf73157deaccd8b87b500efe21d9a94cbc7","modified":1668313311806},{"_id":"themes/obsidian/.github/FUNDING.yml","hash":"3f874b8655bc5cf04d97e6be412840c9a3faa08e","modified":1668313311804},{"_id":"themes/obsidian/languages/zh-CN.yml","hash":"07eacfc9c19f9d9aa20e793b6a7a0e56497037f8","modified":1668313311806},{"_id":"themes/obsidian/languages/zh-TW.yml","hash":"31090af93079a84129f6b65303b75f9d3d8f46e1","modified":1668313311806},{"_id":"themes/obsidian/layout/page.ejs","hash":"db7051aba9f46e48808236a3887d440d2369d74e","modified":1668313311808},{"_id":"themes/obsidian/layout/index.ejs","hash":"7873010b22819f17b08c67edb60fa01fba94589c","modified":1668313311808},{"_id":"themes/obsidian/layout/tag.ejs","hash":"920114db892fe39fab097c4f65d8ffc9b2a76b69","modified":1668313311808},{"_id":"themes/obsidian/layout/post.ejs","hash":"e585d8b4680c52dccfc40ffa6b2c5df515bf20d2","modified":1668313311808},{"_id":"themes/obsidian/scripts/helpers/hexo-symbols-count-time.js","hash":"dc213a7d2533f4624bd6c41217657c9ab4e9ce85","modified":1668313311808},{"_id":"themes/obsidian/scripts/helpers/page_title.js","hash":"35dbc39e4edd53b20f5433dc0d1708024049186d","modified":1668313311808},{"_id":"themes/obsidian/yarn.lock","hash":"b81d44a2a4bd92aeb699cac03a15d83edb4b80ee","modified":1668313382115},{"_id":"themes/obsidian/layout/archive.ejs","hash":"17eb8f480c30e1de60e5f696942c697e20dc6d3a","modified":1668313311808},{"_id":"themes/obsidian/scripts/helpers/hexo-html-truncate.js","hash":"72733931cbe4841f3da9a680e7549718f13bd0b7","modified":1668313311808},{"_id":"themes/obsidian/layout/category.ejs","hash":"e0c36bded984989c864227801dcd289207241f76","modified":1668313311808},{"_id":"themes/obsidian/source/aplayer/package.json","hash":"420fbfe9616677997279ab5e44999f7803acefed","modified":1668313311813},{"_id":"themes/obsidian/source/aplayer/LICENSE","hash":"ae26f1f8ac172c3e6daf6a62e7e407e9b5221fac","modified":1668313311809},{"_id":"themes/obsidian/source/js/busuanzi.min.js","hash":"c31e1244ea9c6da70f306b76ea0c001486e4ea78","modified":1668313311829},{"_id":"themes/obsidian/source/js/Meting.min.js","hash":"be49f061c76145ba818a7e20b4b4515131bba32b","modified":1668313311829},{"_id":"themes/obsidian/source/js/busuanzi.js","hash":"8148df0753f8fdcddb306dc36003a6a636b44691","modified":1668313311829},{"_id":"themes/obsidian/source/js/loadaplayer.js","hash":"ec86aeb41463c3ee8602d08b21df1c7ec97ddfa1","modified":1668313311830},{"_id":"themes/obsidian/source/js/jquery.truncate.js","hash":"9bfb5e6e567458aff86e0cc4bc8c53917387ce13","modified":1668313311830},{"_id":"themes/obsidian/source/js/jquery.truncate.min.js","hash":"a71f558be59d47c2e896bea46e605eb93aa26786","modified":1668313311830},{"_id":"themes/obsidian/source/js/obsidian.js","hash":"b3595121977c127598f9108316eeaae491521a18","modified":1668313311830},{"_id":"themes/obsidian/source/aplayer/README.md","hash":"1f9abec9efec10b6112feb5c1408e2bf499aa051","modified":1668313311810},{"_id":"themes/obsidian/source/js/obsidian.min.js","hash":"609c0f9fe552687d3d4bca1f58da8bc603911410","modified":1668313311830},{"_id":"themes/obsidian/source/js/search.js","hash":"7dd6ada071decde02737645143d217906fe3fe80","modified":1668313311831},{"_id":"themes/obsidian/source/js/plugin.js","hash":"0ac6bf36a9a11ca6fad0af1f20e5705bc326abf4","modified":1668313311831},{"_id":"themes/obsidian/source/css/ball-atom.min.css","hash":"c226472e3b8f09c1a30c55a4e1575fc2b22bd4a5","modified":1668313311818},{"_id":"themes/obsidian/layout/layout.ejs","hash":"38506238848041990347d9d1a6767494ee0d9ffc","modified":1669056630404},{"_id":"themes/obsidian/source/css/codemirror.styl","hash":"b2e335244baf9703d2281eb41bbbf37ddf820713","modified":1668313311818},{"_id":"themes/obsidian/source/img/favicon.png","hash":"763e5dd543412266eb38bb66d1e2ed79391c75b6","modified":1668313311819},{"_id":"themes/obsidian/source/css/theme.styl","hash":"7a3cda7d326995d7e16dc17c2201241525b89ba1","modified":1668313311818},{"_id":"themes/obsidian/source/img/logo_icon.png","hash":"763e5dd543412266eb38bb66d1e2ed79391c75b6","modified":1668313311819},{"_id":"themes/obsidian/source/img/logo.png","hash":"956a5c90eba01360e5576178122cf29e3df1b3e4","modified":1668313311819},{"_id":"themes/obsidian/source/font/Rubik-Bold-kern-latin.woff2","hash":"5ffc50abee67c11cfe7c174e6407119dda79bffe","modified":1668313311818},{"_id":"themes/obsidian/source/font/Rubik-Regular-kern-latin.woff2","hash":"f6220f2824efbdb57afe2165886aa7e8ca9345b3","modified":1668313311818},{"_id":"themes/obsidian/layout/_partial/categories.ejs","hash":"db45b83951cd4dca8b9f1fac289e0f38e13c3dc1","modified":1668313311806},{"_id":"themes/obsidian/layout/_partial/list.ejs","hash":"8e03499580aa81ec0b4c8316347b4e3839849007","modified":1668313311806},{"_id":"themes/obsidian/layout/_partial/menu.ejs","hash":"34c14e4d39fda3f4b0f6ec7e393529ebb33c1139","modified":1668313311807},{"_id":"themes/obsidian/layout/_partial/google-analytics.ejs","hash":"4806289a1c3de19a1cc4e6242c82cdd429c3bfe8","modified":1668313311806},{"_id":"themes/obsidian/layout/_partial/pagination.ejs","hash":"23bf862b3b8a3cd831850504d9b5a24d21b005e7","modified":1668313311807},{"_id":"themes/obsidian/layout/_partial/head.ejs","hash":"dcc9c939cd5c9ab176a5a27b66e2a8c683e6e3e6","modified":1668313311806},{"_id":"themes/obsidian/scripts/libs/cheerio/cheerio.js","hash":"df60e3da86341b0474f15d9aa8547d71617cb5a9","modified":1668313311809},{"_id":"themes/obsidian/layout/_partial/mathjax.ejs","hash":"3aae1c6eb8795525090f83b4e2ab00a1c04db13d","modified":1668313311807},{"_id":"themes/obsidian/scripts/libs/cheerio/parse.js","hash":"dc8dc6f82fd1c8f33eda9442025235a3632bfa36","modified":1668313311809},{"_id":"themes/obsidian/layout/_partial/screen.ejs","hash":"919c1a9ab04ba22eac1e2e66f46e69b362dea93a","modified":1668313311807},{"_id":"themes/obsidian/scripts/libs/cheerio/static.js","hash":"36ad488d734e0d9930d0a478deacebe6d5b8c775","modified":1668313311809},{"_id":"themes/obsidian/layout/_partial/tags.ejs","hash":"fc037d52e956ed280d2d69f9683461ef86b5b453","modified":1668313311808},{"_id":"themes/obsidian/scripts/libs/cheerio/utils.js","hash":"425759c783010cd1d72771f2b8d471047a1e1285","modified":1668313311809},{"_id":"themes/obsidian/layout/_partial/scripts.ejs","hash":"eef3077d691c67c81138a07b5575dec8889134a8","modified":1668313311807},{"_id":"themes/obsidian/layout/_partial/photoswipe.ejs","hash":"9cd0571569a37aef1c6c4a5bf074dc1dc7b0558b","modified":1668313311807},{"_id":"themes/obsidian/source/aplayer/demo/demo.js","hash":"b8f47c0c112b54e068cfabbac07a6c65f4aa4907","modified":1668313311810},{"_id":"themes/obsidian/source/aplayer/demo/index.html","hash":"0c4317d84bbf6a22aeda24657d806cd222225a2b","modified":1668313311810},{"_id":"themes/obsidian/source/aplayer/webpack/dev.config.js","hash":"38486bc2e2a2e072b29f95eb049e4191b312c09e","modified":1668313311816},{"_id":"themes/obsidian/source/aplayer/webpack/prod.config.js","hash":"e8a8f69b91c0deb4ae6f88f40d1e495f9212236e","modified":1668313311816},{"_id":"themes/obsidian/source/aplayer/dist/APlayer.min.js","hash":"22caa28ff6b41a16ff40f15d38f1739e22359478","modified":1668313311812},{"_id":"themes/obsidian/source/aplayer/dist/APlayer.min.css.map","hash":"c59d2bc9472922cf6ef9a99e052dbee6cc7e6b36","modified":1668313311811},{"_id":"themes/obsidian/source/aplayer/dist/APlayer.min.css","hash":"e0702acfbbe02aa08af77ff55102ef4c80dde105","modified":1668313311811},{"_id":"themes/obsidian/source/aplayer/docs/config.js","hash":"781bf27b5073314aac6992e2bacf75783cd36f01","modified":1668313311813},{"_id":"themes/obsidian/source/aplayer/docs/README.md","hash":"ece89351b4bd0aed112291157d31e8e2e893dcb7","modified":1668313311812},{"_id":"themes/obsidian/source/aplayer/docs/index.html","hash":"94506337e896d818c0f0a4589a03d150287284c1","modified":1668313311813},{"_id":"themes/obsidian/source/aplayer/docs/landing.html","hash":"c3a5f4259529e7a42edbe3da17a4571c70b0d1a6","modified":1668313311813},{"_id":"themes/obsidian/layout/_partial/post/article.ejs","hash":"ddb124cc561f2150c67ec1090f5f064bc3c72832","modified":1668313311807},{"_id":"themes/obsidian/source/aplayer/docs/support.md","hash":"cb3fb8224a7e4f2be8917fd03a0e44ee8c8706ef","modified":1668313311813},{"_id":"themes/obsidian/source/aplayer/docs/ecosystem.md","hash":"60f428190159f6958ce66b74e2f48a307d44142f","modified":1668313311813},{"_id":"themes/obsidian/layout/_partial/post/date.ejs","hash":"6f2d1aa9562df343b797d25705f1945323c465fb","modified":1668313311807},{"_id":"themes/obsidian/layout/_partial/post/gitalk.ejs","hash":"d46d85ccccc3f431fd6f80495fe03fc906871a0e","modified":1668313311807},{"_id":"themes/obsidian/layout/_partial/post/tag.ejs","hash":"c2b4ce7e1d7eed59f4c333915cd431f008f898e3","modified":1668313311807},{"_id":"themes/obsidian/layout/_partial/post/item.ejs","hash":"94a764ed75ce19eb17527f77ac44927242c51436","modified":1668313311807},{"_id":"themes/obsidian/scripts/libs/cheerio/api/manipulation.js","hash":"93b36f7e67557d2a2f5ba65eee21a65f93c37b1f","modified":1668313311809},{"_id":"themes/obsidian/scripts/libs/cheerio/api/css.js","hash":"de88fe4f6977eab77bf080d9a688cc3f2b0d516c","modified":1668313311809},{"_id":"themes/obsidian/scripts/libs/cheerio/api/attributes.js","hash":"404a942475f8bf31dd4704d17490b25bfcdffb07","modified":1668313311809},{"_id":"themes/obsidian/layout/_partial/post/title.ejs","hash":"33f2a96f17fb1efa354c92aef906d96984abd9ab","modified":1668313311807},{"_id":"themes/obsidian/scripts/libs/cheerio/api/traversing.js","hash":"5a83ea3c18f2e73eb1b4f4e4425de932e20d38bb","modified":1668313311809},{"_id":"themes/obsidian/scripts/libs/cheerio/api/forms.js","hash":"e9d8465f092ce6c2d2e48575bfa1de7e1cbaf3bd","modified":1668313311809},{"_id":"themes/obsidian/layout/_partial/post/header.ejs","hash":"95af4961efdc1421fc62b60075672cc49bc49a2c","modified":1668313311807},{"_id":"themes/obsidian/source/aplayer/src/assets/loop-one.svg","hash":"221b3e24dae19a5dc023d9ab00253fb754b5b389","modified":1668313311814},{"_id":"themes/obsidian/source/aplayer/src/assets/loading.svg","hash":"a032e15f65605ebea9d61de5a741f836b3ff5c21","modified":1668313311813},{"_id":"themes/obsidian/source/aplayer/src/assets/lrc.svg","hash":"1f0eebc00c99da25332a4bdcb3fd7b770c59a709","modified":1668313311814},{"_id":"themes/obsidian/source/aplayer/src/assets/menu.svg","hash":"5b37ffd6adba91c42daf63a8232f2b180dcc9e49","modified":1668313311814},{"_id":"themes/obsidian/source/aplayer/src/assets/order-list.svg","hash":"d9762f52daa5da7489279bca269f86ef82100e59","modified":1668313311814},{"_id":"themes/obsidian/source/aplayer/src/assets/order-random.svg","hash":"e8328fc87b99c6bc6ed2c89cfa260dc6b1628af0","modified":1668313311814},{"_id":"themes/obsidian/source/aplayer/src/assets/pause.svg","hash":"4fc55cadd15cc6cc053b0b327f1ba72692e234d7","modified":1668313311814},{"_id":"themes/obsidian/source/aplayer/src/assets/loop-none.svg","hash":"daf74504add716b8b32ed06df236c8ab35c15faf","modified":1668313311814},{"_id":"themes/obsidian/source/aplayer/src/assets/loop-all.svg","hash":"d15f558bca9675cee9eacdbc2d1125907f6cf22f","modified":1668313311813},{"_id":"themes/obsidian/source/aplayer/src/assets/play.svg","hash":"f36398bb91f986da148f7157316f4ceaa2b42beb","modified":1668313311814},{"_id":"themes/obsidian/source/aplayer/src/assets/right.svg","hash":"d9e8211c2f4783bd69d3871330db4facb4a6780f","modified":1668313311814},{"_id":"themes/obsidian/source/aplayer/src/assets/volume-off.svg","hash":"5c8b6b0acf02070216ccaa5bdf27f05758e1033d","modified":1668313311814},{"_id":"themes/obsidian/source/aplayer/src/assets/volume-down.svg","hash":"0fe1d0f49f3ecb87584fb9ce28c55c715d3b2dfe","modified":1668313311814},{"_id":"themes/obsidian/source/aplayer/src/assets/skip.svg","hash":"5635ae52738c79b3a65e3184784bd78bc5af7b26","modified":1668313311814},{"_id":"themes/obsidian/source/aplayer/src/js/events.js","hash":"58cc17514767d6a79f14eff6c6eb75549cff54bc","modified":1668313311815},{"_id":"themes/obsidian/source/aplayer/src/js/controller.js","hash":"a1fa5f1be74a9080abf8c266de52479e1f4fe662","modified":1668313311815},{"_id":"themes/obsidian/source/aplayer/src/js/bar.js","hash":"f530658a6b2f221e624546b763b1056de7adf2e5","modified":1668313311815},{"_id":"themes/obsidian/source/aplayer/src/css/index.scss","hash":"cc4c34c197667439e7ca924cc0c45d44d505adf4","modified":1668313311814},{"_id":"themes/obsidian/source/aplayer/src/js/index.js","hash":"4b445a3e4b0183fbdbec92e1ad989b9ce05ce502","modified":1668313311815},{"_id":"themes/obsidian/source/aplayer/src/js/lrc.js","hash":"f843a16621bc204d16ae97e579fa10be89b2d76a","modified":1668313311815},{"_id":"themes/obsidian/source/aplayer/src/js/list.js","hash":"af64cfa133ffa2eb67425094a3e5a5ae4b2320ef","modified":1668313311815},{"_id":"themes/obsidian/source/aplayer/src/js/options.js","hash":"4b343773b511d73520a32082b66422278a1ab136","modified":1668313311815},{"_id":"themes/obsidian/source/aplayer/src/js/player.js","hash":"3c3e4e2806a376d65dc576eab66e020c188717af","modified":1668313311815},{"_id":"themes/obsidian/source/aplayer/src/js/storage.js","hash":"1a70813959ac37e55337958466185e0177d5dcba","modified":1668313311815},{"_id":"themes/obsidian/source/aplayer/src/assets/volume-up.svg","hash":"2d6979f5cb874ab5d14e3c0bea4e0dc40799d83a","modified":1668313311814},{"_id":"themes/obsidian/source/aplayer/src/js/utils.js","hash":"9d4829298ffbca25657d1a1ff2eb140f91e7fa6e","modified":1668313311816},{"_id":"themes/obsidian/source/aplayer/src/template/list-item.art","hash":"e61626368b30154183f8853c69405ab269e46d0b","modified":1668313311816},{"_id":"themes/obsidian/source/aplayer/src/js/template.js","hash":"10b534c119eca0a69628d57be0f7ff320700b48b","modified":1668313311815},{"_id":"themes/obsidian/source/aplayer/src/js/timer.js","hash":"4681c42cf8014b35141dbe827dd0578862a1c56a","modified":1668313311816},{"_id":"themes/obsidian/source/aplayer/src/template/lrc.art","hash":"f9bd888397d0f972f8c764797fb9354cebeafafc","modified":1668313311816},{"_id":"themes/obsidian/source/aplayer/docs/zh-Hans/ecosystem.md","hash":"93c0561a6ea190a783299843ac78fa584761847e","modified":1668313311813},{"_id":"themes/obsidian/source/aplayer/src/template/player.art","hash":"64edf17aa5b21193d051a6170c6c935ca94526ad","modified":1668313311816},{"_id":"themes/obsidian/source/aplayer/docs/zh-Hans/README.md","hash":"efb64217c6a09a382284e8c5fd73ebf7f2b2eac7","modified":1668313311813},{"_id":"themes/obsidian/source/aplayer/src/js/icons.js","hash":"b34136ffdbfe9861081eb8aaeda6331679340f0d","modified":1668313311815},{"_id":"themes/obsidian/source/aplayer/docs/zh-Hans/support.md","hash":"267028806007e6ee067765d84fa2ff1c7b263a36","modified":1668313311813},{"_id":"themes/obsidian/source/js/jquery.min.js","hash":"3f1b0e9e54af1af2db2c8a639530448723462151","modified":1668313311830},{"_id":"themes/obsidian/source/css/obsidian.styl","hash":"519777788a0b7e1872a1cc05e634d8ce135a1d92","modified":1668313311818},{"_id":"themes/obsidian/source/aplayer/dist/APlayer.js","hash":"484f100a6548d181a27fe32cfcdc9a1a548c10bc","modified":1668313311811},{"_id":"themes/obsidian/source/img/cover.jpg","hash":"b977716eb4569f06ae41747c92121d44dd0ef2ec","modified":1668313311819},{"_id":"themes/obsidian/source/aplayer/dist/APlayer.min.js.map","hash":"31a19da0f0cb6b00ec212eafa847f31af86788df","modified":1668313311812},{"_id":"source/images/demo1.gif","hash":"baf127a84161d51657bb51a27af5fdb923686045","modified":1681183827162},{"_id":"source/_posts/interestingCSS/demo1.gif","hash":"baf127a84161d51657bb51a27af5fdb923686045","modified":1681183827121},{"_id":"themes/obsidian/source/aplayer/yarn.lock","hash":"8dbed195fe8209e26307a9bde9cd99b5e38d0395","modified":1668313311817},{"_id":"themes/obsidian/source/img/welcome-cover.jpg","hash":"4f64859e7d800f527944aab1615ecc4e24467f50","modified":1668313311829},{"_id":"themes/obsidian/source/img/profile.jpg","hash":"f039e298bfe68f8edeaa2f3bf90a118852588e4e","modified":1668313311825},{"_id":"source/images/parallelism.png","hash":"219c54c74c62dfa7bd714d5cb1b2dfa3c0f83bb1","modified":1681183827209},{"_id":"source/images/concurrency.png","hash":"1120b4cc1b8c74b0606a59e1afb52f4f74bc90ec","modified":1681183827158},{"_id":"source/images/processing_image.gif","hash":"acbe7ad57dad9e05c39707a193d6a37fe156d399","modified":1681183827223},{"_id":"source/_posts/processing-medium-effect/processing_image.gif","hash":"acbe7ad57dad9e05c39707a193d6a37fe156d399","modified":1681183827141},{"_id":"themes/obsidian/source/statics/chengdu.mp3","hash":"ffff18953f07760d1e30a74e22eee49f1f7f793f","modified":1668313311859},{"_id":"public/content.json","hash":"889c36756f407c026d6562aa3c4da01366a2af8f","modified":1681184266325},{"_id":"public/about/index.html","hash":"0a7f773664a950f78a232a77b376ec48e927e7d9","modified":1681184266325},{"_id":"public/links/index.html","hash":"95aa3fbf6b446ae8462ecb13fe60c489ab05e4cb","modified":1681184266325},{"_id":"public/categories/index.html","hash":"90b2777b1a37155eeb55af0283dc03691b0d7703","modified":1681184266325},{"_id":"public/tags/index.html","hash":"c0ba1363a4841b307c214a12f9275cc2bab8ad5e","modified":1681184266325},{"_id":"public/categories/Vue/index.html","hash":"3a60d2ee912a85ea7d921ae61018d8780627b32c","modified":1681184266325},{"_id":"public/categories/Css-Less-Sass/index.html","hash":"04e8890676e5227635f748bcc31adf90804990aa","modified":1681184266325},{"_id":"public/categories/Mongodb/index.html","hash":"5ba9e0efb0db6bb6e87397ba0fc7033eff46aa0b","modified":1681184266325},{"_id":"public/categories/小程序/index.html","hash":"463db662b7ab1d7688ab3f3fc1e4ebbd589dba0e","modified":1681184266325},{"_id":"public/categories/NodeJs/index.html","hash":"579d36e5660c8a8d32f1aace34b4ef0f6a041adc","modified":1681184266325},{"_id":"public/2023/04/11/Database-Key-and-Index/index.html","hash":"2f24ed1aec0b2903682b9847cae3ea5a379cf06a","modified":1681184266325},{"_id":"public/2023/04/10/Database-Relationship/index.html","hash":"ed8e210e89be02ce14730078f877261b8211de9d","modified":1681184266325},{"_id":"public/2020/06/22/Automaticly-Build-Personal-Website-Via-Jenkins/index.html","hash":"5dd286800602dbf5e511ec87ab84161b1fb29827","modified":1681184266325},{"_id":"public/2019/12/19/Developer-Git-Situation-Solutions/index.html","hash":"1fa048805966472bae804a6ca1c6d9d8d11f8a17","modified":1681184266325},{"_id":"public/2019/11/21/Difference-Between-Concurrency-And-Parallelism/index.html","hash":"2dc28318b06986599522feb5c303beb4aebb1d8a","modified":1681184266325},{"_id":"public/2019/11/21/Frequently-Used-Docker-Container-Network-Command/index.html","hash":"1924ca593edd9d8432c6f4abeed02899a47dadc1","modified":1681184266325},{"_id":"public/2019/11/21/Frequently-Used-Docker-Repository-Command/index.html","hash":"48c5dd23bad3e9fb2721801654722c562704f423","modified":1681184266325},{"_id":"public/2019/08/11/Build-Your-Own-Cli-Tool-Via-Nodejs/index.html","hash":"645263490676f1e78ac25e741d9ae1595324a845","modified":1681184266325},{"_id":"public/2019/11/21/Frequently-Used-Git-Command/index.html","hash":"4d979d54b5d869c5464bd1904f00f4c33d7b7eb8","modified":1681184266325},{"_id":"public/2019/11/21/Frequently-Used-Docker-Container-Or-Image-Command/index.html","hash":"5939b1a23d44344da52f8c2c75380e85a6448edc","modified":1681184266325},{"_id":"public/2019/07/15/nginx-commmand-record/index.html","hash":"e6abf718cdfd214a1f43856d8f91392fc3cc6cb8","modified":1681184266325},{"_id":"public/2018/11/12/manage-Node-js-version-via-mvn/index.html","hash":"56eef2c880a25ca92757566337ebc8aa622a29b5","modified":1681184266325},{"_id":"public/2018/08/01/wechat-share-and-single-page-summary/index.html","hash":"44a1fa78e84ceb325fc085160a4b7dac51e0c402","modified":1681184266325},{"_id":"public/2018/07/08/0to1-build-vue-project/index.html","hash":"6af69d62080bfc1377b76188ff8c7b06e4826743","modified":1681184266325},{"_id":"public/2017/12/10/mediaMatch/index.html","hash":"a23a1c0b7df60a3120d1acc9e8cd8e2e985a645d","modified":1681184266325},{"_id":"public/2017/12/09/The-problem-of-mobile-web-developing/index.html","hash":"607585a881a008e58a9d3cf061d6f0b9f2885086","modified":1681184266325},{"_id":"public/2017/11/30/mongodb-command/index.html","hash":"7f5760e94463586a437b1e6d9f3b9a52c6a0e650","modified":1681184266325},{"_id":"public/2017/09/11/processing-medium-effect/index.html","hash":"f9ad7adddb130b8c0f7ffbb51259a4b798a53d88","modified":1681184266325},{"_id":"public/2017/08/09/JavaScript-Design-Patterns-and-Development-Practice/index.html","hash":"85a267eec9b3a814806a83259ff314de11ed42e1","modified":1681184266325},{"_id":"public/2017/08/06/JavascriptDataType/index.html","hash":"c8994b2ef13925f0171c3bc7a16bca83bf4cd655","modified":1681184266325},{"_id":"public/2017/08/06/SoftwareTesting/index.html","hash":"403cbc8e456b20023d62dae69b91edce22fd9e75","modified":1681184266325},{"_id":"public/2017/06/25/Javascript-data-structure/index.html","hash":"8e32546251453a58d5dc854cb88f4f52abe1fb7e","modified":1681184266325},{"_id":"public/2017/04/27/interestingCSS/index.html","hash":"55a70d1f8bcd113d4019ed600b25295a67b54f84","modified":1681184266325},{"_id":"public/index.html","hash":"91d1eb31aecbdb1b5a2b4a065e6d83fe14a80600","modified":1681184266325},{"_id":"public/page/2/index.html","hash":"f3caf21f2e63b10cdbe60f11ddae51c629ecb9a0","modified":1681184266325},{"_id":"public/page/3/index.html","hash":"5bcd8c7c93dd527a4bebb9eb1193b46cbb1465f5","modified":1681184266325},{"_id":"public/archives/index.html","hash":"f24613315739118b9231dc4ea1b399ed6bd5db17","modified":1681184266325},{"_id":"public/categories/项目构建/index.html","hash":"8e7403f68fe3980e2641f714625e9f8e2e7e387e","modified":1681184266325},{"_id":"public/categories/Database/index.html","hash":"4ba617200d1446d77f692970740653b5699ac8fe","modified":1681184266325},{"_id":"public/categories/Git/index.html","hash":"546ecd7bfa1b0cb71424f0ff2872a5a31b73bfe8","modified":1681184266325},{"_id":"public/categories/Docker/index.html","hash":"68ca31d23626ae9365e6a34572cc0463ea5fb1ad","modified":1681184266325},{"_id":"public/categories/JavaScript/index.html","hash":"c34eb11050ed6555150e378fd26ab88ed2f38b39","modified":1681184266325},{"_id":"public/tags/个人总结/index.html","hash":"82f2122674840772d2cf23d2750f29fdd28eed88","modified":1681184266325},{"_id":"public/tags/读书笔记/index.html","hash":"65bcce9a931807496687b9e831c0e23ff0041aa3","modified":1681184266325},{"_id":"public/tags/备忘翻阅/index.html","hash":"9f5906fcbd5a81796bbc244f0bc74a2b7763b5d6","modified":1681184266325},{"_id":"public/tags/每周一练/index.html","hash":"0341761dfaeee79fbf402772f507bc08eaba76b6","modified":1681184266325},{"_id":"public/tags/转载/index.html","hash":"10013f6be64a7cb6b04408db12551c3cbb992cbb","modified":1681184266325},{"_id":"public/tags/最佳实践/index.html","hash":"553b66c05a1291d62c28747a743a9a161710d4e0","modified":1681184266325},{"_id":"public/CNANE","hash":"b08d663432b1212b15f0baf6f992105bce5af6cb","modified":1681184266325},{"_id":"public/images/pic1.png","hash":"0c416e6f0a1aa48c6104152a71cf8f54d58f1e6c","modified":1681184266325},{"_id":"public/images/pic2.png","hash":"0731b5925237aea7ce27a0e952f4c2bc8ee79a94","modified":1681184266325},{"_id":"public/images/pic3.png","hash":"8b0bdbf27dd7495464ba86b6c41b4c16d420b8aa","modified":1681184266325},{"_id":"public/aplayer/LICENSE","hash":"ae26f1f8ac172c3e6daf6a62e7e407e9b5221fac","modified":1681184266325},{"_id":"public/img/logo_icon.png","hash":"763e5dd543412266eb38bb66d1e2ed79391c75b6","modified":1681184266325},{"_id":"public/img/logo.png","hash":"956a5c90eba01360e5576178122cf29e3df1b3e4","modified":1681184266325},{"_id":"public/img/favicon.png","hash":"763e5dd543412266eb38bb66d1e2ed79391c75b6","modified":1681184266325},{"_id":"public/font/Rubik-Bold-kern-latin.woff2","hash":"5ffc50abee67c11cfe7c174e6407119dda79bffe","modified":1681184266325},{"_id":"public/aplayer/src/assets/loading.svg","hash":"a032e15f65605ebea9d61de5a741f836b3ff5c21","modified":1681184266325},{"_id":"public/font/Rubik-Regular-kern-latin.woff2","hash":"f6220f2824efbdb57afe2165886aa7e8ca9345b3","modified":1681184266325},{"_id":"public/aplayer/dist/APlayer.min.css.map","hash":"c59d2bc9472922cf6ef9a99e052dbee6cc7e6b36","modified":1681184266325},{"_id":"public/aplayer/src/assets/loop-one.svg","hash":"221b3e24dae19a5dc023d9ab00253fb754b5b389","modified":1681184266325},{"_id":"public/aplayer/src/assets/loop-none.svg","hash":"daf74504add716b8b32ed06df236c8ab35c15faf","modified":1681184266325},{"_id":"public/aplayer/src/assets/lrc.svg","hash":"1f0eebc00c99da25332a4bdcb3fd7b770c59a709","modified":1681184266325},{"_id":"public/aplayer/src/assets/order-list.svg","hash":"d9762f52daa5da7489279bca269f86ef82100e59","modified":1681184266325},{"_id":"public/aplayer/src/assets/order-random.svg","hash":"e8328fc87b99c6bc6ed2c89cfa260dc6b1628af0","modified":1681184266325},{"_id":"public/aplayer/src/assets/pause.svg","hash":"4fc55cadd15cc6cc053b0b327f1ba72692e234d7","modified":1681184266325},{"_id":"public/aplayer/src/assets/menu.svg","hash":"5b37ffd6adba91c42daf63a8232f2b180dcc9e49","modified":1681184266325},{"_id":"public/aplayer/src/assets/loop-all.svg","hash":"d15f558bca9675cee9eacdbc2d1125907f6cf22f","modified":1681184266325},{"_id":"public/aplayer/src/assets/right.svg","hash":"d9e8211c2f4783bd69d3871330db4facb4a6780f","modified":1681184266325},{"_id":"public/aplayer/src/assets/skip.svg","hash":"5635ae52738c79b3a65e3184784bd78bc5af7b26","modified":1681184266325},{"_id":"public/aplayer/src/assets/volume-down.svg","hash":"0fe1d0f49f3ecb87584fb9ce28c55c715d3b2dfe","modified":1681184266325},{"_id":"public/aplayer/src/assets/volume-off.svg","hash":"5c8b6b0acf02070216ccaa5bdf27f05758e1033d","modified":1681184266325},{"_id":"public/aplayer/src/assets/volume-up.svg","hash":"2d6979f5cb874ab5d14e3c0bea4e0dc40799d83a","modified":1681184266325},{"_id":"public/aplayer/src/template/list-item.art","hash":"e61626368b30154183f8853c69405ab269e46d0b","modified":1681184266325},{"_id":"public/aplayer/src/css/index.scss","hash":"cc4c34c197667439e7ca924cc0c45d44d505adf4","modified":1681184266325},{"_id":"public/aplayer/src/assets/play.svg","hash":"f36398bb91f986da148f7157316f4ceaa2b42beb","modified":1681184266325},{"_id":"public/aplayer/src/template/player.art","hash":"64edf17aa5b21193d051a6170c6c935ca94526ad","modified":1681184266325},{"_id":"public/aplayer/src/template/lrc.art","hash":"f9bd888397d0f972f8c764797fb9354cebeafafc","modified":1681184266325},{"_id":"public/images/image-20191128140108874.png","hash":"99cf1fa47bb28b03f00ac4241debcd3deba184f9","modified":1681184266325},{"_id":"public/images/image-20191128142447611.png","hash":"281583de43a2c8b0ad0c97c5a188f3776a2c4054","modified":1681184266325},{"_id":"public/images/image-20191128142021000.png","hash":"fbbdc2d962f0c43a04b293c1d9d50fa64059f243","modified":1681184266325},{"_id":"public/images/image-20191128142917368.png","hash":"90d71470936f55c844f58d68cc9de10435a7d5c7","modified":1681184266325},{"_id":"public/aplayer/package.json","hash":"72085f63e6199b8dc0dfaa05610b63e397bd1f43","modified":1681184266325},{"_id":"public/js/Meting.min.js","hash":"be49f061c76145ba818a7e20b4b4515131bba32b","modified":1681184266325},{"_id":"public/js/busuanzi.min.js","hash":"c31e1244ea9c6da70f306b76ea0c001486e4ea78","modified":1681184266325},{"_id":"public/js/jquery.truncate.js","hash":"9bfb5e6e567458aff86e0cc4bc8c53917387ce13","modified":1681184266325},{"_id":"public/js/busuanzi.js","hash":"8148df0753f8fdcddb306dc36003a6a636b44691","modified":1681184266325},{"_id":"public/js/loadaplayer.js","hash":"ec86aeb41463c3ee8602d08b21df1c7ec97ddfa1","modified":1681184266325},{"_id":"public/js/jquery.truncate.min.js","hash":"a71f558be59d47c2e896bea46e605eb93aa26786","modified":1681184266325},{"_id":"public/js/search.js","hash":"7dd6ada071decde02737645143d217906fe3fe80","modified":1681184266325},{"_id":"public/js/obsidian.min.js","hash":"609c0f9fe552687d3d4bca1f58da8bc603911410","modified":1681184266325},{"_id":"public/css/ball-atom.min.css","hash":"c226472e3b8f09c1a30c55a4e1575fc2b22bd4a5","modified":1681184266325},{"_id":"public/aplayer/README.html","hash":"4e62891fbbd329c967ec08763bb32f34465e4849","modified":1681184266325},{"_id":"public/css/codemirror.css","hash":"d45967fa2b7e701c3d0dd62cdce0385f5c8f6961","modified":1681184266325},{"_id":"public/css/theme.css","hash":"0e5c3bdd7b08931209c816eab93ab1b62554d609","modified":1681184266325},{"_id":"public/aplayer/webpack/dev.config.js","hash":"38486bc2e2a2e072b29f95eb049e4191b312c09e","modified":1681184266325},{"_id":"public/aplayer/demo/demo.js","hash":"b8f47c0c112b54e068cfabbac07a6c65f4aa4907","modified":1681184266325},{"_id":"public/aplayer/demo/index.html","hash":"0c4317d84bbf6a22aeda24657d806cd222225a2b","modified":1681184266325},{"_id":"public/aplayer/webpack/prod.config.js","hash":"e8a8f69b91c0deb4ae6f88f40d1e495f9212236e","modified":1681184266325},{"_id":"public/aplayer/dist/APlayer.min.css","hash":"e0702acfbbe02aa08af77ff55102ef4c80dde105","modified":1681184266325},{"_id":"public/aplayer/docs/config.js","hash":"781bf27b5073314aac6992e2bacf75783cd36f01","modified":1681184266325},{"_id":"public/aplayer/docs/ecosystem.html","hash":"32e445002b6d388162ca2cd9863a543d52871efd","modified":1681184266325},{"_id":"public/aplayer/docs/index.html","hash":"94506337e896d818c0f0a4589a03d150287284c1","modified":1681184266325},{"_id":"public/aplayer/docs/support.html","hash":"fb556985584b8158e4fb9635f0649b0bf9f50280","modified":1681184266325},{"_id":"public/aplayer/src/js/events.js","hash":"58cc17514767d6a79f14eff6c6eb75549cff54bc","modified":1681184266325},{"_id":"public/aplayer/src/js/icons.js","hash":"b34136ffdbfe9861081eb8aaeda6331679340f0d","modified":1681184266325},{"_id":"public/aplayer/docs/landing.html","hash":"c3a5f4259529e7a42edbe3da17a4571c70b0d1a6","modified":1681184266325},{"_id":"public/aplayer/src/js/bar.js","hash":"f530658a6b2f221e624546b763b1056de7adf2e5","modified":1681184266325},{"_id":"public/aplayer/src/js/lrc.js","hash":"f843a16621bc204d16ae97e579fa10be89b2d76a","modified":1681184266325},{"_id":"public/aplayer/src/js/index.js","hash":"4b445a3e4b0183fbdbec92e1ad989b9ce05ce502","modified":1681184266325},{"_id":"public/aplayer/src/js/list.js","hash":"af64cfa133ffa2eb67425094a3e5a5ae4b2320ef","modified":1681184266325},{"_id":"public/aplayer/src/js/options.js","hash":"4b343773b511d73520a32082b66422278a1ab136","modified":1681184266325},{"_id":"public/aplayer/src/js/controller.js","hash":"a1fa5f1be74a9080abf8c266de52479e1f4fe662","modified":1681184266325},{"_id":"public/aplayer/src/js/player.js","hash":"3c3e4e2806a376d65dc576eab66e020c188717af","modified":1681184266325},{"_id":"public/aplayer/src/js/utils.js","hash":"9d4829298ffbca25657d1a1ff2eb140f91e7fa6e","modified":1681184266325},{"_id":"public/aplayer/src/js/template.js","hash":"10b534c119eca0a69628d57be0f7ff320700b48b","modified":1681184266325},{"_id":"public/aplayer/src/js/storage.js","hash":"1a70813959ac37e55337958466185e0177d5dcba","modified":1681184266325},{"_id":"public/aplayer/docs/zh-Hans/ecosystem.html","hash":"4834ab5017e273fbc333adfca573cdf15d3fb8ce","modified":1681184266325},{"_id":"public/aplayer/src/js/timer.js","hash":"4681c42cf8014b35141dbe827dd0578862a1c56a","modified":1681184266325},{"_id":"public/aplayer/docs/zh-Hans/support.html","hash":"b4876ccccbed564b312013ab292c2a7c51a94abe","modified":1681184266325},{"_id":"public/js/obsidian.js","hash":"b3595121977c127598f9108316eeaae491521a18","modified":1681184266325},{"_id":"public/js/jquery.min.js","hash":"3f1b0e9e54af1af2db2c8a639530448723462151","modified":1681184266325},{"_id":"public/js/plugin.js","hash":"0ac6bf36a9a11ca6fad0af1f20e5705bc326abf4","modified":1681184266325},{"_id":"public/css/obsidian.css","hash":"62822bfbc85e79250f4aef143e04dd5bc89b3ec9","modified":1681184266325},{"_id":"public/aplayer/dist/APlayer.js","hash":"484f100a6548d181a27fe32cfcdc9a1a548c10bc","modified":1681184266325},{"_id":"public/aplayer/docs/README.html","hash":"e0ba677af1e0852d73dcdb437d9d85960705a04c","modified":1681184266325},{"_id":"public/aplayer/dist/APlayer.min.js","hash":"22caa28ff6b41a16ff40f15d38f1739e22359478","modified":1681184266325},{"_id":"public/aplayer/docs/zh-Hans/README.html","hash":"e86101eb1d829c2096a2ea83658568390d20bb02","modified":1681184266325},{"_id":"public/images/pic4.png","hash":"0ee043d7b403a0ffa07283ef2618883243d4245a","modified":1681184266325},{"_id":"public/images/pic5.png","hash":"3e5c49f032b80a0a55cca22b11235b54f64bf0cf","modified":1681184266325},{"_id":"public/images/pic6.jpg","hash":"ad9ef3d29d77c3c7d5d03561e2ec0e83ee9ba53b","modified":1681184266325},{"_id":"public/images/processing_image.gif.png","hash":"72960bb981d375188c0178bda5ceef09fe049963","modified":1681184266325},{"_id":"public/img/cover.jpg","hash":"b977716eb4569f06ae41747c92121d44dd0ef2ec","modified":1681184266325},{"_id":"public/aplayer/dist/APlayer.min.js.map","hash":"31a19da0f0cb6b00ec212eafa847f31af86788df","modified":1681184266325},{"_id":"public/images/git_move_file.png","hash":"ea6003667e7731e9294b2ec6447e3ff7b070a632","modified":1681184266325},{"_id":"public/images/image-20191128113937513.png","hash":"252bb2c1faa1c8e7c76b83632bf8a0d4d01e14ed","modified":1681184266325},{"_id":"public/images/jeninks_image6.png","hash":"a7ecc6c6f62cac2db1bcfeae7e9c1d156043972a","modified":1681184266325},{"_id":"public/images/image-20191128182507434.png","hash":"216bb0e00d6d1f8ce39225f3efdefdd8f57a8160","modified":1681184266325},{"_id":"public/images/image-20191128182813621.png","hash":"9e62e3470296534b1efe730285ee0a0d86e4783e","modified":1681184266325},{"_id":"public/images/jenkins_image1.png","hash":"6287a174e0f73e27ca0abd89f6e14f0c6fabbbee","modified":1681184266325},{"_id":"public/images/jenkins_image3.png","hash":"e968a59230332c62041dd40179717f19465049a4","modified":1681184266325},{"_id":"public/images/jenkins_image2.png","hash":"c82549d43c05d60b4f53053a1facf420e0463873","modified":1681184266325},{"_id":"public/images/jenkins_image4.png","hash":"d1783f515c009d5fc47202c40e649e8cf8e90205","modified":1681184266325},{"_id":"public/images/jenkins_image5.png","hash":"155a8b5614cf6105f0317f9b7d42c9a308423398","modified":1681184266325},{"_id":"public/images/jenkins_image10.png","hash":"3941ebe016aed3b5fffe8d98027513a615ddb713","modified":1681184266325},{"_id":"public/images/jenkins_image11.png","hash":"83dbc032f52d3a3e99aaea70499446db2152522c","modified":1681184266325},{"_id":"public/images/jenkins_image7.png","hash":"8fae648c0eaa78946bf1ad76b0545cbea131481a","modified":1681184266325},{"_id":"public/images/jenkins_image8.png","hash":"6ab0c7666982a7c39c9c74344e9d57b3345f88ba","modified":1681184266325},{"_id":"public/images/jenkins_image9.png","hash":"a9f12936b972c5ad017ac7ed0a52219bc97fa9f8","modified":1681184266325},{"_id":"public/aplayer/yarn.lock","hash":"8dbed195fe8209e26307a9bde9cd99b5e38d0395","modified":1681184266325},{"_id":"public/images/demo3.gif","hash":"5272b4ebaab2e81080d962821efc5ad7dd98464b","modified":1681184266325},{"_id":"public/img/welcome-cover.jpg","hash":"4f64859e7d800f527944aab1615ecc4e24467f50","modified":1681184266325},{"_id":"public/img/profile.jpg","hash":"f039e298bfe68f8edeaa2f3bf90a118852588e4e","modified":1681184266325},{"_id":"public/images/demo1.gif","hash":"baf127a84161d51657bb51a27af5fdb923686045","modified":1681184266325},{"_id":"public/images/parallelism.png","hash":"219c54c74c62dfa7bd714d5cb1b2dfa3c0f83bb1","modified":1681184266325},{"_id":"public/images/concurrency.png","hash":"1120b4cc1b8c74b0606a59e1afb52f4f74bc90ec","modified":1681184266325},{"_id":"public/images/processing_image.gif","hash":"acbe7ad57dad9e05c39707a193d6a37fe156d399","modified":1681184266325},{"_id":"public/statics/chengdu.mp3","hash":"ffff18953f07760d1e30a74e22eee49f1f7f793f","modified":1681184266325}],"Category":[{"name":"项目构建","_id":"clgbppeb30004bvchb0d121wq"},{"name":"Vue","_id":"clgbppeb8000hbvchfcsoflcu"},{"name":"Database","_id":"clgbppeba000qbvchb56h6stl"},{"name":"Git","_id":"clgbppebd0013bvche7eu11jm"},{"name":"NodeJs","_id":"clgbppebf001bbvch7miggylh"},{"name":"Docker","_id":"clgbppebg001ibvch21vhax8c"},{"name":"JavaScript","_id":"clgbppebj0027bvchf2m21lyf"},{"name":"Css-Less-Sass","_id":"clgbppebk002lbvch7lo1b13r"},{"name":"Mongodb","_id":"clgbppebl002rbvch2b172l0n"},{"name":"小程序","_id":"clgbppebm002vbvch7fj9ejkl"}],"Data":[],"Page":[{"title":"about","date":"2017-12-09T13:02:58.000Z","_content":"\n# 我是一个","source":"about/index.md","raw":"---\ntitle: about\ndate: 2017-12-09 21:02:58\n---\n\n# 我是一个","updated":"2023-04-11T03:30:27.142Z","path":"about/index.html","comments":1,"layout":"page","_id":"clgbppeb00000bvch6yr9apld","content":"<h1><a href=\"#wo-shi-yi-ge\" class=\"header-anchor\"></a><span id=\"wo-shi-yi-ge\">我是一个</span></h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"我是一个\"><a href=\"#我是一个\" class=\"headerlink\" title=\"我是一个\"></a>我是一个</h1>"},{"_content":"<div class=\"list-with-title\">\n  <ul class=\"listing\">\n    <div class=\"listing-item\">\n      <div class=\"listing-post\">\n        <i class=\"fa fa-tag\"></i>\n        <a href=\"/categories/React/\" title=\"React\">React</a>\n      </div>\n    </div>\n    <div class=\"listing-item\">\n      <div class=\"listing-post\">\n        <i class=\"fa fa-tag\"></i>\n        <a href=\"/categories/Vue/\" title=\"Vue\">Vue</a>\n      </div>\n    </div>\n    <div class=\"listing-item\">\n      <div class=\"listing-post\">\n        <i class=\"fa fa-tag\"></i>\n        <a href=\"/categories/小程序/\" title=\"小程序\">小程序</a>\n      </div>\n    </div>\n    <div class=\"listing-item\">\n      <div class=\"listing-post\">\n        <i class=\"fa fa-tag\"></i>\n        <a href=\"/categories/JavaScript/\" title=\"JavaScript\">JavaScript</a>\n      </div>\n    </div>\n    <div class=\"listing-item\">\n      <div class=\"listing-post\">\n        <i class=\"fa fa-tag\"></i>\n        <a href=\"/categories/Css-Less-Sass/\" title=\"Css-Less-Sass\">Css-Less-Sass</a>\n      </div>\n    </div>\n    <div class=\"listing-item\">\n      <div class=\"listing-post\">\n        <i class=\"fa fa-tag\"></i>\n        <a href=\"/categories/Webpack/\" title=\"Webpack\">Webpack</a>\n      </div>\n    </div>\n    <div class=\"listing-item\">\n      <div class=\"listing-post\">\n        <i class=\"fa fa-tag\"></i>\n        <a href=\"/categories/NodeJs/\" title=\"NodeJs\">NodeJs</a>\n      </div>\n    </div>\n    <div class=\"listing-item\">\n      <div class=\"listing-post\">\n        <i class=\"fa fa-tag\"></i>\n        <a href=\"/categories/MongoDB/\" title=\"MongoDB\">MongoDB</a>\n      </div>\n    </div>\n    <div class=\"listing-item\">\n      <div class=\"listing-post\">\n        <i class=\"fa fa-tag\"></i>\n        <a href=\"/categories/Git/\" title=\"Git\">Git</a>\n      </div>\n    </div>\n    <div class=\"listing-item\">\n      <div class=\"listing-post\">\n        <i class=\"fa fa-tag\"></i>\n        <a href=\"/categories/Docker/\" title=\"Docker\">Docker</a>\n      </div>\n    </div>\n    <div class=\"listing-item\">\n      <div class=\"listing-post\">\n        <i class=\"fa fa-tag\"></i>\n        <a href=\"/categories/项目构建/\" title=\"项目构建\">项目构建</a>\n      </div>\n    </div>\n  </ul>\n</div>","source":"categories/index.html","raw":"<div class=\"list-with-title\">\n  <ul class=\"listing\">\n    <div class=\"listing-item\">\n      <div class=\"listing-post\">\n        <i class=\"fa fa-tag\"></i>\n        <a href=\"/categories/React/\" title=\"React\">React</a>\n      </div>\n    </div>\n    <div class=\"listing-item\">\n      <div class=\"listing-post\">\n        <i class=\"fa fa-tag\"></i>\n        <a href=\"/categories/Vue/\" title=\"Vue\">Vue</a>\n      </div>\n    </div>\n    <div class=\"listing-item\">\n      <div class=\"listing-post\">\n        <i class=\"fa fa-tag\"></i>\n        <a href=\"/categories/小程序/\" title=\"小程序\">小程序</a>\n      </div>\n    </div>\n    <div class=\"listing-item\">\n      <div class=\"listing-post\">\n        <i class=\"fa fa-tag\"></i>\n        <a href=\"/categories/JavaScript/\" title=\"JavaScript\">JavaScript</a>\n      </div>\n    </div>\n    <div class=\"listing-item\">\n      <div class=\"listing-post\">\n        <i class=\"fa fa-tag\"></i>\n        <a href=\"/categories/Css-Less-Sass/\" title=\"Css-Less-Sass\">Css-Less-Sass</a>\n      </div>\n    </div>\n    <div class=\"listing-item\">\n      <div class=\"listing-post\">\n        <i class=\"fa fa-tag\"></i>\n        <a href=\"/categories/Webpack/\" title=\"Webpack\">Webpack</a>\n      </div>\n    </div>\n    <div class=\"listing-item\">\n      <div class=\"listing-post\">\n        <i class=\"fa fa-tag\"></i>\n        <a href=\"/categories/NodeJs/\" title=\"NodeJs\">NodeJs</a>\n      </div>\n    </div>\n    <div class=\"listing-item\">\n      <div class=\"listing-post\">\n        <i class=\"fa fa-tag\"></i>\n        <a href=\"/categories/MongoDB/\" title=\"MongoDB\">MongoDB</a>\n      </div>\n    </div>\n    <div class=\"listing-item\">\n      <div class=\"listing-post\">\n        <i class=\"fa fa-tag\"></i>\n        <a href=\"/categories/Git/\" title=\"Git\">Git</a>\n      </div>\n    </div>\n    <div class=\"listing-item\">\n      <div class=\"listing-post\">\n        <i class=\"fa fa-tag\"></i>\n        <a href=\"/categories/Docker/\" title=\"Docker\">Docker</a>\n      </div>\n    </div>\n    <div class=\"listing-item\">\n      <div class=\"listing-post\">\n        <i class=\"fa fa-tag\"></i>\n        <a href=\"/categories/项目构建/\" title=\"项目构建\">项目构建</a>\n      </div>\n    </div>\n  </ul>\n</div>","date":"2023-04-11T03:30:27.142Z","updated":"2023-04-11T03:30:27.142Z","path":"categories/index.html","title":"","comments":1,"layout":"page","_id":"clgbppeb20002bvch8pm51rm0","content":"<div class=\"list-with-title\">\n  <ul class=\"listing\">\n    <div class=\"listing-item\">\n      <div class=\"listing-post\">\n        <i class=\"fa fa-tag\"></i>\n        <a href=\"/categories/React/\" title=\"React\">React</a>\n      </div>\n    </div>\n    <div class=\"listing-item\">\n      <div class=\"listing-post\">\n        <i class=\"fa fa-tag\"></i>\n        <a href=\"/categories/Vue/\" title=\"Vue\">Vue</a>\n      </div>\n    </div>\n    <div class=\"listing-item\">\n      <div class=\"listing-post\">\n        <i class=\"fa fa-tag\"></i>\n        <a href=\"/categories/小程序/\" title=\"小程序\">小程序</a>\n      </div>\n    </div>\n    <div class=\"listing-item\">\n      <div class=\"listing-post\">\n        <i class=\"fa fa-tag\"></i>\n        <a href=\"/categories/JavaScript/\" title=\"JavaScript\">JavaScript</a>\n      </div>\n    </div>\n    <div class=\"listing-item\">\n      <div class=\"listing-post\">\n        <i class=\"fa fa-tag\"></i>\n        <a href=\"/categories/Css-Less-Sass/\" title=\"Css-Less-Sass\">Css-Less-Sass</a>\n      </div>\n    </div>\n    <div class=\"listing-item\">\n      <div class=\"listing-post\">\n        <i class=\"fa fa-tag\"></i>\n        <a href=\"/categories/Webpack/\" title=\"Webpack\">Webpack</a>\n      </div>\n    </div>\n    <div class=\"listing-item\">\n      <div class=\"listing-post\">\n        <i class=\"fa fa-tag\"></i>\n        <a href=\"/categories/NodeJs/\" title=\"NodeJs\">NodeJs</a>\n      </div>\n    </div>\n    <div class=\"listing-item\">\n      <div class=\"listing-post\">\n        <i class=\"fa fa-tag\"></i>\n        <a href=\"/categories/MongoDB/\" title=\"MongoDB\">MongoDB</a>\n      </div>\n    </div>\n    <div class=\"listing-item\">\n      <div class=\"listing-post\">\n        <i class=\"fa fa-tag\"></i>\n        <a href=\"/categories/Git/\" title=\"Git\">Git</a>\n      </div>\n    </div>\n    <div class=\"listing-item\">\n      <div class=\"listing-post\">\n        <i class=\"fa fa-tag\"></i>\n        <a href=\"/categories/Docker/\" title=\"Docker\">Docker</a>\n      </div>\n    </div>\n    <div class=\"listing-item\">\n      <div class=\"listing-post\">\n        <i class=\"fa fa-tag\"></i>\n        <a href=\"/categories/项目构建/\" title=\"项目构建\">项目构建</a>\n      </div>\n    </div>\n  </ul>\n</div>","site":{"data":{}},"excerpt":"","more":"<div class=\"list-with-title\">\n  <ul class=\"listing\">\n    <div class=\"listing-item\">\n      <div class=\"listing-post\">\n        <i class=\"fa fa-tag\"></i>\n        <a href=\"/categories/React/\" title=\"React\">React</a>\n      </div>\n    </div>\n    <div class=\"listing-item\">\n      <div class=\"listing-post\">\n        <i class=\"fa fa-tag\"></i>\n        <a href=\"/categories/Vue/\" title=\"Vue\">Vue</a>\n      </div>\n    </div>\n    <div class=\"listing-item\">\n      <div class=\"listing-post\">\n        <i class=\"fa fa-tag\"></i>\n        <a href=\"/categories/小程序/\" title=\"小程序\">小程序</a>\n      </div>\n    </div>\n    <div class=\"listing-item\">\n      <div class=\"listing-post\">\n        <i class=\"fa fa-tag\"></i>\n        <a href=\"/categories/JavaScript/\" title=\"JavaScript\">JavaScript</a>\n      </div>\n    </div>\n    <div class=\"listing-item\">\n      <div class=\"listing-post\">\n        <i class=\"fa fa-tag\"></i>\n        <a href=\"/categories/Css-Less-Sass/\" title=\"Css-Less-Sass\">Css-Less-Sass</a>\n      </div>\n    </div>\n    <div class=\"listing-item\">\n      <div class=\"listing-post\">\n        <i class=\"fa fa-tag\"></i>\n        <a href=\"/categories/Webpack/\" title=\"Webpack\">Webpack</a>\n      </div>\n    </div>\n    <div class=\"listing-item\">\n      <div class=\"listing-post\">\n        <i class=\"fa fa-tag\"></i>\n        <a href=\"/categories/NodeJs/\" title=\"NodeJs\">NodeJs</a>\n      </div>\n    </div>\n    <div class=\"listing-item\">\n      <div class=\"listing-post\">\n        <i class=\"fa fa-tag\"></i>\n        <a href=\"/categories/MongoDB/\" title=\"MongoDB\">MongoDB</a>\n      </div>\n    </div>\n    <div class=\"listing-item\">\n      <div class=\"listing-post\">\n        <i class=\"fa fa-tag\"></i>\n        <a href=\"/categories/Git/\" title=\"Git\">Git</a>\n      </div>\n    </div>\n    <div class=\"listing-item\">\n      <div class=\"listing-post\">\n        <i class=\"fa fa-tag\"></i>\n        <a href=\"/categories/Docker/\" title=\"Docker\">Docker</a>\n      </div>\n    </div>\n    <div class=\"listing-item\">\n      <div class=\"listing-post\">\n        <i class=\"fa fa-tag\"></i>\n        <a href=\"/categories/项目构建/\" title=\"项目构建\">项目构建</a>\n      </div>\n    </div>\n  </ul>\n</div>"},{"title":"links","date":"2023-04-11T03:30:27.225Z","_content":"","source":"links/index.md","raw":"---\ntitle: links\ndate: \n---\n","updated":"2023-04-11T03:30:27.225Z","path":"links/index.html","comments":1,"layout":"page","_id":"clgbppeb40006bvch7om97fii","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"<div class=\"list-with-title\">\n  <ul class=\"listing\">\n    <div class=\"listing-item\">\n      <div class=\"listing-post\">\n        <i class=\"fa fa-tag\"></i>\n        <a href=\"/tags/个人总结/\" title=\"个人总结\">个人总结</a>\n      </div>\n    </div>\n    <div class=\"listing-item\">\n      <div class=\"listing-post\">\n        <i class=\"fa fa-tag\"></i>\n        <a href=\"/tags/读书笔记/\" title=\"读书笔记\">读书笔记</a>\n      </div>\n    </div>\n    <div class=\"listing-item\">\n      <div class=\"listing-post\">\n        <i class=\"fa fa-tag\"></i>\n        <a href=\"/tags/最佳实践/\" title=\"最佳实践\">最佳实践</a>\n      </div>\n    </div>\n    <div class=\"listing-item\">\n      <div class=\"listing-post\">\n        <i class=\"fa fa-tag\"></i>\n        <a href=\"/tags/备忘翻阅/\" title=\"备忘翻阅\">备忘翻阅</a>\n      </div>\n    </div>\n    <div class=\"listing-item\">\n      <div class=\"listing-post\">\n        <i class=\"fa fa-tag\"></i>\n        <a href=\"/tags/每周一练/\" title=\"每周一练\">每周一练</a>\n      </div>\n    </div>\n    <div class=\"listing-item\">\n      <div class=\"listing-post\">\n        <i class=\"fa fa-tag\"></i>\n        <a href=\"/tags/转载/\" title=\"转载\">转载</a>\n      </div>\n    </div>\n  </ul>\n</div>","source":"tags/index.html","raw":"<div class=\"list-with-title\">\n  <ul class=\"listing\">\n    <div class=\"listing-item\">\n      <div class=\"listing-post\">\n        <i class=\"fa fa-tag\"></i>\n        <a href=\"/tags/个人总结/\" title=\"个人总结\">个人总结</a>\n      </div>\n    </div>\n    <div class=\"listing-item\">\n      <div class=\"listing-post\">\n        <i class=\"fa fa-tag\"></i>\n        <a href=\"/tags/读书笔记/\" title=\"读书笔记\">读书笔记</a>\n      </div>\n    </div>\n    <div class=\"listing-item\">\n      <div class=\"listing-post\">\n        <i class=\"fa fa-tag\"></i>\n        <a href=\"/tags/最佳实践/\" title=\"最佳实践\">最佳实践</a>\n      </div>\n    </div>\n    <div class=\"listing-item\">\n      <div class=\"listing-post\">\n        <i class=\"fa fa-tag\"></i>\n        <a href=\"/tags/备忘翻阅/\" title=\"备忘翻阅\">备忘翻阅</a>\n      </div>\n    </div>\n    <div class=\"listing-item\">\n      <div class=\"listing-post\">\n        <i class=\"fa fa-tag\"></i>\n        <a href=\"/tags/每周一练/\" title=\"每周一练\">每周一练</a>\n      </div>\n    </div>\n    <div class=\"listing-item\">\n      <div class=\"listing-post\">\n        <i class=\"fa fa-tag\"></i>\n        <a href=\"/tags/转载/\" title=\"转载\">转载</a>\n      </div>\n    </div>\n  </ul>\n</div>","date":"2023-04-11T03:30:27.225Z","updated":"2023-04-11T03:30:27.225Z","path":"tags/index.html","title":"","comments":1,"layout":"page","_id":"clgbppeb50008bvch863n4uz1","content":"<div class=\"list-with-title\">\n  <ul class=\"listing\">\n    <div class=\"listing-item\">\n      <div class=\"listing-post\">\n        <i class=\"fa fa-tag\"></i>\n        <a href=\"/tags/个人总结/\" title=\"个人总结\">个人总结</a>\n      </div>\n    </div>\n    <div class=\"listing-item\">\n      <div class=\"listing-post\">\n        <i class=\"fa fa-tag\"></i>\n        <a href=\"/tags/读书笔记/\" title=\"读书笔记\">读书笔记</a>\n      </div>\n    </div>\n    <div class=\"listing-item\">\n      <div class=\"listing-post\">\n        <i class=\"fa fa-tag\"></i>\n        <a href=\"/tags/最佳实践/\" title=\"最佳实践\">最佳实践</a>\n      </div>\n    </div>\n    <div class=\"listing-item\">\n      <div class=\"listing-post\">\n        <i class=\"fa fa-tag\"></i>\n        <a href=\"/tags/备忘翻阅/\" title=\"备忘翻阅\">备忘翻阅</a>\n      </div>\n    </div>\n    <div class=\"listing-item\">\n      <div class=\"listing-post\">\n        <i class=\"fa fa-tag\"></i>\n        <a href=\"/tags/每周一练/\" title=\"每周一练\">每周一练</a>\n      </div>\n    </div>\n    <div class=\"listing-item\">\n      <div class=\"listing-post\">\n        <i class=\"fa fa-tag\"></i>\n        <a href=\"/tags/转载/\" title=\"转载\">转载</a>\n      </div>\n    </div>\n  </ul>\n</div>","site":{"data":{}},"excerpt":"","more":"<div class=\"list-with-title\">\n  <ul class=\"listing\">\n    <div class=\"listing-item\">\n      <div class=\"listing-post\">\n        <i class=\"fa fa-tag\"></i>\n        <a href=\"/tags/个人总结/\" title=\"个人总结\">个人总结</a>\n      </div>\n    </div>\n    <div class=\"listing-item\">\n      <div class=\"listing-post\">\n        <i class=\"fa fa-tag\"></i>\n        <a href=\"/tags/读书笔记/\" title=\"读书笔记\">读书笔记</a>\n      </div>\n    </div>\n    <div class=\"listing-item\">\n      <div class=\"listing-post\">\n        <i class=\"fa fa-tag\"></i>\n        <a href=\"/tags/最佳实践/\" title=\"最佳实践\">最佳实践</a>\n      </div>\n    </div>\n    <div class=\"listing-item\">\n      <div class=\"listing-post\">\n        <i class=\"fa fa-tag\"></i>\n        <a href=\"/tags/备忘翻阅/\" title=\"备忘翻阅\">备忘翻阅</a>\n      </div>\n    </div>\n    <div class=\"listing-item\">\n      <div class=\"listing-post\">\n        <i class=\"fa fa-tag\"></i>\n        <a href=\"/tags/每周一练/\" title=\"每周一练\">每周一练</a>\n      </div>\n    </div>\n    <div class=\"listing-item\">\n      <div class=\"listing-post\">\n        <i class=\"fa fa-tag\"></i>\n        <a href=\"/tags/转载/\" title=\"转载\">转载</a>\n      </div>\n    </div>\n  </ul>\n</div>"}],"Post":[{"title":"使用Jenkins自动化构建你的个人网站","date":"2020-06-22T10:49:00.000Z","_content":"## 前言\n\n首先想要做这个自动化构建的初衷是，最近网站备案信息作了更改，我需要重新备案，但是现在备案可比几年前的时候严格多了，导致了现在网站的内容有好多不符合规范，因此我把个人网站修改了之后，再提交审核，结果又出现了其他问题被拒绝回来再次需要修改，这样来来回回搞了好几回，因为我的个人网站都是静态网站，每次修改后都要手动把代码发布到服务器上，这样的重复性工作显得很繁琐，所以研究了一下怎么用工具自动化构建自己的网站。\n\n## 使用Docker在电脑上运行 Jenkins 平台\n\n首先拉取Jenkins镜像，我使用的网易的蜂巢镜像源，镜像地址是：`hubhub.c.163.com/library/jenkins:latest`。[镜像仓库地址（需要登录才能查看）](https://c.163yun.com/hub#/library/repository/info?repoId=3093)  \n\n运行命令`docker pull hub.c.163.com/library/jenkins:latest` 把镜像拉取到本地，然后为了日后使用方便，我们给这个镜像打上一个标签：\n\n```\ndocker tag hubhub.c.163.com/library/jenkins:latest cubesuger/jenkins\n```\n\n> 我这里是使用cubeSuger/jenknis这个名称\n\n根据这个镜像的使用说明，我们需要映射 8080 和 50000 端口，那我们使用下面的命令来运行这个镜像：\n\n```\ndocker run -p 8080:8080 -p 50000:50000 --name jenkins -v D:/docker/docker-file/jenkins:/var/jenkins_home cubesuger/jenkins\n```\n\n> -p 是映射端口，--name 是为运行镜像所创建的容器添加一个名称（名称为 jenkins）, -v 是把 Jenkins 的配置和插件保存到我们的磁盘上\n\n执行后等待一会儿，便会看到下面内容便是成功启动了 Jenknis。\n\n```\nINFO:\n\n*************************************************************\n*************************************************************\n*************************************************************\n\nJenkins initial setup is required. An admin user has been created and a password generated.\nPlease use the following password to proceed to installation:\n\n91a3b5b09eea439689e5faead48e9891\n\nThis may also be found at: /var/jenkins_home/secrets/initialAdminPassword\n\n*************************************************************\n*************************************************************\n*************************************************************\n\n--> setting agent port for jnlp\n--> setting agent port for jnlp... done\n```\n\n> 注意这里包含了一个密码串`91a3b5b09eea439689e5faead48e9891`，这个密码串会在接下来的登录中用到\n\n在浏览器打开 `localhost:8080` 就会看到jenkins的初始化界面：\n\n![jenkins_image1](/images/jenkins_image1.png)\n\n我们填上Jenkins的默认密码串，密码串可以在刚刚启动时输出的内容中找到。找不到的也可以到`/var/jenkins_home/secrets/initialAdminPassword`这个目录下用文件编辑器打开查看。（`/var/jenkins_home`这个目录我们映射到了`D:/docker/docker-file/jenkins`这个目录中，所以可以在电脑上直接到这个目录上打开查看，而不用在容器中用cat命令查看）\n\n输入后便会跳转到用户管理界面，这个时候最好修改一下原始密码，防止以后忘记要进入容器中寻找。\n\n一般来说我们从蜂巢上下载下来的Jenkins版本会相对老一些，这时候我们应该对jenkins做升级，防止因为版本而出现问题。\n\n## 更新Jenkins\n\n我们可以从清华镜像中下载最新版本的Jenkins，[（下载地址：://mirrors.tuna.tsinghua.edu.cn/jenkins/war/latest/）](https://mirrors.tuna.tsinghua.edu.cn/jenkins/war/latest/)，打开后选择下载jenkins.war即可，然后我们把下载好的文件移动到刚刚我们给容器共享的目录中（这里我设置的目录是：D:/docker/docker-file/jenkins），然后我们执行命令以root身份进入容器：\n\n```\ndocker exec -it -u root [containerID] /bin/bash\n``` \n\n> 注：containerID 就是创建容器是的ID。\n\n> 默认情况下会以 jenkins 这个用户进入容器，但是这个用户只能操作jenkins_home下的目录，所以要更新jenkins版本，就要用root用户进入容器进行操作。\n\n\n然后我们查看当前jenkins的war包在哪里，点击设置，查看系统信息\n\n等重启完毕后就能看到新版本的Jenkins在运行了：\n\n![jenkins_image2](/images/jenkins_image2.png)\n\n\n## 更新国内源\n\n默认情况下Jenkins会使用国外的地址进行更新和插件下载，这些地址访问时可能会非常慢，因此如果出现这种现象的时候，我们应该把更新地址改为国内的镜像地址。更新为国内源需要两步：\n\n1. 修改`jenkins_home/update`目录下`default`文件里的地址，因为我们在启动容器的时候做了映射，所以这个文件可以在`D:\\docker\\docker-file\\jenkins\\updates`这个目录中找到，打开`default`文件，把里面的`http://www.google.com/`全部改成`http://www.baidu.com/`，把`http://updates.jenkins-ci.org/download/`全部改成`https://mirrors.tuna.tsinghua.edu.cn/jenkins/`，然后保存修改。\n2. 打开jenkins控制台，进入插件管理，点击Advanced（高级）,在最下面的update site 中填写`https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json`这个地址，点击submit（提交）然后等待刷新然后重启就可以了。\n\n修改完成后可以发现插件的更新速度有了明显的提升。\n\n## 安装必要的插件\n\n接下来安装必要的插件来完成我们的自动化构建。\n\n### 汉化插件\n\n对于英文不好的朋友，可以先去安装一个汉化插件，名字叫 Localization Chinese(Simplified)。安装完后重启就可以看到汉化后的界面了。\n\n\n![](/images/jenkins_image3.png)\n\n### 安装git插件\n\n在插件中搜索git并安装，一般来说在安装git的过程中会把凭证插件也安装上，所以就不用手动去安装凭证插件了，如果发现没有安装凭证插件，则需要手动安装一下。\n\n### 安装并配置凭证插件\n\n要想自动化构建网站，首先要可以获取到构建网站的代码，这就涉及到安全验证的问题，比如GitHub的私有仓库就有两种方式来获取代码，ssh和用户密码。还有我们有时候在构建好代码后，需要登录到服务器上把构建好的代码放到指定目录上去，也需要用到凭证。\n\n安装Credentials Binding插件，安装完成后重启jenkins。\n\n重启完成后点击管理凭证，然后点击全局，添加一个凭证，这里可以选择 用户名和密码 、ssh等方式。选择自己想要的验证方式并且配置就可以了。用户名和密码比较简单，这里就列举比较复杂的ssh方式：\n\n首先进入到容器中生成公钥和私钥[（这里参考GitHub上的教程）：](https://help.github.com/en/github/authenticating-to-github/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent)\n\n输入命令然后按回车即可：\n\n`ssh-keygen -t rsa -b 4096 -C \"your_email@example.com\"`\n\n然后执行命令把秘钥添加到ssh-agent中：\n\n`eval \"$(ssh-agent -s)\"`\n\n然后把新生成的秘钥添加到GitHub上[（参考）](https://help.github.com/en/github/authenticating-to-github/adding-a-new-ssh-key-to-your-github-account)\n\n最后在jenkins的凭证中配置：\n\n![jenkins_image4](/images/jenkins_image4.png)\n\n私钥中选中在容器中创建的 `~/.ssh/id_rsa`，然后保存即可。\n\n### 安装Node.js\n\n搜索node.js插件并安装，安装完成后到系统管理，全局工具配置中配置Node.js。\n\n\n![jenkins_image5](/images/jenkins_image5.png)\n\n这里我选择安装了两个版本的Node.js，都是使用从nodejs.org官网上的安装方法，如果你的项目有使用到一些全局的包也可以在下面的`Global npm packages to install`选项中配置。\n\n### 安装Publish Over SSH\n\n当我们把项目在容器中构建好后，就需要把构建好的代码发送到生产服务器上，这个时候就需要用到这个插件：`Publish Over SSH`\n\n搜索`Publish Over SSH`插件并安装，安装好在系统管理——系统配置中配置`Publish Over SSH`。\n\n![jeninks_image6](/images/jeninks_image6.png)\n\n这样就可以在构建流程中使用了。\n\n### 创建工作流程\n\n首先创建一个自由风格的项目，给项目起个名字，然后就进入到了构建流程配置中：\n\n![jenkins_image7](/images/jenkins_image7.png)\n\n1. 可以给项目添加一个描述\n2. 然后在源码管理中选择git，添加git仓库地址，凭证选择之前创建好的凭证，分支选择你需要构建的分支即可。\n3. 如果在构建之前需要登录服务器把之前的旧目录删除，则可以在构建环境中勾选`Send files or execute commands over SSH before the build starts`，然后选择之前配置好的服务器，在`Exec command`中编写命令：\n\n![jenkins_image8](/images/jenkins_image8.png)\n\n4. 勾选紧接着的`Provide Node & npm bin/ folder to PATH`，然后选择当前项目需要用到的Node.js版本。\n\n![jenkins_image9](/images/jenkins_image9.png)\n\n5. 然后在构建中输入需要执行的构建命令。\n\n![jenkins_image10](/images/jenkins_image10.png)\n\n6. 最后把构建好的代码发送到生产服务器上。\n\n![jenkins_image11](/images/jenkins_image11.png)\n\n\n点击保存后就可以进行构建了。\n\n第一次构建的时候需要安装node.js和一些全局的npm包，所以等待的时间会久一些，之后的构建速度就快很多了。\n\n## 结尾\n\n至此，我们就已经完成了使用Jenkins来自动化构建自己的网站应用了。","source":"_posts/Automaticly-Build-Personal-Website-Via-Jenkins.md","raw":"title: 使用Jenkins自动化构建你的个人网站\ntags:\n  - 个人总结\ncategories:\n  - 项目构建\ndate: 2020-06-22 18:49:00\n---\n## 前言\n\n首先想要做这个自动化构建的初衷是，最近网站备案信息作了更改，我需要重新备案，但是现在备案可比几年前的时候严格多了，导致了现在网站的内容有好多不符合规范，因此我把个人网站修改了之后，再提交审核，结果又出现了其他问题被拒绝回来再次需要修改，这样来来回回搞了好几回，因为我的个人网站都是静态网站，每次修改后都要手动把代码发布到服务器上，这样的重复性工作显得很繁琐，所以研究了一下怎么用工具自动化构建自己的网站。\n\n## 使用Docker在电脑上运行 Jenkins 平台\n\n首先拉取Jenkins镜像，我使用的网易的蜂巢镜像源，镜像地址是：`hubhub.c.163.com/library/jenkins:latest`。[镜像仓库地址（需要登录才能查看）](https://c.163yun.com/hub#/library/repository/info?repoId=3093)  \n\n运行命令`docker pull hub.c.163.com/library/jenkins:latest` 把镜像拉取到本地，然后为了日后使用方便，我们给这个镜像打上一个标签：\n\n```\ndocker tag hubhub.c.163.com/library/jenkins:latest cubesuger/jenkins\n```\n\n> 我这里是使用cubeSuger/jenknis这个名称\n\n根据这个镜像的使用说明，我们需要映射 8080 和 50000 端口，那我们使用下面的命令来运行这个镜像：\n\n```\ndocker run -p 8080:8080 -p 50000:50000 --name jenkins -v D:/docker/docker-file/jenkins:/var/jenkins_home cubesuger/jenkins\n```\n\n> -p 是映射端口，--name 是为运行镜像所创建的容器添加一个名称（名称为 jenkins）, -v 是把 Jenkins 的配置和插件保存到我们的磁盘上\n\n执行后等待一会儿，便会看到下面内容便是成功启动了 Jenknis。\n\n```\nINFO:\n\n*************************************************************\n*************************************************************\n*************************************************************\n\nJenkins initial setup is required. An admin user has been created and a password generated.\nPlease use the following password to proceed to installation:\n\n91a3b5b09eea439689e5faead48e9891\n\nThis may also be found at: /var/jenkins_home/secrets/initialAdminPassword\n\n*************************************************************\n*************************************************************\n*************************************************************\n\n--> setting agent port for jnlp\n--> setting agent port for jnlp... done\n```\n\n> 注意这里包含了一个密码串`91a3b5b09eea439689e5faead48e9891`，这个密码串会在接下来的登录中用到\n\n在浏览器打开 `localhost:8080` 就会看到jenkins的初始化界面：\n\n![jenkins_image1](/images/jenkins_image1.png)\n\n我们填上Jenkins的默认密码串，密码串可以在刚刚启动时输出的内容中找到。找不到的也可以到`/var/jenkins_home/secrets/initialAdminPassword`这个目录下用文件编辑器打开查看。（`/var/jenkins_home`这个目录我们映射到了`D:/docker/docker-file/jenkins`这个目录中，所以可以在电脑上直接到这个目录上打开查看，而不用在容器中用cat命令查看）\n\n输入后便会跳转到用户管理界面，这个时候最好修改一下原始密码，防止以后忘记要进入容器中寻找。\n\n一般来说我们从蜂巢上下载下来的Jenkins版本会相对老一些，这时候我们应该对jenkins做升级，防止因为版本而出现问题。\n\n## 更新Jenkins\n\n我们可以从清华镜像中下载最新版本的Jenkins，[（下载地址：://mirrors.tuna.tsinghua.edu.cn/jenkins/war/latest/）](https://mirrors.tuna.tsinghua.edu.cn/jenkins/war/latest/)，打开后选择下载jenkins.war即可，然后我们把下载好的文件移动到刚刚我们给容器共享的目录中（这里我设置的目录是：D:/docker/docker-file/jenkins），然后我们执行命令以root身份进入容器：\n\n```\ndocker exec -it -u root [containerID] /bin/bash\n``` \n\n> 注：containerID 就是创建容器是的ID。\n\n> 默认情况下会以 jenkins 这个用户进入容器，但是这个用户只能操作jenkins_home下的目录，所以要更新jenkins版本，就要用root用户进入容器进行操作。\n\n\n然后我们查看当前jenkins的war包在哪里，点击设置，查看系统信息\n\n等重启完毕后就能看到新版本的Jenkins在运行了：\n\n![jenkins_image2](/images/jenkins_image2.png)\n\n\n## 更新国内源\n\n默认情况下Jenkins会使用国外的地址进行更新和插件下载，这些地址访问时可能会非常慢，因此如果出现这种现象的时候，我们应该把更新地址改为国内的镜像地址。更新为国内源需要两步：\n\n1. 修改`jenkins_home/update`目录下`default`文件里的地址，因为我们在启动容器的时候做了映射，所以这个文件可以在`D:\\docker\\docker-file\\jenkins\\updates`这个目录中找到，打开`default`文件，把里面的`http://www.google.com/`全部改成`http://www.baidu.com/`，把`http://updates.jenkins-ci.org/download/`全部改成`https://mirrors.tuna.tsinghua.edu.cn/jenkins/`，然后保存修改。\n2. 打开jenkins控制台，进入插件管理，点击Advanced（高级）,在最下面的update site 中填写`https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json`这个地址，点击submit（提交）然后等待刷新然后重启就可以了。\n\n修改完成后可以发现插件的更新速度有了明显的提升。\n\n## 安装必要的插件\n\n接下来安装必要的插件来完成我们的自动化构建。\n\n### 汉化插件\n\n对于英文不好的朋友，可以先去安装一个汉化插件，名字叫 Localization Chinese(Simplified)。安装完后重启就可以看到汉化后的界面了。\n\n\n![](/images/jenkins_image3.png)\n\n### 安装git插件\n\n在插件中搜索git并安装，一般来说在安装git的过程中会把凭证插件也安装上，所以就不用手动去安装凭证插件了，如果发现没有安装凭证插件，则需要手动安装一下。\n\n### 安装并配置凭证插件\n\n要想自动化构建网站，首先要可以获取到构建网站的代码，这就涉及到安全验证的问题，比如GitHub的私有仓库就有两种方式来获取代码，ssh和用户密码。还有我们有时候在构建好代码后，需要登录到服务器上把构建好的代码放到指定目录上去，也需要用到凭证。\n\n安装Credentials Binding插件，安装完成后重启jenkins。\n\n重启完成后点击管理凭证，然后点击全局，添加一个凭证，这里可以选择 用户名和密码 、ssh等方式。选择自己想要的验证方式并且配置就可以了。用户名和密码比较简单，这里就列举比较复杂的ssh方式：\n\n首先进入到容器中生成公钥和私钥[（这里参考GitHub上的教程）：](https://help.github.com/en/github/authenticating-to-github/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent)\n\n输入命令然后按回车即可：\n\n`ssh-keygen -t rsa -b 4096 -C \"your_email@example.com\"`\n\n然后执行命令把秘钥添加到ssh-agent中：\n\n`eval \"$(ssh-agent -s)\"`\n\n然后把新生成的秘钥添加到GitHub上[（参考）](https://help.github.com/en/github/authenticating-to-github/adding-a-new-ssh-key-to-your-github-account)\n\n最后在jenkins的凭证中配置：\n\n![jenkins_image4](/images/jenkins_image4.png)\n\n私钥中选中在容器中创建的 `~/.ssh/id_rsa`，然后保存即可。\n\n### 安装Node.js\n\n搜索node.js插件并安装，安装完成后到系统管理，全局工具配置中配置Node.js。\n\n\n![jenkins_image5](/images/jenkins_image5.png)\n\n这里我选择安装了两个版本的Node.js，都是使用从nodejs.org官网上的安装方法，如果你的项目有使用到一些全局的包也可以在下面的`Global npm packages to install`选项中配置。\n\n### 安装Publish Over SSH\n\n当我们把项目在容器中构建好后，就需要把构建好的代码发送到生产服务器上，这个时候就需要用到这个插件：`Publish Over SSH`\n\n搜索`Publish Over SSH`插件并安装，安装好在系统管理——系统配置中配置`Publish Over SSH`。\n\n![jeninks_image6](/images/jeninks_image6.png)\n\n这样就可以在构建流程中使用了。\n\n### 创建工作流程\n\n首先创建一个自由风格的项目，给项目起个名字，然后就进入到了构建流程配置中：\n\n![jenkins_image7](/images/jenkins_image7.png)\n\n1. 可以给项目添加一个描述\n2. 然后在源码管理中选择git，添加git仓库地址，凭证选择之前创建好的凭证，分支选择你需要构建的分支即可。\n3. 如果在构建之前需要登录服务器把之前的旧目录删除，则可以在构建环境中勾选`Send files or execute commands over SSH before the build starts`，然后选择之前配置好的服务器，在`Exec command`中编写命令：\n\n![jenkins_image8](/images/jenkins_image8.png)\n\n4. 勾选紧接着的`Provide Node & npm bin/ folder to PATH`，然后选择当前项目需要用到的Node.js版本。\n\n![jenkins_image9](/images/jenkins_image9.png)\n\n5. 然后在构建中输入需要执行的构建命令。\n\n![jenkins_image10](/images/jenkins_image10.png)\n\n6. 最后把构建好的代码发送到生产服务器上。\n\n![jenkins_image11](/images/jenkins_image11.png)\n\n\n点击保存后就可以进行构建了。\n\n第一次构建的时候需要安装node.js和一些全局的npm包，所以等待的时间会久一些，之后的构建速度就快很多了。\n\n## 结尾\n\n至此，我们就已经完成了使用Jenkins来自动化构建自己的网站应用了。","slug":"Automaticly-Build-Personal-Website-Via-Jenkins","published":1,"updated":"2023-04-11T03:30:27.109Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgbppeb10001bvchhjlx7uhv","content":"<h2><a href=\"#qian-yan\" class=\"header-anchor\"></a><span id=\"qian-yan\">前言</span></h2><p>首先想要做这个自动化构建的初衷是，最近网站备案信息作了更改，我需要重新备案，但是现在备案可比几年前的时候严格多了，导致了现在网站的内容有好多不符合规范，因此我把个人网站修改了之后，再提交审核，结果又出现了其他问题被拒绝回来再次需要修改，这样来来回回搞了好几回，因为我的个人网站都是静态网站，每次修改后都要手动把代码发布到服务器上，这样的重复性工作显得很繁琐，所以研究了一下怎么用工具自动化构建自己的网站。</p>\n<h2><a href=\"#shi-yong-docker-zai-dian-nao-shang-yun-xing-jenkins-ping-tai\" class=\"header-anchor\"></a><span id=\"shi-yong-docker-zai-dian-nao-shang-yun-xing-jenkins-ping-tai\">使用Docker在电脑上运行 Jenkins 平台</span></h2><p>首先拉取Jenkins镜像，我使用的网易的蜂巢镜像源，镜像地址是：<code>hubhub.c.163.com/library/jenkins:latest</code>。<a href=\"https://c.163yun.com/hub#/library/repository/info?repoId=3093\">镜像仓库地址（需要登录才能查看）</a>  </p>\n<p>运行命令<code>docker pull hub.c.163.com/library/jenkins:latest</code> 把镜像拉取到本地，然后为了日后使用方便，我们给这个镜像打上一个标签：</p>\n<pre><code>docker tag hubhub.c.163.com/library/jenkins:latest cubesuger/jenkins\n</code></pre>\n<blockquote>\n<p>我这里是使用cubeSuger&#x2F;jenknis这个名称</p>\n</blockquote>\n<p>根据这个镜像的使用说明，我们需要映射 8080 和 50000 端口，那我们使用下面的命令来运行这个镜像：</p>\n<pre><code>docker run -p 8080:8080 -p 50000:50000 --name jenkins -v D:/docker/docker-file/jenkins:/var/jenkins_home cubesuger/jenkins\n</code></pre>\n<blockquote>\n<p>-p 是映射端口，–name 是为运行镜像所创建的容器添加一个名称（名称为 jenkins）, -v 是把 Jenkins 的配置和插件保存到我们的磁盘上</p>\n</blockquote>\n<p>执行后等待一会儿，便会看到下面内容便是成功启动了 Jenknis。</p>\n<pre><code>INFO:\n\n*************************************************************\n*************************************************************\n*************************************************************\n\nJenkins initial setup is required. An admin user has been created and a password generated.\nPlease use the following password to proceed to installation:\n\n91a3b5b09eea439689e5faead48e9891\n\nThis may also be found at: /var/jenkins_home/secrets/initialAdminPassword\n\n*************************************************************\n*************************************************************\n*************************************************************\n\n--&gt; setting agent port for jnlp\n--&gt; setting agent port for jnlp... done\n</code></pre>\n<blockquote>\n<p>注意这里包含了一个密码串<code>91a3b5b09eea439689e5faead48e9891</code>，这个密码串会在接下来的登录中用到</p>\n</blockquote>\n<p>在浏览器打开 <code>localhost:8080</code> 就会看到jenkins的初始化界面：</p>\n<p><img src=\"/images/jenkins_image1.png\" alt=\"jenkins_image1\"></p>\n<p>我们填上Jenkins的默认密码串，密码串可以在刚刚启动时输出的内容中找到。找不到的也可以到<code>/var/jenkins_home/secrets/initialAdminPassword</code>这个目录下用文件编辑器打开查看。（<code>/var/jenkins_home</code>这个目录我们映射到了<code>D:/docker/docker-file/jenkins</code>这个目录中，所以可以在电脑上直接到这个目录上打开查看，而不用在容器中用cat命令查看）</p>\n<p>输入后便会跳转到用户管理界面，这个时候最好修改一下原始密码，防止以后忘记要进入容器中寻找。</p>\n<p>一般来说我们从蜂巢上下载下来的Jenkins版本会相对老一些，这时候我们应该对jenkins做升级，防止因为版本而出现问题。</p>\n<h2><a href=\"#geng-xin-jenkins\" class=\"header-anchor\"></a><span id=\"geng-xin-jenkins\">更新Jenkins</span></h2><p>我们可以从清华镜像中下载最新版本的Jenkins，<a href=\"https://mirrors.tuna.tsinghua.edu.cn/jenkins/war/latest/\">（下载地址：:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;jenkins&#x2F;war&#x2F;latest&#x2F;）</a>，打开后选择下载jenkins.war即可，然后我们把下载好的文件移动到刚刚我们给容器共享的目录中（这里我设置的目录是：D:&#x2F;docker&#x2F;docker-file&#x2F;jenkins），然后我们执行命令以root身份进入容器：</p>\n<pre><code>docker exec -it -u root [containerID] /bin/bash\n</code></pre>\n<blockquote>\n<p>注：containerID 就是创建容器是的ID。</p>\n</blockquote>\n<blockquote>\n<p>默认情况下会以 jenkins 这个用户进入容器，但是这个用户只能操作jenkins_home下的目录，所以要更新jenkins版本，就要用root用户进入容器进行操作。</p>\n</blockquote>\n<p>然后我们查看当前jenkins的war包在哪里，点击设置，查看系统信息</p>\n<p>等重启完毕后就能看到新版本的Jenkins在运行了：</p>\n<p><img src=\"/images/jenkins_image2.png\" alt=\"jenkins_image2\"></p>\n<h2><a href=\"#geng-xin-guo-nei-yuan\" class=\"header-anchor\"></a><span id=\"geng-xin-guo-nei-yuan\">更新国内源</span></h2><p>默认情况下Jenkins会使用国外的地址进行更新和插件下载，这些地址访问时可能会非常慢，因此如果出现这种现象的时候，我们应该把更新地址改为国内的镜像地址。更新为国内源需要两步：</p>\n<ol>\n<li>修改<code>jenkins_home/update</code>目录下<code>default</code>文件里的地址，因为我们在启动容器的时候做了映射，所以这个文件可以在<code>D:\\docker\\docker-file\\jenkins\\updates</code>这个目录中找到，打开<code>default</code>文件，把里面的<code>http://www.google.com/</code>全部改成<code>http://www.baidu.com/</code>，把<code>http://updates.jenkins-ci.org/download/</code>全部改成<code>https://mirrors.tuna.tsinghua.edu.cn/jenkins/</code>，然后保存修改。</li>\n<li>打开jenkins控制台，进入插件管理，点击Advanced（高级）,在最下面的update site 中填写<code>https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json</code>这个地址，点击submit（提交）然后等待刷新然后重启就可以了。</li>\n</ol>\n<p>修改完成后可以发现插件的更新速度有了明显的提升。</p>\n<h2><a href=\"#an-zhuang-bi-yao-de-cha-jian\" class=\"header-anchor\"></a><span id=\"an-zhuang-bi-yao-de-cha-jian\">安装必要的插件</span></h2><p>接下来安装必要的插件来完成我们的自动化构建。</p>\n<h3><a href=\"#han-hua-cha-jian\" class=\"header-anchor\"></a><span id=\"han-hua-cha-jian\">汉化插件</span></h3><p>对于英文不好的朋友，可以先去安装一个汉化插件，名字叫 Localization Chinese(Simplified)。安装完后重启就可以看到汉化后的界面了。</p>\n<p><img src=\"/images/jenkins_image3.png\"></p>\n<h3><a href=\"#an-zhuang-git-cha-jian\" class=\"header-anchor\"></a><span id=\"an-zhuang-git-cha-jian\">安装git插件</span></h3><p>在插件中搜索git并安装，一般来说在安装git的过程中会把凭证插件也安装上，所以就不用手动去安装凭证插件了，如果发现没有安装凭证插件，则需要手动安装一下。</p>\n<h3><a href=\"#an-zhuang-bing-pei-zhi-ping-zheng-cha-jian\" class=\"header-anchor\"></a><span id=\"an-zhuang-bing-pei-zhi-ping-zheng-cha-jian\">安装并配置凭证插件</span></h3><p>要想自动化构建网站，首先要可以获取到构建网站的代码，这就涉及到安全验证的问题，比如GitHub的私有仓库就有两种方式来获取代码，ssh和用户密码。还有我们有时候在构建好代码后，需要登录到服务器上把构建好的代码放到指定目录上去，也需要用到凭证。</p>\n<p>安装Credentials Binding插件，安装完成后重启jenkins。</p>\n<p>重启完成后点击管理凭证，然后点击全局，添加一个凭证，这里可以选择 用户名和密码 、ssh等方式。选择自己想要的验证方式并且配置就可以了。用户名和密码比较简单，这里就列举比较复杂的ssh方式：</p>\n<p>首先进入到容器中生成公钥和私钥<a href=\"https://help.github.com/en/github/authenticating-to-github/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent\">（这里参考GitHub上的教程）：</a></p>\n<p>输入命令然后按回车即可：</p>\n<p><code>ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;</code></p>\n<p>然后执行命令把秘钥添加到ssh-agent中：</p>\n<p><code>eval &quot;$(ssh-agent -s)&quot;</code></p>\n<p>然后把新生成的秘钥添加到GitHub上<a href=\"https://help.github.com/en/github/authenticating-to-github/adding-a-new-ssh-key-to-your-github-account\">（参考）</a></p>\n<p>最后在jenkins的凭证中配置：</p>\n<p><img src=\"/images/jenkins_image4.png\" alt=\"jenkins_image4\"></p>\n<p>私钥中选中在容器中创建的 <code>~/.ssh/id_rsa</code>，然后保存即可。</p>\n<h3><a href=\"#an-zhuang-node-js\" class=\"header-anchor\"></a><span id=\"an-zhuang-node-js\">安装Node.js</span></h3><p>搜索node.js插件并安装，安装完成后到系统管理，全局工具配置中配置Node.js。</p>\n<p><img src=\"/images/jenkins_image5.png\" alt=\"jenkins_image5\"></p>\n<p>这里我选择安装了两个版本的Node.js，都是使用从nodejs.org官网上的安装方法，如果你的项目有使用到一些全局的包也可以在下面的<code>Global npm packages to install</code>选项中配置。</p>\n<h3><a href=\"#an-zhuang-publish-over-ssh\" class=\"header-anchor\"></a><span id=\"an-zhuang-publish-over-ssh\">安装Publish Over SSH</span></h3><p>当我们把项目在容器中构建好后，就需要把构建好的代码发送到生产服务器上，这个时候就需要用到这个插件：<code>Publish Over SSH</code></p>\n<p>搜索<code>Publish Over SSH</code>插件并安装，安装好在系统管理——系统配置中配置<code>Publish Over SSH</code>。</p>\n<p><img src=\"/images/jeninks_image6.png\" alt=\"jeninks_image6\"></p>\n<p>这样就可以在构建流程中使用了。</p>\n<h3><a href=\"#chuang-jian-gong-zuo-liu-cheng\" class=\"header-anchor\"></a><span id=\"chuang-jian-gong-zuo-liu-cheng\">创建工作流程</span></h3><p>首先创建一个自由风格的项目，给项目起个名字，然后就进入到了构建流程配置中：</p>\n<p><img src=\"/images/jenkins_image7.png\" alt=\"jenkins_image7\"></p>\n<ol>\n<li>可以给项目添加一个描述</li>\n<li>然后在源码管理中选择git，添加git仓库地址，凭证选择之前创建好的凭证，分支选择你需要构建的分支即可。</li>\n<li>如果在构建之前需要登录服务器把之前的旧目录删除，则可以在构建环境中勾选<code>Send files or execute commands over SSH before the build starts</code>，然后选择之前配置好的服务器，在<code>Exec command</code>中编写命令：</li>\n</ol>\n<p><img src=\"/images/jenkins_image8.png\" alt=\"jenkins_image8\"></p>\n<ol start=\"4\">\n<li>勾选紧接着的<code>Provide Node &amp; npm bin/ folder to PATH</code>，然后选择当前项目需要用到的Node.js版本。</li>\n</ol>\n<p><img src=\"/images/jenkins_image9.png\" alt=\"jenkins_image9\"></p>\n<ol start=\"5\">\n<li>然后在构建中输入需要执行的构建命令。</li>\n</ol>\n<p><img src=\"/images/jenkins_image10.png\" alt=\"jenkins_image10\"></p>\n<ol start=\"6\">\n<li>最后把构建好的代码发送到生产服务器上。</li>\n</ol>\n<p><img src=\"/images/jenkins_image11.png\" alt=\"jenkins_image11\"></p>\n<p>点击保存后就可以进行构建了。</p>\n<p>第一次构建的时候需要安装node.js和一些全局的npm包，所以等待的时间会久一些，之后的构建速度就快很多了。</p>\n<h2><a href=\"#jie-wei\" class=\"header-anchor\"></a><span id=\"jie-wei\">结尾</span></h2><p>至此，我们就已经完成了使用Jenkins来自动化构建自己的网站应用了。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>首先想要做这个自动化构建的初衷是，最近网站备案信息作了更改，我需要重新备案，但是现在备案可比几年前的时候严格多了，导致了现在网站的内容有好多不符合规范，因此我把个人网站修改了之后，再提交审核，结果又出现了其他问题被拒绝回来再次需要修改，这样来来回回搞了好几回，因为我的个人网站都是静态网站，每次修改后都要手动把代码发布到服务器上，这样的重复性工作显得很繁琐，所以研究了一下怎么用工具自动化构建自己的网站。</p>\n<h2 id=\"使用Docker在电脑上运行-Jenkins-平台\"><a href=\"#使用Docker在电脑上运行-Jenkins-平台\" class=\"headerlink\" title=\"使用Docker在电脑上运行 Jenkins 平台\"></a>使用Docker在电脑上运行 Jenkins 平台</h2><p>首先拉取Jenkins镜像，我使用的网易的蜂巢镜像源，镜像地址是：<code>hubhub.c.163.com/library/jenkins:latest</code>。<a href=\"https://c.163yun.com/hub#/library/repository/info?repoId=3093\">镜像仓库地址（需要登录才能查看）</a>  </p>\n<p>运行命令<code>docker pull hub.c.163.com/library/jenkins:latest</code> 把镜像拉取到本地，然后为了日后使用方便，我们给这个镜像打上一个标签：</p>\n<pre><code>docker tag hubhub.c.163.com/library/jenkins:latest cubesuger/jenkins\n</code></pre>\n<blockquote>\n<p>我这里是使用cubeSuger&#x2F;jenknis这个名称</p>\n</blockquote>\n<p>根据这个镜像的使用说明，我们需要映射 8080 和 50000 端口，那我们使用下面的命令来运行这个镜像：</p>\n<pre><code>docker run -p 8080:8080 -p 50000:50000 --name jenkins -v D:/docker/docker-file/jenkins:/var/jenkins_home cubesuger/jenkins\n</code></pre>\n<blockquote>\n<p>-p 是映射端口，–name 是为运行镜像所创建的容器添加一个名称（名称为 jenkins）, -v 是把 Jenkins 的配置和插件保存到我们的磁盘上</p>\n</blockquote>\n<p>执行后等待一会儿，便会看到下面内容便是成功启动了 Jenknis。</p>\n<pre><code>INFO:\n\n*************************************************************\n*************************************************************\n*************************************************************\n\nJenkins initial setup is required. An admin user has been created and a password generated.\nPlease use the following password to proceed to installation:\n\n91a3b5b09eea439689e5faead48e9891\n\nThis may also be found at: /var/jenkins_home/secrets/initialAdminPassword\n\n*************************************************************\n*************************************************************\n*************************************************************\n\n--&gt; setting agent port for jnlp\n--&gt; setting agent port for jnlp... done\n</code></pre>\n<blockquote>\n<p>注意这里包含了一个密码串<code>91a3b5b09eea439689e5faead48e9891</code>，这个密码串会在接下来的登录中用到</p>\n</blockquote>\n<p>在浏览器打开 <code>localhost:8080</code> 就会看到jenkins的初始化界面：</p>\n<p><img src=\"/images/jenkins_image1.png\" alt=\"jenkins_image1\"></p>\n<p>我们填上Jenkins的默认密码串，密码串可以在刚刚启动时输出的内容中找到。找不到的也可以到<code>/var/jenkins_home/secrets/initialAdminPassword</code>这个目录下用文件编辑器打开查看。（<code>/var/jenkins_home</code>这个目录我们映射到了<code>D:/docker/docker-file/jenkins</code>这个目录中，所以可以在电脑上直接到这个目录上打开查看，而不用在容器中用cat命令查看）</p>\n<p>输入后便会跳转到用户管理界面，这个时候最好修改一下原始密码，防止以后忘记要进入容器中寻找。</p>\n<p>一般来说我们从蜂巢上下载下来的Jenkins版本会相对老一些，这时候我们应该对jenkins做升级，防止因为版本而出现问题。</p>\n<h2 id=\"更新Jenkins\"><a href=\"#更新Jenkins\" class=\"headerlink\" title=\"更新Jenkins\"></a>更新Jenkins</h2><p>我们可以从清华镜像中下载最新版本的Jenkins，<a href=\"https://mirrors.tuna.tsinghua.edu.cn/jenkins/war/latest/\">（下载地址：:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;jenkins&#x2F;war&#x2F;latest&#x2F;）</a>，打开后选择下载jenkins.war即可，然后我们把下载好的文件移动到刚刚我们给容器共享的目录中（这里我设置的目录是：D:&#x2F;docker&#x2F;docker-file&#x2F;jenkins），然后我们执行命令以root身份进入容器：</p>\n<pre><code>docker exec -it -u root [containerID] /bin/bash\n</code></pre>\n<blockquote>\n<p>注：containerID 就是创建容器是的ID。</p>\n</blockquote>\n<blockquote>\n<p>默认情况下会以 jenkins 这个用户进入容器，但是这个用户只能操作jenkins_home下的目录，所以要更新jenkins版本，就要用root用户进入容器进行操作。</p>\n</blockquote>\n<p>然后我们查看当前jenkins的war包在哪里，点击设置，查看系统信息</p>\n<p>等重启完毕后就能看到新版本的Jenkins在运行了：</p>\n<p><img src=\"/images/jenkins_image2.png\" alt=\"jenkins_image2\"></p>\n<h2 id=\"更新国内源\"><a href=\"#更新国内源\" class=\"headerlink\" title=\"更新国内源\"></a>更新国内源</h2><p>默认情况下Jenkins会使用国外的地址进行更新和插件下载，这些地址访问时可能会非常慢，因此如果出现这种现象的时候，我们应该把更新地址改为国内的镜像地址。更新为国内源需要两步：</p>\n<ol>\n<li>修改<code>jenkins_home/update</code>目录下<code>default</code>文件里的地址，因为我们在启动容器的时候做了映射，所以这个文件可以在<code>D:\\docker\\docker-file\\jenkins\\updates</code>这个目录中找到，打开<code>default</code>文件，把里面的<code>http://www.google.com/</code>全部改成<code>http://www.baidu.com/</code>，把<code>http://updates.jenkins-ci.org/download/</code>全部改成<code>https://mirrors.tuna.tsinghua.edu.cn/jenkins/</code>，然后保存修改。</li>\n<li>打开jenkins控制台，进入插件管理，点击Advanced（高级）,在最下面的update site 中填写<code>https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json</code>这个地址，点击submit（提交）然后等待刷新然后重启就可以了。</li>\n</ol>\n<p>修改完成后可以发现插件的更新速度有了明显的提升。</p>\n<h2 id=\"安装必要的插件\"><a href=\"#安装必要的插件\" class=\"headerlink\" title=\"安装必要的插件\"></a>安装必要的插件</h2><p>接下来安装必要的插件来完成我们的自动化构建。</p>\n<h3 id=\"汉化插件\"><a href=\"#汉化插件\" class=\"headerlink\" title=\"汉化插件\"></a>汉化插件</h3><p>对于英文不好的朋友，可以先去安装一个汉化插件，名字叫 Localization Chinese(Simplified)。安装完后重启就可以看到汉化后的界面了。</p>\n<p><img src=\"/images/jenkins_image3.png\"></p>\n<h3 id=\"安装git插件\"><a href=\"#安装git插件\" class=\"headerlink\" title=\"安装git插件\"></a>安装git插件</h3><p>在插件中搜索git并安装，一般来说在安装git的过程中会把凭证插件也安装上，所以就不用手动去安装凭证插件了，如果发现没有安装凭证插件，则需要手动安装一下。</p>\n<h3 id=\"安装并配置凭证插件\"><a href=\"#安装并配置凭证插件\" class=\"headerlink\" title=\"安装并配置凭证插件\"></a>安装并配置凭证插件</h3><p>要想自动化构建网站，首先要可以获取到构建网站的代码，这就涉及到安全验证的问题，比如GitHub的私有仓库就有两种方式来获取代码，ssh和用户密码。还有我们有时候在构建好代码后，需要登录到服务器上把构建好的代码放到指定目录上去，也需要用到凭证。</p>\n<p>安装Credentials Binding插件，安装完成后重启jenkins。</p>\n<p>重启完成后点击管理凭证，然后点击全局，添加一个凭证，这里可以选择 用户名和密码 、ssh等方式。选择自己想要的验证方式并且配置就可以了。用户名和密码比较简单，这里就列举比较复杂的ssh方式：</p>\n<p>首先进入到容器中生成公钥和私钥<a href=\"https://help.github.com/en/github/authenticating-to-github/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent\">（这里参考GitHub上的教程）：</a></p>\n<p>输入命令然后按回车即可：</p>\n<p><code>ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;</code></p>\n<p>然后执行命令把秘钥添加到ssh-agent中：</p>\n<p><code>eval &quot;$(ssh-agent -s)&quot;</code></p>\n<p>然后把新生成的秘钥添加到GitHub上<a href=\"https://help.github.com/en/github/authenticating-to-github/adding-a-new-ssh-key-to-your-github-account\">（参考）</a></p>\n<p>最后在jenkins的凭证中配置：</p>\n<p><img src=\"/images/jenkins_image4.png\" alt=\"jenkins_image4\"></p>\n<p>私钥中选中在容器中创建的 <code>~/.ssh/id_rsa</code>，然后保存即可。</p>\n<h3 id=\"安装Node-js\"><a href=\"#安装Node-js\" class=\"headerlink\" title=\"安装Node.js\"></a>安装Node.js</h3><p>搜索node.js插件并安装，安装完成后到系统管理，全局工具配置中配置Node.js。</p>\n<p><img src=\"/images/jenkins_image5.png\" alt=\"jenkins_image5\"></p>\n<p>这里我选择安装了两个版本的Node.js，都是使用从nodejs.org官网上的安装方法，如果你的项目有使用到一些全局的包也可以在下面的<code>Global npm packages to install</code>选项中配置。</p>\n<h3 id=\"安装Publish-Over-SSH\"><a href=\"#安装Publish-Over-SSH\" class=\"headerlink\" title=\"安装Publish Over SSH\"></a>安装Publish Over SSH</h3><p>当我们把项目在容器中构建好后，就需要把构建好的代码发送到生产服务器上，这个时候就需要用到这个插件：<code>Publish Over SSH</code></p>\n<p>搜索<code>Publish Over SSH</code>插件并安装，安装好在系统管理——系统配置中配置<code>Publish Over SSH</code>。</p>\n<p><img src=\"/images/jeninks_image6.png\" alt=\"jeninks_image6\"></p>\n<p>这样就可以在构建流程中使用了。</p>\n<h3 id=\"创建工作流程\"><a href=\"#创建工作流程\" class=\"headerlink\" title=\"创建工作流程\"></a>创建工作流程</h3><p>首先创建一个自由风格的项目，给项目起个名字，然后就进入到了构建流程配置中：</p>\n<p><img src=\"/images/jenkins_image7.png\" alt=\"jenkins_image7\"></p>\n<ol>\n<li>可以给项目添加一个描述</li>\n<li>然后在源码管理中选择git，添加git仓库地址，凭证选择之前创建好的凭证，分支选择你需要构建的分支即可。</li>\n<li>如果在构建之前需要登录服务器把之前的旧目录删除，则可以在构建环境中勾选<code>Send files or execute commands over SSH before the build starts</code>，然后选择之前配置好的服务器，在<code>Exec command</code>中编写命令：</li>\n</ol>\n<p><img src=\"/images/jenkins_image8.png\" alt=\"jenkins_image8\"></p>\n<ol start=\"4\">\n<li>勾选紧接着的<code>Provide Node &amp; npm bin/ folder to PATH</code>，然后选择当前项目需要用到的Node.js版本。</li>\n</ol>\n<p><img src=\"/images/jenkins_image9.png\" alt=\"jenkins_image9\"></p>\n<ol start=\"5\">\n<li>然后在构建中输入需要执行的构建命令。</li>\n</ol>\n<p><img src=\"/images/jenkins_image10.png\" alt=\"jenkins_image10\"></p>\n<ol start=\"6\">\n<li>最后把构建好的代码发送到生产服务器上。</li>\n</ol>\n<p><img src=\"/images/jenkins_image11.png\" alt=\"jenkins_image11\"></p>\n<p>点击保存后就可以进行构建了。</p>\n<p>第一次构建的时候需要安装node.js和一些全局的npm包，所以等待的时间会久一些，之后的构建速度就快很多了。</p>\n<h2 id=\"结尾\"><a href=\"#结尾\" class=\"headerlink\" title=\"结尾\"></a>结尾</h2><p>至此，我们就已经完成了使用Jenkins来自动化构建自己的网站应用了。</p>\n"},{"layout":"[post]","title":"自建一个node cli工具","date":"2019-08-11T08:28:00.000Z","_content":"cli——**命令行界面**（英语：**command-line interface**），我们可以通过cli提供的特定命令执行、操作对应功能。\n\n一个cli工具可以看作是一个工具包再外套上cli，通过cli上提供命令和参数在命令行界面上与人交互，然后完成命令对应的功能。所以在自建一个cli工具之前，首先应该明确它的作用是什么（解决什么问题），应该包含什么功能。还有一点最重要的是，**现在网上是否已经有满足需求的现成cli 工具可以直接使用**（有宝马还造什么自行车 🤪🤪🤪）。\n\n### 目录结构 & 工作流程\n\n首先在工程目录下新建一个文件夹，并新建`bin`目录存放命令执行的文件和`lib`目录存放命令调用的相应模块。\n\n```\n/bin  # ------ 命令执行文件\n/lib  # ------ 工具模块\npackage.json\n```\n\n`package.json`包含了对cli的相关描述，与其它普通的项目类似，但有一个地方需要特别注意的是，`package.json`下的`bin`参数，**它定义了cli被调用的脚本命令名称及入口文件**，比如：\n\n```\n{\n    \"name\":'tmc-cli'\n    ...\n    \"bin\": {\n      \"tmc\": \"index.js\"\n    }\n    ...\n}\n```\n\n上面的`bin`字段说明了这个`cli`的命令是`tmc`，当用户在输入`tmc`时就会去当前目录下的`bin`文件夹执行`index.js`文件。\n\n### 实践步骤\n\n1. 设置命令\n\n   在`bin`目录下新建一个`index.js`作为入口文件。然后在`index.js`里写入以下代码：\n\n```javascript\n#!/usr/bin/env node\n\nconst program = require('commander') // npm i commander -D\n\nprogram.version('1.0.0')\n  .usage('<command> [项目名称]')\n  .command('hello', 'hello')\n  .command('init', '创建新项目')\n  .parse(process.argv)\n```\n\n​\t\t上面代码设置了`tmc`命令可以执行的`option`分别是`hello`和`init`，因为没有在`commander`里设置了`command`而没有调用`action`，所以当执行了相应的命令时，在调用了`parse`方法后，`commander`会自动去找当前文件目录下对应与命令同名的js文件并执行，如果文件不存在则会报错。对应的源码如下：\n\n```javascript\n// node_modules/commander/index.js\n\nCommand.prototype.parse = function(argv) {\n  // implicit help\n  if (this.executables) this.addImplicitHelpCommand();\n\n  // store raw args\n  this.rawArgs = argv;\n\n  // guess name\n  this._name = this._name || basename(argv[1], '.js');\n\n  // github-style sub-commands with no sub-command\n  if (this.executables && argv.length < 3 && !this.defaultExecutable) {\n    // this user needs help\n    argv.push('--help');\n  }\n \t... \n}\n```\n\n2. 编写对应命令的执行逻辑\n\n   这个部分就是来实现命令相应的功能的，可以像普通Node程序那样对文件进行处理等等。比如在执行`init`操作后`tmc`会去我的一个仓库拉去模板代码，然后再根据我输入的一些选项来进行更细化的操作。\n\n   Tmc-init.js代码如下：\n\n   ```javascript\n   #!/usr/bin/env node\n   \n   const program = require('commander')\n   const path = require('path')\n   const fs = require('fs')\n   const glob = require('glob')\n   const download = require('../lib/download')\n   const inquirer = require('inquirer')\n   const chalk = require('chalk')\n   const logSymbols = require('log-symbols')\n   const generator = require('../lib/generator')\n   \n   program.usage('<project-name>').parse(process.argv)\n   \n   // 获取新建项目名称\n   let projectName = program.args[0]\n   \n   if (!projectName) { // project-name 必填\n     // 相当于执行命令的--help选项，显示help信息，这是commander内置的一个命令选项\n     program.help()\n     return\n   }\n   \n   const rootName = path.basename(process.cwd()) // 获取当前路径\n   const list = glob.sync('*') // 遍历当前目录\n   \n   let next = undefined\n   \n   const inquirerList = [{\n     name: 'projectVersion',\n     message: '项目的版本',\n     type: 'input',\n     default: '0.1.0',\n   }, {\n     name: 'projectDescription',\n     message: '项目的描述',\n     type: 'input',\n     default: 'test',\n   }, {\n     name: 'author',\n     message: '项目的作者',\n     type: 'input',\n     default: 'kuntang',\n   }]\n   \n   if (list.length) { // 如果当前目录不为空\n     if (list.filter(name => {\n         const fileName = path.resolve(process.cwd(), path.join('.', name))\n         const isDir = fs.statSync(fileName).isDirectory()\n         return name.indexOf(projectName) !== -1 && isDir\n       }).length !== 0) {\n       console.log(`项目${projectName}已经存在`)\n       return\n     }\n     next = inquirer.prompt(inquirerList).then(answer => {\n       return Promise.resolve({\n         projectPath: projectName,\n         ...answer\n       })\n     })\n   } else if (rootName === projectName) {\n     next = inquirer.prompt([{\n       name: 'projectPath',\n       message: '当前目录为空，且目录名称和项目名称相同，是否直接在当前目录下创建新项目？',\n       type: 'confirm',\n       default: true\n     }, ...inquirerList]).then(answer => {\n       return Promise.resolve({\n         projectPath: answer.buildInCurrent ? '.' : projectName,\n         ...answer\n       })\n     })\n   } else {\n     next = inquirer.prompt(inquirerList).then(answer => {\n       return Promise.resolve({\n         projectPath: projectName,\n         ...answer\n       })\n     })\n   }\n   \n   next && initialization()\n   \n   function initialization() {\n     next.then(answer => {\n       const {\n         projectPath,\n         projectVersion,\n         projectDescription,\n         author,\n       } = answer\n       if (projectPath !== '.') {\n         fs.mkdirSync(projectPath)\n       }\n       return download(projectPath).then(downloadTempPath => {\n         return {\n           projectName,\n           projectVersion,\n           projectDescription,\n           projectPath,\n           author,\n           downloadTemp: downloadTempPath,\n         }\n       })\n     }).then(context => {\n       const src = path.join(process.cwd(), context.downloadTemp)\n       const dest = path.join(process.cwd(), context.projectPath)\n       return generator(context, src, dest)\n     }).then(context => {\n       // 成功用绿色显示，给出积极的反馈\n       console.log(logSymbols.success, chalk.green('创建成功:)'))\n       console.log()\n       console.log(chalk.green('cd ' + context.root + '\\nnpm install\\nnpm run dev'))\n     }).catch(error => {\n       // 失败了用红色，增强提示\n       console.error(logSymbols.error, chalk.red(`创建失败：${error.message}`))\n     })\n   }\n   ```\n\n   Lib/download.js:\n\n   ```javascript\n   const download = require('download-git-repo')\n   const ora = require('ora')\n   const path = require('path')\n   \n   module.exports = function(dest) {\n     dest = path.join(dest || '.', '.download-temp')\n     return new Promise((resolve, reject) => {\n       const url = 'https://github.com:kunkuntang/react-typescript-scaffold#template'\n       const spinner = ora(`正在下载项目模板，源地址：${url}`)\n       spinner.start()\n         // 这里可以根据具体的模板地址设置下载的url，注意，如果是git，url后面的branch不能忽略\n       download(url,\n         dest, { clone: true }, (err) => {\n           if (err) {\n             spinner.fail() // wrong :(\n             reject(err)\n           } else {\n             spinner.succeed() // ok :)\n               // 下载的模板存放在一个临时路径中，下载完成后，可以向下通知这个临时路径，以便后续处理\n             resolve(dest)\n           }\n         })\n     })\n   }\n   ```\n\n   lib/generator.js:\n\n   ```javascript\n   const Metalsmith = require('metalsmith')\n   const Handlebars = require('handlebars')\n   const rm = require('rimraf').sync\n   \n   module.exports = function(metadata = {}, src, dest = '.') {\n     if (!src) {\n       return Promise.reject(new Error(`无效的source：${src}`))\n     }\n   \n     return new Promise((resolve, reject) => {\n       Metalsmith(process.cwd())\n         .metadata(metadata)\n         .clean(false)\n         .source(src)\n         .destination(dest)\n         .use((files, metalsmith, done) => {\n           const meta = metalsmith.metadata()\n           Object.keys(files).forEach(fileName => {\n             if (fileName.includes('package.json')) {\n               const t = files[fileName].contents.toString()\n               files[fileName].contents = new Buffer.from(Handlebars.compile(t)(meta))\n             }\n           })\n           done()\n         }).build(err => {\n           rm(src)\n           err ? reject(err) : resolve({\n             root: dest\n           })\n         })\n     })\n   }\n   ```\n\n   3. 发布到npm\n\n      \n\n### Commander 使用\n\ncommander是Node 命令行交互的一个工具，使用它可以创建自己想要的Node命令。\n\nCommander有几个基本概念：\n\n- version option\n\n- option\n- command & action\n\n#### version\n\n指定`cli`的版本号。\n\n```javascript\nconst program = require('commander')\nprogram\n  .version('0.0.1', '-v, --version')\n```\n\n#### Option parsing\n\noption是用来为commander命令添加一个选项的，用户可以不同的选项来能行特定的功能。\n\n```javascript\n#!/usr/bin/env node\n \n/**\n * Module dependencies.\n */\n \nvar program = require('commander');\n \nprogram\n  .version('0.1.0')\n  .option('-p, --peppers', 'Add peppers')\n  .option('-P, --pineapple', 'Add pineapple')\n  .option('-b, --bbq-sauce', 'Add bbq sauce')\n  .option('-c, --cheese [type]', 'Add the specified type of cheese [marble]', 'marble')\n  .parse(process.argv);\n \nconsole.log('you ordered a pizza with:');\nif (program.peppers) console.log('  - peppers');\nif (program.pineapple) console.log('  - pineapple');\nif (program.bbqSauce) console.log('  - bbq');\nconsole.log('  - %s cheese', program.cheese);\n```\n\n在Node.js中，用户输入的参数可以通过`process.argv`得到。`commander`的`option`只定义不处理用户输入的参数，需要显式将`process.argv`传入到`parse`方法调用才能处理。\n\n连续输入参数`-abc`等同于`-a -b -c`，在`cli`输入`--template-engine`，在`commander`可以通过`program.templateEngine`驼峰命名取得。\n\n通过给选项加`--no`前缀可以给它设置为`false`，如设置`--no-sauce`后从`program.sauce`取到的是`false`。\n\n要想拿到选项后输入的值，可以设置中括号（选填）或者尖括号（必填），如`.option('-m --myarg [myVar]', 'my option var')`或`.option('-m --myarg <myVar>', 'my require var')`，然后可以这样来取得值`var myInput = program.myarg`。\n\n#### Command 子命令\n\n**`Command`是一个特殊的`option`**，通过设置子命令可以让工具根据入参来实现的特定的小任务，并且对于子命令也可以像主命令一样设置它的`option`。\n\n```javascript\n#!/usr/bin/env node\n \nvar program = require('commander');\n \nprogram\n  .command('rm <dir>')\n  .option('-r, --recursive', 'Remove recursively')\n  .action(function (dir, cmd) {\n    console.log('remove ' + dir + (cmd.recursive ? ' recursively' : ''))\n  })\n \nprogram.parse(process.argv)\n```\n\n\n\n#### Option & Command Option\n\n对于主命令的`option`和子命令有时候比较难区分，我们以一个例子来说明一下它们的使用：\n\n比如对于主命令`tmc`来说，它具有初始化项目的功能，那么可以给它定义一个名叫`init`的`option`：\n\n```javascript\n#!/usr/bin/env node\n\nconst program = require('commander')\n\nprogram\n  .version('0.1.0')\n  .option('-i, --init', 'Init the project')\n  .parse(process.argv);\n\nif(program.init) {\n  // ... do something\n}\n```\n\n更多的使用方法参照：\n\n[Commander]: https://www.npmjs.com/package/commander\t\"commander npm官网\"\n\n### inquirer\n\ninquirer是一个可以和命令行交互的一个工具包，它提供了多种交互方式：input、radio、select等等，简单的用法如下：\n\n```javascript\nvar inquirer = require('inquirer');\ninquirer\n  .prompt([\n    /* Pass your questions in here */\n  ])\n  .then(answers => {\n    // Use user feedback for... whatever!!\n  });\n```\n\n[inquirer]: https://www.npmjs.com/package/inquirer\n\n\n\n### download-git-repo\n\n这个工具可以把远程仓库上的代码下载到本地然后作下一步的操作，它的使用方法比较简单，\n\n例如下载`github`上的代码时可以这样写：\n\n```javascript\nconst download = require('download-git-repo');\n\n// download(url, desc, option, callback);\n// url: 仓库地址；\n// desc: 下载到本地目录的路径；\n// option: 下载的一些额外选项；\n// callback: 下载完成后的回调函数，可以处理错误信息；\ndownload('https://mygitlab.com:flipxfx/download-git-repo-fixture#my-branch', 'test/tmp', { clone: true }, function (err) {\n  console.log(err ? 'Error' : 'Success')\n})\n```\n\n更多的使用方法参照：\n\n[download-git-repo]: https://www.npmjs.com/package/download-git-repo\n\n\n\n### Metalsmith\n\nMetalsmith是一个静态网站生成器，说抽象了，简单点我个人理解就是它可以把指定目录下的所有文件都遍历出来，然后再把遍历出来的文件每一个都通过定义好的拆件处理一遍，最后再放回去指定的目标路径下。整个过程有点像项目流程构建工具`Grunt`或者`Gulp`。\n\n通过他我们可以很轻松地实现模板插值填充功能。当然如果只有几个文件需要模板插值的话，也可以通过Node API把文件的内容读出来，然后调用模板工具API里对应的编译接口，最后把编译后的内容再覆盖到文件中，这样就不会有种牛刀用到杀鸡上的感觉了。\n\n```javascript\n// Metalsmith(src).use(plugin).build(callback)\nMetalsmith(src)\n  .use(layouts('handlebars'))\n  .build(function(err) {\n    if (err) throw err;\n    console.log('Build finished!');\n  });\n```\n\n更多的使用方法参照：\n\n[Metalsmith]: https://www.npmjs.com/package/metalsmith\t\"metalsmith npm官网\"\n\n### update-notifier\n\n这个工具可以在用户使用你的工具包的时候检查是够有新的版本可以更新，从而觉得下一步的操作。比如如果我发布了某个工具包的新版本，而某位用户还在使用旧版本的时候就会提醒他有新版本可以更新。\n\n```javascript\nconst updateNotifier = require('update-notifier');\nconst pkg = require('./package.json');\n \nupdateNotifier({pkg}).notify();\n```\n\n更多的使用方法参照：\n\n[update-notifier]: https://www.npmjs.com/package/update-notifier\t\"update-notifier npm官网\"\n\n\n","source":"_posts/Build-Your-Own-Cli-Tool-Via-Nodejs.md","raw":"layout: '[post]'\ntitle: 自建一个node cli工具\ntags:\n  - 个人总结\ncategories:\n  - 项目构建\n  - ''\ndate: 2019-08-11 16:28:00\n---\ncli——**命令行界面**（英语：**command-line interface**），我们可以通过cli提供的特定命令执行、操作对应功能。\n\n一个cli工具可以看作是一个工具包再外套上cli，通过cli上提供命令和参数在命令行界面上与人交互，然后完成命令对应的功能。所以在自建一个cli工具之前，首先应该明确它的作用是什么（解决什么问题），应该包含什么功能。还有一点最重要的是，**现在网上是否已经有满足需求的现成cli 工具可以直接使用**（有宝马还造什么自行车 🤪🤪🤪）。\n\n### 目录结构 & 工作流程\n\n首先在工程目录下新建一个文件夹，并新建`bin`目录存放命令执行的文件和`lib`目录存放命令调用的相应模块。\n\n```\n/bin  # ------ 命令执行文件\n/lib  # ------ 工具模块\npackage.json\n```\n\n`package.json`包含了对cli的相关描述，与其它普通的项目类似，但有一个地方需要特别注意的是，`package.json`下的`bin`参数，**它定义了cli被调用的脚本命令名称及入口文件**，比如：\n\n```\n{\n    \"name\":'tmc-cli'\n    ...\n    \"bin\": {\n      \"tmc\": \"index.js\"\n    }\n    ...\n}\n```\n\n上面的`bin`字段说明了这个`cli`的命令是`tmc`，当用户在输入`tmc`时就会去当前目录下的`bin`文件夹执行`index.js`文件。\n\n### 实践步骤\n\n1. 设置命令\n\n   在`bin`目录下新建一个`index.js`作为入口文件。然后在`index.js`里写入以下代码：\n\n```javascript\n#!/usr/bin/env node\n\nconst program = require('commander') // npm i commander -D\n\nprogram.version('1.0.0')\n  .usage('<command> [项目名称]')\n  .command('hello', 'hello')\n  .command('init', '创建新项目')\n  .parse(process.argv)\n```\n\n​\t\t上面代码设置了`tmc`命令可以执行的`option`分别是`hello`和`init`，因为没有在`commander`里设置了`command`而没有调用`action`，所以当执行了相应的命令时，在调用了`parse`方法后，`commander`会自动去找当前文件目录下对应与命令同名的js文件并执行，如果文件不存在则会报错。对应的源码如下：\n\n```javascript\n// node_modules/commander/index.js\n\nCommand.prototype.parse = function(argv) {\n  // implicit help\n  if (this.executables) this.addImplicitHelpCommand();\n\n  // store raw args\n  this.rawArgs = argv;\n\n  // guess name\n  this._name = this._name || basename(argv[1], '.js');\n\n  // github-style sub-commands with no sub-command\n  if (this.executables && argv.length < 3 && !this.defaultExecutable) {\n    // this user needs help\n    argv.push('--help');\n  }\n \t... \n}\n```\n\n2. 编写对应命令的执行逻辑\n\n   这个部分就是来实现命令相应的功能的，可以像普通Node程序那样对文件进行处理等等。比如在执行`init`操作后`tmc`会去我的一个仓库拉去模板代码，然后再根据我输入的一些选项来进行更细化的操作。\n\n   Tmc-init.js代码如下：\n\n   ```javascript\n   #!/usr/bin/env node\n   \n   const program = require('commander')\n   const path = require('path')\n   const fs = require('fs')\n   const glob = require('glob')\n   const download = require('../lib/download')\n   const inquirer = require('inquirer')\n   const chalk = require('chalk')\n   const logSymbols = require('log-symbols')\n   const generator = require('../lib/generator')\n   \n   program.usage('<project-name>').parse(process.argv)\n   \n   // 获取新建项目名称\n   let projectName = program.args[0]\n   \n   if (!projectName) { // project-name 必填\n     // 相当于执行命令的--help选项，显示help信息，这是commander内置的一个命令选项\n     program.help()\n     return\n   }\n   \n   const rootName = path.basename(process.cwd()) // 获取当前路径\n   const list = glob.sync('*') // 遍历当前目录\n   \n   let next = undefined\n   \n   const inquirerList = [{\n     name: 'projectVersion',\n     message: '项目的版本',\n     type: 'input',\n     default: '0.1.0',\n   }, {\n     name: 'projectDescription',\n     message: '项目的描述',\n     type: 'input',\n     default: 'test',\n   }, {\n     name: 'author',\n     message: '项目的作者',\n     type: 'input',\n     default: 'kuntang',\n   }]\n   \n   if (list.length) { // 如果当前目录不为空\n     if (list.filter(name => {\n         const fileName = path.resolve(process.cwd(), path.join('.', name))\n         const isDir = fs.statSync(fileName).isDirectory()\n         return name.indexOf(projectName) !== -1 && isDir\n       }).length !== 0) {\n       console.log(`项目${projectName}已经存在`)\n       return\n     }\n     next = inquirer.prompt(inquirerList).then(answer => {\n       return Promise.resolve({\n         projectPath: projectName,\n         ...answer\n       })\n     })\n   } else if (rootName === projectName) {\n     next = inquirer.prompt([{\n       name: 'projectPath',\n       message: '当前目录为空，且目录名称和项目名称相同，是否直接在当前目录下创建新项目？',\n       type: 'confirm',\n       default: true\n     }, ...inquirerList]).then(answer => {\n       return Promise.resolve({\n         projectPath: answer.buildInCurrent ? '.' : projectName,\n         ...answer\n       })\n     })\n   } else {\n     next = inquirer.prompt(inquirerList).then(answer => {\n       return Promise.resolve({\n         projectPath: projectName,\n         ...answer\n       })\n     })\n   }\n   \n   next && initialization()\n   \n   function initialization() {\n     next.then(answer => {\n       const {\n         projectPath,\n         projectVersion,\n         projectDescription,\n         author,\n       } = answer\n       if (projectPath !== '.') {\n         fs.mkdirSync(projectPath)\n       }\n       return download(projectPath).then(downloadTempPath => {\n         return {\n           projectName,\n           projectVersion,\n           projectDescription,\n           projectPath,\n           author,\n           downloadTemp: downloadTempPath,\n         }\n       })\n     }).then(context => {\n       const src = path.join(process.cwd(), context.downloadTemp)\n       const dest = path.join(process.cwd(), context.projectPath)\n       return generator(context, src, dest)\n     }).then(context => {\n       // 成功用绿色显示，给出积极的反馈\n       console.log(logSymbols.success, chalk.green('创建成功:)'))\n       console.log()\n       console.log(chalk.green('cd ' + context.root + '\\nnpm install\\nnpm run dev'))\n     }).catch(error => {\n       // 失败了用红色，增强提示\n       console.error(logSymbols.error, chalk.red(`创建失败：${error.message}`))\n     })\n   }\n   ```\n\n   Lib/download.js:\n\n   ```javascript\n   const download = require('download-git-repo')\n   const ora = require('ora')\n   const path = require('path')\n   \n   module.exports = function(dest) {\n     dest = path.join(dest || '.', '.download-temp')\n     return new Promise((resolve, reject) => {\n       const url = 'https://github.com:kunkuntang/react-typescript-scaffold#template'\n       const spinner = ora(`正在下载项目模板，源地址：${url}`)\n       spinner.start()\n         // 这里可以根据具体的模板地址设置下载的url，注意，如果是git，url后面的branch不能忽略\n       download(url,\n         dest, { clone: true }, (err) => {\n           if (err) {\n             spinner.fail() // wrong :(\n             reject(err)\n           } else {\n             spinner.succeed() // ok :)\n               // 下载的模板存放在一个临时路径中，下载完成后，可以向下通知这个临时路径，以便后续处理\n             resolve(dest)\n           }\n         })\n     })\n   }\n   ```\n\n   lib/generator.js:\n\n   ```javascript\n   const Metalsmith = require('metalsmith')\n   const Handlebars = require('handlebars')\n   const rm = require('rimraf').sync\n   \n   module.exports = function(metadata = {}, src, dest = '.') {\n     if (!src) {\n       return Promise.reject(new Error(`无效的source：${src}`))\n     }\n   \n     return new Promise((resolve, reject) => {\n       Metalsmith(process.cwd())\n         .metadata(metadata)\n         .clean(false)\n         .source(src)\n         .destination(dest)\n         .use((files, metalsmith, done) => {\n           const meta = metalsmith.metadata()\n           Object.keys(files).forEach(fileName => {\n             if (fileName.includes('package.json')) {\n               const t = files[fileName].contents.toString()\n               files[fileName].contents = new Buffer.from(Handlebars.compile(t)(meta))\n             }\n           })\n           done()\n         }).build(err => {\n           rm(src)\n           err ? reject(err) : resolve({\n             root: dest\n           })\n         })\n     })\n   }\n   ```\n\n   3. 发布到npm\n\n      \n\n### Commander 使用\n\ncommander是Node 命令行交互的一个工具，使用它可以创建自己想要的Node命令。\n\nCommander有几个基本概念：\n\n- version option\n\n- option\n- command & action\n\n#### version\n\n指定`cli`的版本号。\n\n```javascript\nconst program = require('commander')\nprogram\n  .version('0.0.1', '-v, --version')\n```\n\n#### Option parsing\n\noption是用来为commander命令添加一个选项的，用户可以不同的选项来能行特定的功能。\n\n```javascript\n#!/usr/bin/env node\n \n/**\n * Module dependencies.\n */\n \nvar program = require('commander');\n \nprogram\n  .version('0.1.0')\n  .option('-p, --peppers', 'Add peppers')\n  .option('-P, --pineapple', 'Add pineapple')\n  .option('-b, --bbq-sauce', 'Add bbq sauce')\n  .option('-c, --cheese [type]', 'Add the specified type of cheese [marble]', 'marble')\n  .parse(process.argv);\n \nconsole.log('you ordered a pizza with:');\nif (program.peppers) console.log('  - peppers');\nif (program.pineapple) console.log('  - pineapple');\nif (program.bbqSauce) console.log('  - bbq');\nconsole.log('  - %s cheese', program.cheese);\n```\n\n在Node.js中，用户输入的参数可以通过`process.argv`得到。`commander`的`option`只定义不处理用户输入的参数，需要显式将`process.argv`传入到`parse`方法调用才能处理。\n\n连续输入参数`-abc`等同于`-a -b -c`，在`cli`输入`--template-engine`，在`commander`可以通过`program.templateEngine`驼峰命名取得。\n\n通过给选项加`--no`前缀可以给它设置为`false`，如设置`--no-sauce`后从`program.sauce`取到的是`false`。\n\n要想拿到选项后输入的值，可以设置中括号（选填）或者尖括号（必填），如`.option('-m --myarg [myVar]', 'my option var')`或`.option('-m --myarg <myVar>', 'my require var')`，然后可以这样来取得值`var myInput = program.myarg`。\n\n#### Command 子命令\n\n**`Command`是一个特殊的`option`**，通过设置子命令可以让工具根据入参来实现的特定的小任务，并且对于子命令也可以像主命令一样设置它的`option`。\n\n```javascript\n#!/usr/bin/env node\n \nvar program = require('commander');\n \nprogram\n  .command('rm <dir>')\n  .option('-r, --recursive', 'Remove recursively')\n  .action(function (dir, cmd) {\n    console.log('remove ' + dir + (cmd.recursive ? ' recursively' : ''))\n  })\n \nprogram.parse(process.argv)\n```\n\n\n\n#### Option & Command Option\n\n对于主命令的`option`和子命令有时候比较难区分，我们以一个例子来说明一下它们的使用：\n\n比如对于主命令`tmc`来说，它具有初始化项目的功能，那么可以给它定义一个名叫`init`的`option`：\n\n```javascript\n#!/usr/bin/env node\n\nconst program = require('commander')\n\nprogram\n  .version('0.1.0')\n  .option('-i, --init', 'Init the project')\n  .parse(process.argv);\n\nif(program.init) {\n  // ... do something\n}\n```\n\n更多的使用方法参照：\n\n[Commander]: https://www.npmjs.com/package/commander\t\"commander npm官网\"\n\n### inquirer\n\ninquirer是一个可以和命令行交互的一个工具包，它提供了多种交互方式：input、radio、select等等，简单的用法如下：\n\n```javascript\nvar inquirer = require('inquirer');\ninquirer\n  .prompt([\n    /* Pass your questions in here */\n  ])\n  .then(answers => {\n    // Use user feedback for... whatever!!\n  });\n```\n\n[inquirer]: https://www.npmjs.com/package/inquirer\n\n\n\n### download-git-repo\n\n这个工具可以把远程仓库上的代码下载到本地然后作下一步的操作，它的使用方法比较简单，\n\n例如下载`github`上的代码时可以这样写：\n\n```javascript\nconst download = require('download-git-repo');\n\n// download(url, desc, option, callback);\n// url: 仓库地址；\n// desc: 下载到本地目录的路径；\n// option: 下载的一些额外选项；\n// callback: 下载完成后的回调函数，可以处理错误信息；\ndownload('https://mygitlab.com:flipxfx/download-git-repo-fixture#my-branch', 'test/tmp', { clone: true }, function (err) {\n  console.log(err ? 'Error' : 'Success')\n})\n```\n\n更多的使用方法参照：\n\n[download-git-repo]: https://www.npmjs.com/package/download-git-repo\n\n\n\n### Metalsmith\n\nMetalsmith是一个静态网站生成器，说抽象了，简单点我个人理解就是它可以把指定目录下的所有文件都遍历出来，然后再把遍历出来的文件每一个都通过定义好的拆件处理一遍，最后再放回去指定的目标路径下。整个过程有点像项目流程构建工具`Grunt`或者`Gulp`。\n\n通过他我们可以很轻松地实现模板插值填充功能。当然如果只有几个文件需要模板插值的话，也可以通过Node API把文件的内容读出来，然后调用模板工具API里对应的编译接口，最后把编译后的内容再覆盖到文件中，这样就不会有种牛刀用到杀鸡上的感觉了。\n\n```javascript\n// Metalsmith(src).use(plugin).build(callback)\nMetalsmith(src)\n  .use(layouts('handlebars'))\n  .build(function(err) {\n    if (err) throw err;\n    console.log('Build finished!');\n  });\n```\n\n更多的使用方法参照：\n\n[Metalsmith]: https://www.npmjs.com/package/metalsmith\t\"metalsmith npm官网\"\n\n### update-notifier\n\n这个工具可以在用户使用你的工具包的时候检查是够有新的版本可以更新，从而觉得下一步的操作。比如如果我发布了某个工具包的新版本，而某位用户还在使用旧版本的时候就会提醒他有新版本可以更新。\n\n```javascript\nconst updateNotifier = require('update-notifier');\nconst pkg = require('./package.json');\n \nupdateNotifier({pkg}).notify();\n```\n\n更多的使用方法参照：\n\n[update-notifier]: https://www.npmjs.com/package/update-notifier\t\"update-notifier npm官网\"\n\n\n","slug":"Build-Your-Own-Cli-Tool-Via-Nodejs","published":1,"updated":"2023-04-11T03:30:27.109Z","comments":1,"photos":[],"link":"","_id":"clgbppeb30003bvchfpwjchwf","content":"<p>cli——<strong>命令行界面</strong>（英语：<strong>command-line interface</strong>），我们可以通过cli提供的特定命令执行、操作对应功能。</p>\n<p>一个cli工具可以看作是一个工具包再外套上cli，通过cli上提供命令和参数在命令行界面上与人交互，然后完成命令对应的功能。所以在自建一个cli工具之前，首先应该明确它的作用是什么（解决什么问题），应该包含什么功能。还有一点最重要的是，<strong>现在网上是否已经有满足需求的现成cli 工具可以直接使用</strong>（有宝马还造什么自行车 🤪🤪🤪）。</p>\n<h3><a href=\"#mu-lu-jie-gou-amp-gong-zuo-liu-cheng\" class=\"header-anchor\"></a><span id=\"mu-lu-jie-gou-amp-gong-zuo-liu-cheng\">目录结构 &amp; 工作流程</span></h3><p>首先在工程目录下新建一个文件夹，并新建<code>bin</code>目录存放命令执行的文件和<code>lib</code>目录存放命令调用的相应模块。</p>\n<pre><code>/bin  # ------ 命令执行文件\n/lib  # ------ 工具模块\npackage.json\n</code></pre>\n<p><code>package.json</code>包含了对cli的相关描述，与其它普通的项目类似，但有一个地方需要特别注意的是，<code>package.json</code>下的<code>bin</code>参数，<strong>它定义了cli被调用的脚本命令名称及入口文件</strong>，比如：</p>\n<pre><code>&#123;\n    &quot;name&quot;:&#39;tmc-cli&#39;\n    ...\n    &quot;bin&quot;: &#123;\n      &quot;tmc&quot;: &quot;index.js&quot;\n    &#125;\n    ...\n&#125;\n</code></pre>\n<p>上面的<code>bin</code>字段说明了这个<code>cli</code>的命令是<code>tmc</code>，当用户在输入<code>tmc</code>时就会去当前目录下的<code>bin</code>文件夹执行<code>index.js</code>文件。</p>\n<h3><a href=\"#shi-jian-bu-zou\" class=\"header-anchor\"></a><span id=\"shi-jian-bu-zou\">实践步骤</span></h3><ol>\n<li><p>设置命令</p>\n<p>在<code>bin</code>目录下新建一个<code>index.js</code>作为入口文件。然后在<code>index.js</code>里写入以下代码：</p>\n</li>\n</ol>\n<pre><code class=\"javascript\">#!/usr/bin/env node\n\nconst program = require(&#39;commander&#39;) // npm i commander -D\n\nprogram.version(&#39;1.0.0&#39;)\n  .usage(&#39;&lt;command&gt; [项目名称]&#39;)\n  .command(&#39;hello&#39;, &#39;hello&#39;)\n  .command(&#39;init&#39;, &#39;创建新项目&#39;)\n  .parse(process.argv)\n</code></pre>\n<p>​\t\t上面代码设置了<code>tmc</code>命令可以执行的<code>option</code>分别是<code>hello</code>和<code>init</code>，因为没有在<code>commander</code>里设置了<code>command</code>而没有调用<code>action</code>，所以当执行了相应的命令时，在调用了<code>parse</code>方法后，<code>commander</code>会自动去找当前文件目录下对应与命令同名的js文件并执行，如果文件不存在则会报错。对应的源码如下：</p>\n<pre><code class=\"javascript\">// node_modules/commander/index.js\n\nCommand.prototype.parse = function(argv) &#123;\n  // implicit help\n  if (this.executables) this.addImplicitHelpCommand();\n\n  // store raw args\n  this.rawArgs = argv;\n\n  // guess name\n  this._name = this._name || basename(argv[1], &#39;.js&#39;);\n\n  // github-style sub-commands with no sub-command\n  if (this.executables &amp;&amp; argv.length &lt; 3 &amp;&amp; !this.defaultExecutable) &#123;\n    // this user needs help\n    argv.push(&#39;--help&#39;);\n  &#125;\n     ... \n&#125;\n</code></pre>\n<ol start=\"2\">\n<li><p>编写对应命令的执行逻辑</p>\n<p>这个部分就是来实现命令相应的功能的，可以像普通Node程序那样对文件进行处理等等。比如在执行<code>init</code>操作后<code>tmc</code>会去我的一个仓库拉去模板代码，然后再根据我输入的一些选项来进行更细化的操作。</p>\n<p>Tmc-init.js代码如下：</p>\n<pre><code class=\"javascript\">#!/usr/bin/env node\n\nconst program = require(&#39;commander&#39;)\nconst path = require(&#39;path&#39;)\nconst fs = require(&#39;fs&#39;)\nconst glob = require(&#39;glob&#39;)\nconst download = require(&#39;../lib/download&#39;)\nconst inquirer = require(&#39;inquirer&#39;)\nconst chalk = require(&#39;chalk&#39;)\nconst logSymbols = require(&#39;log-symbols&#39;)\nconst generator = require(&#39;../lib/generator&#39;)\n\nprogram.usage(&#39;&lt;project-name&gt;&#39;).parse(process.argv)\n\n// 获取新建项目名称\nlet projectName = program.args[0]\n\nif (!projectName) &#123; // project-name 必填\n  // 相当于执行命令的--help选项，显示help信息，这是commander内置的一个命令选项\n  program.help()\n  return\n&#125;\n\nconst rootName = path.basename(process.cwd()) // 获取当前路径\nconst list = glob.sync(&#39;*&#39;) // 遍历当前目录\n\nlet next = undefined\n\nconst inquirerList = [&#123;\n  name: &#39;projectVersion&#39;,\n  message: &#39;项目的版本&#39;,\n  type: &#39;input&#39;,\n  default: &#39;0.1.0&#39;,\n&#125;, &#123;\n  name: &#39;projectDescription&#39;,\n  message: &#39;项目的描述&#39;,\n  type: &#39;input&#39;,\n  default: &#39;test&#39;,\n&#125;, &#123;\n  name: &#39;author&#39;,\n  message: &#39;项目的作者&#39;,\n  type: &#39;input&#39;,\n  default: &#39;kuntang&#39;,\n&#125;]\n\nif (list.length) &#123; // 如果当前目录不为空\n  if (list.filter(name =&gt; &#123;\n      const fileName = path.resolve(process.cwd(), path.join(&#39;.&#39;, name))\n      const isDir = fs.statSync(fileName).isDirectory()\n      return name.indexOf(projectName) !== -1 &amp;&amp; isDir\n    &#125;).length !== 0) &#123;\n    console.log(`项目$&#123;projectName&#125;已经存在`)\n    return\n  &#125;\n  next = inquirer.prompt(inquirerList).then(answer =&gt; &#123;\n    return Promise.resolve(&#123;\n      projectPath: projectName,\n      ...answer\n    &#125;)\n  &#125;)\n&#125; else if (rootName === projectName) &#123;\n  next = inquirer.prompt([&#123;\n    name: &#39;projectPath&#39;,\n    message: &#39;当前目录为空，且目录名称和项目名称相同，是否直接在当前目录下创建新项目？&#39;,\n    type: &#39;confirm&#39;,\n    default: true\n  &#125;, ...inquirerList]).then(answer =&gt; &#123;\n    return Promise.resolve(&#123;\n      projectPath: answer.buildInCurrent ? &#39;.&#39; : projectName,\n      ...answer\n    &#125;)\n  &#125;)\n&#125; else &#123;\n  next = inquirer.prompt(inquirerList).then(answer =&gt; &#123;\n    return Promise.resolve(&#123;\n      projectPath: projectName,\n      ...answer\n    &#125;)\n  &#125;)\n&#125;\n\nnext &amp;&amp; initialization()\n\nfunction initialization() &#123;\n  next.then(answer =&gt; &#123;\n    const &#123;\n      projectPath,\n      projectVersion,\n      projectDescription,\n      author,\n    &#125; = answer\n    if (projectPath !== &#39;.&#39;) &#123;\n      fs.mkdirSync(projectPath)\n    &#125;\n    return download(projectPath).then(downloadTempPath =&gt; &#123;\n      return &#123;\n        projectName,\n        projectVersion,\n        projectDescription,\n        projectPath,\n        author,\n        downloadTemp: downloadTempPath,\n      &#125;\n    &#125;)\n  &#125;).then(context =&gt; &#123;\n    const src = path.join(process.cwd(), context.downloadTemp)\n    const dest = path.join(process.cwd(), context.projectPath)\n    return generator(context, src, dest)\n  &#125;).then(context =&gt; &#123;\n    // 成功用绿色显示，给出积极的反馈\n    console.log(logSymbols.success, chalk.green(&#39;创建成功:)&#39;))\n    console.log()\n    console.log(chalk.green(&#39;cd &#39; + context.root + &#39;\\nnpm install\\nnpm run dev&#39;))\n  &#125;).catch(error =&gt; &#123;\n    // 失败了用红色，增强提示\n    console.error(logSymbols.error, chalk.red(`创建失败：$&#123;error.message&#125;`))\n  &#125;)\n&#125;\n</code></pre>\n<p>Lib&#x2F;download.js:</p>\n<pre><code class=\"javascript\">const download = require(&#39;download-git-repo&#39;)\nconst ora = require(&#39;ora&#39;)\nconst path = require(&#39;path&#39;)\n\nmodule.exports = function(dest) &#123;\n  dest = path.join(dest || &#39;.&#39;, &#39;.download-temp&#39;)\n  return new Promise((resolve, reject) =&gt; &#123;\n    const url = &#39;https://github.com:kunkuntang/react-typescript-scaffold#template&#39;\n    const spinner = ora(`正在下载项目模板，源地址：$&#123;url&#125;`)\n    spinner.start()\n      // 这里可以根据具体的模板地址设置下载的url，注意，如果是git，url后面的branch不能忽略\n    download(url,\n      dest, &#123; clone: true &#125;, (err) =&gt; &#123;\n        if (err) &#123;\n          spinner.fail() // wrong :(\n          reject(err)\n        &#125; else &#123;\n          spinner.succeed() // ok :)\n            // 下载的模板存放在一个临时路径中，下载完成后，可以向下通知这个临时路径，以便后续处理\n          resolve(dest)\n        &#125;\n      &#125;)\n  &#125;)\n&#125;\n</code></pre>\n<p>lib&#x2F;generator.js:</p>\n<pre><code class=\"javascript\">const Metalsmith = require(&#39;metalsmith&#39;)\nconst Handlebars = require(&#39;handlebars&#39;)\nconst rm = require(&#39;rimraf&#39;).sync\n\nmodule.exports = function(metadata = &#123;&#125;, src, dest = &#39;.&#39;) &#123;\n  if (!src) &#123;\n    return Promise.reject(new Error(`无效的source：$&#123;src&#125;`))\n  &#125;\n\n  return new Promise((resolve, reject) =&gt; &#123;\n    Metalsmith(process.cwd())\n      .metadata(metadata)\n      .clean(false)\n      .source(src)\n      .destination(dest)\n      .use((files, metalsmith, done) =&gt; &#123;\n        const meta = metalsmith.metadata()\n        Object.keys(files).forEach(fileName =&gt; &#123;\n          if (fileName.includes(&#39;package.json&#39;)) &#123;\n            const t = files[fileName].contents.toString()\n            files[fileName].contents = new Buffer.from(Handlebars.compile(t)(meta))\n          &#125;\n        &#125;)\n        done()\n      &#125;).build(err =&gt; &#123;\n        rm(src)\n        err ? reject(err) : resolve(&#123;\n          root: dest\n        &#125;)\n      &#125;)\n  &#125;)\n&#125;\n</code></pre>\n<ol start=\"3\">\n<li>发布到npm</li>\n</ol>\n</li>\n</ol>\n<h3><a href=\"#commander-shi-yong\" class=\"header-anchor\"></a><span id=\"commander-shi-yong\">Commander 使用</span></h3><p>commander是Node 命令行交互的一个工具，使用它可以创建自己想要的Node命令。</p>\n<p>Commander有几个基本概念：</p>\n<ul>\n<li><p>version option</p>\n</li>\n<li><p>option</p>\n</li>\n<li><p>command &amp; action</p>\n</li>\n</ul>\n<h4><a href=\"#version\" class=\"header-anchor\"></a><span id=\"version\">version</span></h4><p>指定<code>cli</code>的版本号。</p>\n<pre><code class=\"javascript\">const program = require(&#39;commander&#39;)\nprogram\n  .version(&#39;0.0.1&#39;, &#39;-v, --version&#39;)\n</code></pre>\n<h4><a href=\"#option-parsing\" class=\"header-anchor\"></a><span id=\"option-parsing\">Option parsing</span></h4><p>option是用来为commander命令添加一个选项的，用户可以不同的选项来能行特定的功能。</p>\n<pre><code class=\"javascript\">#!/usr/bin/env node\n \n/**\n * Module dependencies.\n */\n \nvar program = require(&#39;commander&#39;);\n \nprogram\n  .version(&#39;0.1.0&#39;)\n  .option(&#39;-p, --peppers&#39;, &#39;Add peppers&#39;)\n  .option(&#39;-P, --pineapple&#39;, &#39;Add pineapple&#39;)\n  .option(&#39;-b, --bbq-sauce&#39;, &#39;Add bbq sauce&#39;)\n  .option(&#39;-c, --cheese [type]&#39;, &#39;Add the specified type of cheese [marble]&#39;, &#39;marble&#39;)\n  .parse(process.argv);\n \nconsole.log(&#39;you ordered a pizza with:&#39;);\nif (program.peppers) console.log(&#39;  - peppers&#39;);\nif (program.pineapple) console.log(&#39;  - pineapple&#39;);\nif (program.bbqSauce) console.log(&#39;  - bbq&#39;);\nconsole.log(&#39;  - %s cheese&#39;, program.cheese);\n</code></pre>\n<p>在Node.js中，用户输入的参数可以通过<code>process.argv</code>得到。<code>commander</code>的<code>option</code>只定义不处理用户输入的参数，需要显式将<code>process.argv</code>传入到<code>parse</code>方法调用才能处理。</p>\n<p>连续输入参数<code>-abc</code>等同于<code>-a -b -c</code>，在<code>cli</code>输入<code>--template-engine</code>，在<code>commander</code>可以通过<code>program.templateEngine</code>驼峰命名取得。</p>\n<p>通过给选项加<code>--no</code>前缀可以给它设置为<code>false</code>，如设置<code>--no-sauce</code>后从<code>program.sauce</code>取到的是<code>false</code>。</p>\n<p>要想拿到选项后输入的值，可以设置中括号（选填）或者尖括号（必填），如<code>.option(&#39;-m --myarg [myVar]&#39;, &#39;my option var&#39;)</code>或<code>.option(&#39;-m --myarg &lt;myVar&gt;&#39;, &#39;my require var&#39;)</code>，然后可以这样来取得值<code>var myInput = program.myarg</code>。</p>\n<h4><a href=\"#command-zi-ming-ling\" class=\"header-anchor\"></a><span id=\"command-zi-ming-ling\">Command 子命令</span></h4><p>**<code>Command</code>是一个特殊的<code>option</code>**，通过设置子命令可以让工具根据入参来实现的特定的小任务，并且对于子命令也可以像主命令一样设置它的<code>option</code>。</p>\n<pre><code class=\"javascript\">#!/usr/bin/env node\n \nvar program = require(&#39;commander&#39;);\n \nprogram\n  .command(&#39;rm &lt;dir&gt;&#39;)\n  .option(&#39;-r, --recursive&#39;, &#39;Remove recursively&#39;)\n  .action(function (dir, cmd) &#123;\n    console.log(&#39;remove &#39; + dir + (cmd.recursive ? &#39; recursively&#39; : &#39;&#39;))\n  &#125;)\n \nprogram.parse(process.argv)\n</code></pre>\n<h4><a href=\"#option-amp-command-option\" class=\"header-anchor\"></a><span id=\"option-amp-command-option\">Option &amp; Command Option</span></h4><p>对于主命令的<code>option</code>和子命令有时候比较难区分，我们以一个例子来说明一下它们的使用：</p>\n<p>比如对于主命令<code>tmc</code>来说，它具有初始化项目的功能，那么可以给它定义一个名叫<code>init</code>的<code>option</code>：</p>\n<pre><code class=\"javascript\">#!/usr/bin/env node\n\nconst program = require(&#39;commander&#39;)\n\nprogram\n  .version(&#39;0.1.0&#39;)\n  .option(&#39;-i, --init&#39;, &#39;Init the project&#39;)\n  .parse(process.argv);\n\nif(program.init) &#123;\n  // ... do something\n&#125;\n</code></pre>\n<p>更多的使用方法参照：</p>\n<p>[Commander]: <a href=\"https://www.npmjs.com/package/commander\">https://www.npmjs.com/package/commander</a>\t“commander npm官网”</p>\n<h3><a href=\"#inquirer\" class=\"header-anchor\"></a><span id=\"inquirer\">inquirer</span></h3><p>inquirer是一个可以和命令行交互的一个工具包，它提供了多种交互方式：input、radio、select等等，简单的用法如下：</p>\n<pre><code class=\"javascript\">var inquirer = require(&#39;inquirer&#39;);\ninquirer\n  .prompt([\n    /* Pass your questions in here */\n  ])\n  .then(answers =&gt; &#123;\n    // Use user feedback for... whatever!!\n  &#125;);\n</code></pre>\n<h3><a href=\"#download-git-repo\" class=\"header-anchor\"></a><span id=\"download-git-repo\">download-git-repo</span></h3><p>这个工具可以把远程仓库上的代码下载到本地然后作下一步的操作，它的使用方法比较简单，</p>\n<p>例如下载<code>github</code>上的代码时可以这样写：</p>\n<pre><code class=\"javascript\">const download = require(&#39;download-git-repo&#39;);\n\n// download(url, desc, option, callback);\n// url: 仓库地址；\n// desc: 下载到本地目录的路径；\n// option: 下载的一些额外选项；\n// callback: 下载完成后的回调函数，可以处理错误信息；\ndownload(&#39;https://mygitlab.com:flipxfx/download-git-repo-fixture#my-branch&#39;, &#39;test/tmp&#39;, &#123; clone: true &#125;, function (err) &#123;\n  console.log(err ? &#39;Error&#39; : &#39;Success&#39;)\n&#125;)\n</code></pre>\n<p>更多的使用方法参照：</p>\n<h3><a href=\"#metalsmith\" class=\"header-anchor\"></a><span id=\"metalsmith\">Metalsmith</span></h3><p>Metalsmith是一个静态网站生成器，说抽象了，简单点我个人理解就是它可以把指定目录下的所有文件都遍历出来，然后再把遍历出来的文件每一个都通过定义好的拆件处理一遍，最后再放回去指定的目标路径下。整个过程有点像项目流程构建工具<code>Grunt</code>或者<code>Gulp</code>。</p>\n<p>通过他我们可以很轻松地实现模板插值填充功能。当然如果只有几个文件需要模板插值的话，也可以通过Node API把文件的内容读出来，然后调用模板工具API里对应的编译接口，最后把编译后的内容再覆盖到文件中，这样就不会有种牛刀用到杀鸡上的感觉了。</p>\n<pre><code class=\"javascript\">// Metalsmith(src).use(plugin).build(callback)\nMetalsmith(src)\n  .use(layouts(&#39;handlebars&#39;))\n  .build(function(err) &#123;\n    if (err) throw err;\n    console.log(&#39;Build finished!&#39;);\n  &#125;);\n</code></pre>\n<p>更多的使用方法参照：</p>\n<p>[Metalsmith]: <a href=\"https://www.npmjs.com/package/metalsmith\">https://www.npmjs.com/package/metalsmith</a>\t“metalsmith npm官网”</p>\n<h3><a href=\"#update-notifier\" class=\"header-anchor\"></a><span id=\"update-notifier\">update-notifier</span></h3><p>这个工具可以在用户使用你的工具包的时候检查是够有新的版本可以更新，从而觉得下一步的操作。比如如果我发布了某个工具包的新版本，而某位用户还在使用旧版本的时候就会提醒他有新版本可以更新。</p>\n<pre><code class=\"javascript\">const updateNotifier = require(&#39;update-notifier&#39;);\nconst pkg = require(&#39;./package.json&#39;);\n \nupdateNotifier(&#123;pkg&#125;).notify();\n</code></pre>\n<p>更多的使用方法参照：</p>\n<p>[update-notifier]: <a href=\"https://www.npmjs.com/package/update-notifier\">https://www.npmjs.com/package/update-notifier</a>\t“update-notifier npm官网”</p>\n","site":{"data":{}},"excerpt":"","more":"<p>cli——<strong>命令行界面</strong>（英语：<strong>command-line interface</strong>），我们可以通过cli提供的特定命令执行、操作对应功能。</p>\n<p>一个cli工具可以看作是一个工具包再外套上cli，通过cli上提供命令和参数在命令行界面上与人交互，然后完成命令对应的功能。所以在自建一个cli工具之前，首先应该明确它的作用是什么（解决什么问题），应该包含什么功能。还有一点最重要的是，<strong>现在网上是否已经有满足需求的现成cli 工具可以直接使用</strong>（有宝马还造什么自行车 🤪🤪🤪）。</p>\n<h3 id=\"目录结构-amp-工作流程\"><a href=\"#目录结构-amp-工作流程\" class=\"headerlink\" title=\"目录结构 &amp; 工作流程\"></a>目录结构 &amp; 工作流程</h3><p>首先在工程目录下新建一个文件夹，并新建<code>bin</code>目录存放命令执行的文件和<code>lib</code>目录存放命令调用的相应模块。</p>\n<pre><code>/bin  # ------ 命令执行文件\n/lib  # ------ 工具模块\npackage.json\n</code></pre>\n<p><code>package.json</code>包含了对cli的相关描述，与其它普通的项目类似，但有一个地方需要特别注意的是，<code>package.json</code>下的<code>bin</code>参数，<strong>它定义了cli被调用的脚本命令名称及入口文件</strong>，比如：</p>\n<pre><code>&#123;\n    &quot;name&quot;:&#39;tmc-cli&#39;\n    ...\n    &quot;bin&quot;: &#123;\n      &quot;tmc&quot;: &quot;index.js&quot;\n    &#125;\n    ...\n&#125;\n</code></pre>\n<p>上面的<code>bin</code>字段说明了这个<code>cli</code>的命令是<code>tmc</code>，当用户在输入<code>tmc</code>时就会去当前目录下的<code>bin</code>文件夹执行<code>index.js</code>文件。</p>\n<h3 id=\"实践步骤\"><a href=\"#实践步骤\" class=\"headerlink\" title=\"实践步骤\"></a>实践步骤</h3><ol>\n<li><p>设置命令</p>\n<p>在<code>bin</code>目录下新建一个<code>index.js</code>作为入口文件。然后在<code>index.js</code>里写入以下代码：</p>\n</li>\n</ol>\n<pre><code class=\"javascript\">#!/usr/bin/env node\n\nconst program = require(&#39;commander&#39;) // npm i commander -D\n\nprogram.version(&#39;1.0.0&#39;)\n  .usage(&#39;&lt;command&gt; [项目名称]&#39;)\n  .command(&#39;hello&#39;, &#39;hello&#39;)\n  .command(&#39;init&#39;, &#39;创建新项目&#39;)\n  .parse(process.argv)\n</code></pre>\n<p>​\t\t上面代码设置了<code>tmc</code>命令可以执行的<code>option</code>分别是<code>hello</code>和<code>init</code>，因为没有在<code>commander</code>里设置了<code>command</code>而没有调用<code>action</code>，所以当执行了相应的命令时，在调用了<code>parse</code>方法后，<code>commander</code>会自动去找当前文件目录下对应与命令同名的js文件并执行，如果文件不存在则会报错。对应的源码如下：</p>\n<pre><code class=\"javascript\">// node_modules/commander/index.js\n\nCommand.prototype.parse = function(argv) &#123;\n  // implicit help\n  if (this.executables) this.addImplicitHelpCommand();\n\n  // store raw args\n  this.rawArgs = argv;\n\n  // guess name\n  this._name = this._name || basename(argv[1], &#39;.js&#39;);\n\n  // github-style sub-commands with no sub-command\n  if (this.executables &amp;&amp; argv.length &lt; 3 &amp;&amp; !this.defaultExecutable) &#123;\n    // this user needs help\n    argv.push(&#39;--help&#39;);\n  &#125;\n     ... \n&#125;\n</code></pre>\n<ol start=\"2\">\n<li><p>编写对应命令的执行逻辑</p>\n<p>这个部分就是来实现命令相应的功能的，可以像普通Node程序那样对文件进行处理等等。比如在执行<code>init</code>操作后<code>tmc</code>会去我的一个仓库拉去模板代码，然后再根据我输入的一些选项来进行更细化的操作。</p>\n<p>Tmc-init.js代码如下：</p>\n<pre><code class=\"javascript\">#!/usr/bin/env node\n\nconst program = require(&#39;commander&#39;)\nconst path = require(&#39;path&#39;)\nconst fs = require(&#39;fs&#39;)\nconst glob = require(&#39;glob&#39;)\nconst download = require(&#39;../lib/download&#39;)\nconst inquirer = require(&#39;inquirer&#39;)\nconst chalk = require(&#39;chalk&#39;)\nconst logSymbols = require(&#39;log-symbols&#39;)\nconst generator = require(&#39;../lib/generator&#39;)\n\nprogram.usage(&#39;&lt;project-name&gt;&#39;).parse(process.argv)\n\n// 获取新建项目名称\nlet projectName = program.args[0]\n\nif (!projectName) &#123; // project-name 必填\n  // 相当于执行命令的--help选项，显示help信息，这是commander内置的一个命令选项\n  program.help()\n  return\n&#125;\n\nconst rootName = path.basename(process.cwd()) // 获取当前路径\nconst list = glob.sync(&#39;*&#39;) // 遍历当前目录\n\nlet next = undefined\n\nconst inquirerList = [&#123;\n  name: &#39;projectVersion&#39;,\n  message: &#39;项目的版本&#39;,\n  type: &#39;input&#39;,\n  default: &#39;0.1.0&#39;,\n&#125;, &#123;\n  name: &#39;projectDescription&#39;,\n  message: &#39;项目的描述&#39;,\n  type: &#39;input&#39;,\n  default: &#39;test&#39;,\n&#125;, &#123;\n  name: &#39;author&#39;,\n  message: &#39;项目的作者&#39;,\n  type: &#39;input&#39;,\n  default: &#39;kuntang&#39;,\n&#125;]\n\nif (list.length) &#123; // 如果当前目录不为空\n  if (list.filter(name =&gt; &#123;\n      const fileName = path.resolve(process.cwd(), path.join(&#39;.&#39;, name))\n      const isDir = fs.statSync(fileName).isDirectory()\n      return name.indexOf(projectName) !== -1 &amp;&amp; isDir\n    &#125;).length !== 0) &#123;\n    console.log(`项目$&#123;projectName&#125;已经存在`)\n    return\n  &#125;\n  next = inquirer.prompt(inquirerList).then(answer =&gt; &#123;\n    return Promise.resolve(&#123;\n      projectPath: projectName,\n      ...answer\n    &#125;)\n  &#125;)\n&#125; else if (rootName === projectName) &#123;\n  next = inquirer.prompt([&#123;\n    name: &#39;projectPath&#39;,\n    message: &#39;当前目录为空，且目录名称和项目名称相同，是否直接在当前目录下创建新项目？&#39;,\n    type: &#39;confirm&#39;,\n    default: true\n  &#125;, ...inquirerList]).then(answer =&gt; &#123;\n    return Promise.resolve(&#123;\n      projectPath: answer.buildInCurrent ? &#39;.&#39; : projectName,\n      ...answer\n    &#125;)\n  &#125;)\n&#125; else &#123;\n  next = inquirer.prompt(inquirerList).then(answer =&gt; &#123;\n    return Promise.resolve(&#123;\n      projectPath: projectName,\n      ...answer\n    &#125;)\n  &#125;)\n&#125;\n\nnext &amp;&amp; initialization()\n\nfunction initialization() &#123;\n  next.then(answer =&gt; &#123;\n    const &#123;\n      projectPath,\n      projectVersion,\n      projectDescription,\n      author,\n    &#125; = answer\n    if (projectPath !== &#39;.&#39;) &#123;\n      fs.mkdirSync(projectPath)\n    &#125;\n    return download(projectPath).then(downloadTempPath =&gt; &#123;\n      return &#123;\n        projectName,\n        projectVersion,\n        projectDescription,\n        projectPath,\n        author,\n        downloadTemp: downloadTempPath,\n      &#125;\n    &#125;)\n  &#125;).then(context =&gt; &#123;\n    const src = path.join(process.cwd(), context.downloadTemp)\n    const dest = path.join(process.cwd(), context.projectPath)\n    return generator(context, src, dest)\n  &#125;).then(context =&gt; &#123;\n    // 成功用绿色显示，给出积极的反馈\n    console.log(logSymbols.success, chalk.green(&#39;创建成功:)&#39;))\n    console.log()\n    console.log(chalk.green(&#39;cd &#39; + context.root + &#39;\\nnpm install\\nnpm run dev&#39;))\n  &#125;).catch(error =&gt; &#123;\n    // 失败了用红色，增强提示\n    console.error(logSymbols.error, chalk.red(`创建失败：$&#123;error.message&#125;`))\n  &#125;)\n&#125;\n</code></pre>\n<p>Lib&#x2F;download.js:</p>\n<pre><code class=\"javascript\">const download = require(&#39;download-git-repo&#39;)\nconst ora = require(&#39;ora&#39;)\nconst path = require(&#39;path&#39;)\n\nmodule.exports = function(dest) &#123;\n  dest = path.join(dest || &#39;.&#39;, &#39;.download-temp&#39;)\n  return new Promise((resolve, reject) =&gt; &#123;\n    const url = &#39;https://github.com:kunkuntang/react-typescript-scaffold#template&#39;\n    const spinner = ora(`正在下载项目模板，源地址：$&#123;url&#125;`)\n    spinner.start()\n      // 这里可以根据具体的模板地址设置下载的url，注意，如果是git，url后面的branch不能忽略\n    download(url,\n      dest, &#123; clone: true &#125;, (err) =&gt; &#123;\n        if (err) &#123;\n          spinner.fail() // wrong :(\n          reject(err)\n        &#125; else &#123;\n          spinner.succeed() // ok :)\n            // 下载的模板存放在一个临时路径中，下载完成后，可以向下通知这个临时路径，以便后续处理\n          resolve(dest)\n        &#125;\n      &#125;)\n  &#125;)\n&#125;\n</code></pre>\n<p>lib&#x2F;generator.js:</p>\n<pre><code class=\"javascript\">const Metalsmith = require(&#39;metalsmith&#39;)\nconst Handlebars = require(&#39;handlebars&#39;)\nconst rm = require(&#39;rimraf&#39;).sync\n\nmodule.exports = function(metadata = &#123;&#125;, src, dest = &#39;.&#39;) &#123;\n  if (!src) &#123;\n    return Promise.reject(new Error(`无效的source：$&#123;src&#125;`))\n  &#125;\n\n  return new Promise((resolve, reject) =&gt; &#123;\n    Metalsmith(process.cwd())\n      .metadata(metadata)\n      .clean(false)\n      .source(src)\n      .destination(dest)\n      .use((files, metalsmith, done) =&gt; &#123;\n        const meta = metalsmith.metadata()\n        Object.keys(files).forEach(fileName =&gt; &#123;\n          if (fileName.includes(&#39;package.json&#39;)) &#123;\n            const t = files[fileName].contents.toString()\n            files[fileName].contents = new Buffer.from(Handlebars.compile(t)(meta))\n          &#125;\n        &#125;)\n        done()\n      &#125;).build(err =&gt; &#123;\n        rm(src)\n        err ? reject(err) : resolve(&#123;\n          root: dest\n        &#125;)\n      &#125;)\n  &#125;)\n&#125;\n</code></pre>\n<ol start=\"3\">\n<li>发布到npm</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"Commander-使用\"><a href=\"#Commander-使用\" class=\"headerlink\" title=\"Commander 使用\"></a>Commander 使用</h3><p>commander是Node 命令行交互的一个工具，使用它可以创建自己想要的Node命令。</p>\n<p>Commander有几个基本概念：</p>\n<ul>\n<li><p>version option</p>\n</li>\n<li><p>option</p>\n</li>\n<li><p>command &amp; action</p>\n</li>\n</ul>\n<h4 id=\"version\"><a href=\"#version\" class=\"headerlink\" title=\"version\"></a>version</h4><p>指定<code>cli</code>的版本号。</p>\n<pre><code class=\"javascript\">const program = require(&#39;commander&#39;)\nprogram\n  .version(&#39;0.0.1&#39;, &#39;-v, --version&#39;)\n</code></pre>\n<h4 id=\"Option-parsing\"><a href=\"#Option-parsing\" class=\"headerlink\" title=\"Option parsing\"></a>Option parsing</h4><p>option是用来为commander命令添加一个选项的，用户可以不同的选项来能行特定的功能。</p>\n<pre><code class=\"javascript\">#!/usr/bin/env node\n \n/**\n * Module dependencies.\n */\n \nvar program = require(&#39;commander&#39;);\n \nprogram\n  .version(&#39;0.1.0&#39;)\n  .option(&#39;-p, --peppers&#39;, &#39;Add peppers&#39;)\n  .option(&#39;-P, --pineapple&#39;, &#39;Add pineapple&#39;)\n  .option(&#39;-b, --bbq-sauce&#39;, &#39;Add bbq sauce&#39;)\n  .option(&#39;-c, --cheese [type]&#39;, &#39;Add the specified type of cheese [marble]&#39;, &#39;marble&#39;)\n  .parse(process.argv);\n \nconsole.log(&#39;you ordered a pizza with:&#39;);\nif (program.peppers) console.log(&#39;  - peppers&#39;);\nif (program.pineapple) console.log(&#39;  - pineapple&#39;);\nif (program.bbqSauce) console.log(&#39;  - bbq&#39;);\nconsole.log(&#39;  - %s cheese&#39;, program.cheese);\n</code></pre>\n<p>在Node.js中，用户输入的参数可以通过<code>process.argv</code>得到。<code>commander</code>的<code>option</code>只定义不处理用户输入的参数，需要显式将<code>process.argv</code>传入到<code>parse</code>方法调用才能处理。</p>\n<p>连续输入参数<code>-abc</code>等同于<code>-a -b -c</code>，在<code>cli</code>输入<code>--template-engine</code>，在<code>commander</code>可以通过<code>program.templateEngine</code>驼峰命名取得。</p>\n<p>通过给选项加<code>--no</code>前缀可以给它设置为<code>false</code>，如设置<code>--no-sauce</code>后从<code>program.sauce</code>取到的是<code>false</code>。</p>\n<p>要想拿到选项后输入的值，可以设置中括号（选填）或者尖括号（必填），如<code>.option(&#39;-m --myarg [myVar]&#39;, &#39;my option var&#39;)</code>或<code>.option(&#39;-m --myarg &lt;myVar&gt;&#39;, &#39;my require var&#39;)</code>，然后可以这样来取得值<code>var myInput = program.myarg</code>。</p>\n<h4 id=\"Command-子命令\"><a href=\"#Command-子命令\" class=\"headerlink\" title=\"Command 子命令\"></a>Command 子命令</h4><p>**<code>Command</code>是一个特殊的<code>option</code>**，通过设置子命令可以让工具根据入参来实现的特定的小任务，并且对于子命令也可以像主命令一样设置它的<code>option</code>。</p>\n<pre><code class=\"javascript\">#!/usr/bin/env node\n \nvar program = require(&#39;commander&#39;);\n \nprogram\n  .command(&#39;rm &lt;dir&gt;&#39;)\n  .option(&#39;-r, --recursive&#39;, &#39;Remove recursively&#39;)\n  .action(function (dir, cmd) &#123;\n    console.log(&#39;remove &#39; + dir + (cmd.recursive ? &#39; recursively&#39; : &#39;&#39;))\n  &#125;)\n \nprogram.parse(process.argv)\n</code></pre>\n<h4 id=\"Option-amp-Command-Option\"><a href=\"#Option-amp-Command-Option\" class=\"headerlink\" title=\"Option &amp; Command Option\"></a>Option &amp; Command Option</h4><p>对于主命令的<code>option</code>和子命令有时候比较难区分，我们以一个例子来说明一下它们的使用：</p>\n<p>比如对于主命令<code>tmc</code>来说，它具有初始化项目的功能，那么可以给它定义一个名叫<code>init</code>的<code>option</code>：</p>\n<pre><code class=\"javascript\">#!/usr/bin/env node\n\nconst program = require(&#39;commander&#39;)\n\nprogram\n  .version(&#39;0.1.0&#39;)\n  .option(&#39;-i, --init&#39;, &#39;Init the project&#39;)\n  .parse(process.argv);\n\nif(program.init) &#123;\n  // ... do something\n&#125;\n</code></pre>\n<p>更多的使用方法参照：</p>\n<p>[Commander]: <a href=\"https://www.npmjs.com/package/commander\">https://www.npmjs.com/package/commander</a>\t“commander npm官网”</p>\n<h3 id=\"inquirer\"><a href=\"#inquirer\" class=\"headerlink\" title=\"inquirer\"></a>inquirer</h3><p>inquirer是一个可以和命令行交互的一个工具包，它提供了多种交互方式：input、radio、select等等，简单的用法如下：</p>\n<pre><code class=\"javascript\">var inquirer = require(&#39;inquirer&#39;);\ninquirer\n  .prompt([\n    /* Pass your questions in here */\n  ])\n  .then(answers =&gt; &#123;\n    // Use user feedback for... whatever!!\n  &#125;);\n</code></pre>\n<h3 id=\"download-git-repo\"><a href=\"#download-git-repo\" class=\"headerlink\" title=\"download-git-repo\"></a>download-git-repo</h3><p>这个工具可以把远程仓库上的代码下载到本地然后作下一步的操作，它的使用方法比较简单，</p>\n<p>例如下载<code>github</code>上的代码时可以这样写：</p>\n<pre><code class=\"javascript\">const download = require(&#39;download-git-repo&#39;);\n\n// download(url, desc, option, callback);\n// url: 仓库地址；\n// desc: 下载到本地目录的路径；\n// option: 下载的一些额外选项；\n// callback: 下载完成后的回调函数，可以处理错误信息；\ndownload(&#39;https://mygitlab.com:flipxfx/download-git-repo-fixture#my-branch&#39;, &#39;test/tmp&#39;, &#123; clone: true &#125;, function (err) &#123;\n  console.log(err ? &#39;Error&#39; : &#39;Success&#39;)\n&#125;)\n</code></pre>\n<p>更多的使用方法参照：</p>\n<h3 id=\"Metalsmith\"><a href=\"#Metalsmith\" class=\"headerlink\" title=\"Metalsmith\"></a>Metalsmith</h3><p>Metalsmith是一个静态网站生成器，说抽象了，简单点我个人理解就是它可以把指定目录下的所有文件都遍历出来，然后再把遍历出来的文件每一个都通过定义好的拆件处理一遍，最后再放回去指定的目标路径下。整个过程有点像项目流程构建工具<code>Grunt</code>或者<code>Gulp</code>。</p>\n<p>通过他我们可以很轻松地实现模板插值填充功能。当然如果只有几个文件需要模板插值的话，也可以通过Node API把文件的内容读出来，然后调用模板工具API里对应的编译接口，最后把编译后的内容再覆盖到文件中，这样就不会有种牛刀用到杀鸡上的感觉了。</p>\n<pre><code class=\"javascript\">// Metalsmith(src).use(plugin).build(callback)\nMetalsmith(src)\n  .use(layouts(&#39;handlebars&#39;))\n  .build(function(err) &#123;\n    if (err) throw err;\n    console.log(&#39;Build finished!&#39;);\n  &#125;);\n</code></pre>\n<p>更多的使用方法参照：</p>\n<p>[Metalsmith]: <a href=\"https://www.npmjs.com/package/metalsmith\">https://www.npmjs.com/package/metalsmith</a>\t“metalsmith npm官网”</p>\n<h3 id=\"update-notifier\"><a href=\"#update-notifier\" class=\"headerlink\" title=\"update-notifier\"></a>update-notifier</h3><p>这个工具可以在用户使用你的工具包的时候检查是够有新的版本可以更新，从而觉得下一步的操作。比如如果我发布了某个工具包的新版本，而某位用户还在使用旧版本的时候就会提醒他有新版本可以更新。</p>\n<pre><code class=\"javascript\">const updateNotifier = require(&#39;update-notifier&#39;);\nconst pkg = require(&#39;./package.json&#39;);\n \nupdateNotifier(&#123;pkg&#125;).notify();\n</code></pre>\n<p>更多的使用方法参照：</p>\n<p>[update-notifier]: <a href=\"https://www.npmjs.com/package/update-notifier\">https://www.npmjs.com/package/update-notifier</a>\t“update-notifier npm官网”</p>\n"},{"layout":"[post]","title":"从零到一搭建Vue项目工程（Vue全家桶、Vue测试、持续集成）","date":"2018-07-08T04:49:00.000Z","_content":"\n## 开篇前记\n入门前端有一段时间了，从大学就开始学习前端，到现在刚好毕业就整整4年，其中学习了不少东西，也新出不了少东西，前段的发展总是很快的，一不小心之前所学的技术就开始落后了。以前刚开始学的时候还在学html,css,js三件套，当然还会有JQuery，现在有些人入门都开始直接学Vue框架了。踩过很多坑。但是坑还要一个一个地爬出来，未知的东西还是要一个一个地探索，所以才有了冲动来写这篇文章，第一是为了总结我之前学过的知识和经验，比如Vue全家桶，wepback构建Vue环境等。其次是在我没有实践过的领域进行探索的同时记录下来拿，以后有需要的时候再看回这篇文章。\n\n## 摘要\n我把这篇文章的内容拆成几个版块，作为一个连载的文章。首先列一下主要章节内容：\n\n- 搭建一个运行Vue的webpack环境\n- 加入Vue全家桶\n- 编写项目工程代码\n- 总结Vue测试\n- 关于项目的持续集成\n- 项目总结\n\n因为在编写项目的时候总会附上对应的测试代码，但这样有时候需要看关于Vue测试的内容时会过于零散，所以在写完项目之后专门给了一个小节来写关于Vue的测试内容。当然如果你是从头往下看的话可以跳过这一小节。最后项目 弄好了按照国际惯例总是要总结一下经验的。\n\n## 搭建运行Vue的webpack环境\n\n### 工程目录\n\n```\n|____.gitignore\n|____index.html\n|____LICENSE\n|____package-lock.json\n|____package.json\n|____README.md\n|____src\n| |____App.vue\n| |____assets\n| |____components\n| |____main.js\n| |____view\n|____static\n|____test\n|____webpack.config.js\n```\n\n### webpack配置\n\n这是我摸索了几个钟弄出来的配置（不得不说webpack的配置是真的麻烦），以前都是懒所以直接使用vue-cli初始化出来的项目，webpack配置什么的都已经帮我配好了，这次自己动刀搭了一下才发现这么费劲，期间不断地报错，再加上由于用了4.0版本，也出现了一些坑，这里一并也记录一下，以后再遇到的时候好回头翻翻。\n\n 首先是最基础的webpack框架，不清楚的可以去到[webpack官网](https://www.webpackjs.com/configuration/#%E9%80%89%E9%A1%B9)上找（现在都已经有翻译很好的中文网啦，哪像以前那么苦还要去啃英文 (T^T) ）。当然我们也只会用到其中的几个属性。\n\n```\nconst path = require('path')\nmodule.exports = {\n  entry: '',\n  output: {},\n  module: {\n  \trules: []\n  },\n  plugins: []\n}\n```\n\nOK,这就完成了webpack最基本的框架，接下来我们要分别搭建不同方式启动webpack的方案。（其实这两者在实现原理上本没有什么区别，而对于我们使用者来说区别最大的大概就是工程目录的划分和关于wepback-dev-server的配置）\n\n### 基于webpack-dev-server插件来启动webpack\n\n基于`webpack-dev-server`这种方式启动webpack，我们首先把之前的webpack的配置文件命名为`webpack.config.js`并放在项目的根目录下。然后在`package.json`里的`script`对象添加一个`dev`属性，并在后面添加脚本`webpack-dev-server --inline --hot`再保存。例如：\n\n```\n// package.json\n\n{\n  ...\n  \"scripts\": {\n    \"dev\": \"webpack-dev-server --inline --hot\",\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  ...\n}\n```\n\n然后我们在webpack.config.js文件里添加devServer配置：\n\n```\n// webpack.config.js\n\nconst path = require('path')\n\nmodule.exports = {\n  entry: './src/main.js',\n  output: {\n    path: path.resolve(__dirname, './dist'),\n    publicPath: '/dist/',\n    filename: 'build.js'\n  },\n  module: {\n    rules: []\n  },\n  plugins: [],\n  devServer: {\n    // contentBase: path.join(__dirname, \"dist\"),\n    // 确保 publicPath 总是以斜杠(/)开头和结尾。\n    // 默认会取output.path的值，设置之后会覆盖使用devServer.publicPath的值\n    // publicPath: \"/\",\n    historyApiFallback: true,\n    compress: true,\n    proxy: { // proxy URLs to backend development server\n      // '/api': 'http://localhost:3000',\n      // '/api': {\n      //   target: 'http://localhost:3000',\n      //   pathRewrite: {'^/api' : ''}\n      // }\n    },\n    hot: true,\n    inline: true\n  },\n  devtool: '#eval-source-map'\n}\n```\n\n这样就可以把webpack-dev-server启动起来啦~~\n\n### 基于node + express 方式来启动webpack\n\n### 基本可以运行Vue项目的webpack配置\n\n完成了上面的步骤之后，接下来就是配置vue相关的东西了，先回想在使用vue开发的时候，我们会新建一个vue后缀的文件，所以我们就需要一个loader来解析和读取.vue文件的内容。先安装：\n\n```\nnpm install --save-dev vue-loader vue-template-compiler\n```\n\n然后我们再在wepback配置中的module.rules中使用：\n\n```\n// webpack.config.js/webpack.base.conf.js\n\nmodule.exports = {\n  ...\n  module: {\n    rules: [\n      {\n        test: /\\.vue$/,\n        loader: 'vue-loader',\n        options: {}\n      }\n    ]\n  },\n  ...\n```\n\n至于这里为什么要安装`vue-template-compiler`，是因为单纯使用`vue-loader`启动的时候会报错，提示在没有`vue-template-compiler`的情况下使用`vue-loader`，我在网上查了一下也有人写了[blog](https://blog.csdn.net/cominglately/article/details/80555210)说明了这一情况，意思大概是升级到webpack 4.0之后会出现的问题。为了解决这个问题我们要在webpack配置上使用一下。\n\n```\n// webpack.config.js/webpack.base.conf.js\n\nconst path = require('path')\nconst VueLoaderPlugin = require('vue-loader/lib/plugin');\n\nmodule.exports = {\n  ...\n  module: {\n    rules: [\n      {\n        test: /\\.vue$/,\n        loader: 'vue-loader',\n        options: {}\n      }\n    ]\n  },\n  plugins: [\n    new VueLoaderPlugin()\n  ],\n  ...\n```\n现在就可以读vue文件了，接下来就是对vue文件里的css、非标准的js、图片分别配置，也让webpack可以有能力解析。\n\n解析css（css-loader是解析css的，style-loader是把css以<style></style>内嵌的方式注入到html中）:\n```\nnpm install --save-dev style-loader css-loader\n```\n\n解析非标准的js（[使用babel](https://www.babeljs.cn/docs/setup/#installation)）:\n```\nnpm install --save-dev babel-loader babel-preset-env\n```\n\n解析img:\n```\nnpm install --save-dev file-loader\n```\n\n然后再分别写到rules里面，就完成了。整个配置如下：\n\n```\n// webpack.config.js/webpack.base.conf.js\n\nconst path = require('path')\nconst VueLoaderPlugin = require('vue-loader/lib/plugin');\n\nmodule.exports = {\n  entry: './src/main.js',\n  output: {\n    path: path.resolve(__dirname, './dist'),\n    publicPath: '/dist/',\n    filename: 'build.js'\n  },\n  module: {\n    rules: [{\n        test: /\\.css$/,\n        use: [\n          'vue-style-loader',\n          'css-loader'\n        ]\n      },\n      {\n        test: /\\.js$/,\n        loader: 'babel-loader',\n        exclude: /node_modules/\n      },\n      {\n        test: /\\.vue$/,\n        loader: 'vue-loader',\n        options: {}\n      },\n      {\n        test: /\\.(png|jpg|gif|svg)$/,\n        loader: 'file-loader',\n        options: {\n          name: '[name].[ext]?[hash]'\n        }\n      }\n    ]\n  },\n  plugins: [\n    new VueLoaderPlugin()\n  ],\n  devServer: {\n    // contentBase: path.join(__dirname, \"dist\"),\n    // 确保 publicPath 总是以斜杠(/)开头和结尾。\n    // 默认会取output.path的值，设置之后会覆盖使用devServer.publicPath的值\n    // publicPath: \"/\",\n    historyApiFallback: true,\n    compress: true,\n    proxy: { // proxy URLs to backend development server\n      // '/api': 'http://localhost:3000',\n      // '/api': {\n      //   target: 'http://localhost:3000',\n      //   pathRewrite: {'^/api' : ''}\n      // }\n    },\n    hot: true,\n    inline: true\n  },\n  devtool: '#eval-source-map'\n}\n```\n\n### 项目优化\n\n按照刚刚的步骤进行操作的话，会发现当项目运行起来的时候webpack会报如下错误，现在慢慢地按照提示来对项目进行优化。\n\n[![qqEhK.png](https://s1.ax2x.com/2018/07/19/qqEhK.png)](https://simimg.com/i/qqEhK)\n\n#### WARNING in configuration\n\n```\nThe 'mode' option has not been set, webpack will fallback to 'production' for this value. Set 'mode' option to 'development' or 'production' to enable defaults for each environment.\nYou can also set it to 'none' to disable any default behavior. Learn more: https://webpack.js.org/concepts/mode/\n```\n翻译成中文的意思大概是：`mode`这个选项没有被设置，webpack将会默认设置为`production`。你可以把`mode`选项设置为`development`或者`production`，以让webpack以指定的环境启动。你也可以设置为`none`以禁用任何的默认行为。[了解更多：https://webpack.js.org/concepts/mode/](https://webpack.js.org/concepts/mode/)。\n\n这个问题主要是告诉我们要让webpack知道现是要按什么环境去构建应用，通常我们会通过一个配置文件来记录所有会用到的环境，然后在调用的时候通过传入参数的形式来指定使用哪一个环境。\n\n我们新建一个目录`config`，在目录里面再分别建立不同环境的配置，如：\n\n```\n├── config\n│   ├── dev.js\n│   ├── index.js\n│   ├── prod.js\n│   └── test.js\n```\n\n我们分别区别了开发环境、生产环境、和测试环境，然后再通过一个index.js来判断当前使用哪一个环境：\n\n```\n// index.js\nconst prod = require('./prod')\nconst dev = require('./dev')\nconst test = require('./test')\n\nlet env = prod;\n\nswitch (process.env.NODE_ENV) {\n  case 'development':\n    env = dev;\n    break;\n    // case 'test':\n    //   env = test;\n    //   break;\n  default:\n    env = prod;\n}\n\nmodule.exports = env\n```\n\n这里的`process.env`是node.js的一个环境变量对象，挂载到这个对象上的属性可以在node的全局运行环境中访问到，而`NODE_ENV`是node社区约定作为当前运行环境的属性（当然你也可以用其它属性代替）。\n\n为了我们在启动的时候可以为node指定当前运行环境，我们新加入一个依赖包叫[cross-env](https://www.npmjs.com/package/cross-env)，然后修改`package.json`文件里的运行脚本命令，添加`cross-env NODE_ENV=[prototype]`在命令前面即可，如：\n\n```\n// package.json\n\n...\n\"scripts\": {\n  \"dev\": \"cross-env NODE_ENV=development webpack-dev-server --inline --hot\",\n  \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n},\n...\n```\n\n#### WARNING in asset size limit\n\n```\nThe following asset(s) exceed the recommended size limit (244 KiB).\nThis can impact web performance.\nAssets:\n  build.js (2.13 MiB)\n```\n\n#### WARNING in entrypoint size limit\n\n```\nThe following entrypoint(s) combined asset size exceeds the recommended limit (244 KiB). This can impact web performance.\nEntrypoints:\n  main (2.13 MiB)\n      build.js\n      0.9256098444c5c2f2e51c.hot-update.js\n```\n\n#### WARNING in webpack performance recommendations\n\n```\nYou can limit the size of your bundles by using import() or require.ensure to lazy load some parts of your application.\nFor more info visit https://webpack.js.org/guides/code-splitting/\n```\n\n","source":"_posts/0to1-build-vue-project.md","raw":"layout: '[post]'\ntitle: 从零到一搭建Vue项目工程（Vue全家桶、Vue测试、持续集成）\ntags:\n  - 个人总结\ncategories:\n  - Vue\n  - ''\ndate: 2018-07-08 12:49:00\n---\n\n## 开篇前记\n入门前端有一段时间了，从大学就开始学习前端，到现在刚好毕业就整整4年，其中学习了不少东西，也新出不了少东西，前段的发展总是很快的，一不小心之前所学的技术就开始落后了。以前刚开始学的时候还在学html,css,js三件套，当然还会有JQuery，现在有些人入门都开始直接学Vue框架了。踩过很多坑。但是坑还要一个一个地爬出来，未知的东西还是要一个一个地探索，所以才有了冲动来写这篇文章，第一是为了总结我之前学过的知识和经验，比如Vue全家桶，wepback构建Vue环境等。其次是在我没有实践过的领域进行探索的同时记录下来拿，以后有需要的时候再看回这篇文章。\n\n## 摘要\n我把这篇文章的内容拆成几个版块，作为一个连载的文章。首先列一下主要章节内容：\n\n- 搭建一个运行Vue的webpack环境\n- 加入Vue全家桶\n- 编写项目工程代码\n- 总结Vue测试\n- 关于项目的持续集成\n- 项目总结\n\n因为在编写项目的时候总会附上对应的测试代码，但这样有时候需要看关于Vue测试的内容时会过于零散，所以在写完项目之后专门给了一个小节来写关于Vue的测试内容。当然如果你是从头往下看的话可以跳过这一小节。最后项目 弄好了按照国际惯例总是要总结一下经验的。\n\n## 搭建运行Vue的webpack环境\n\n### 工程目录\n\n```\n|____.gitignore\n|____index.html\n|____LICENSE\n|____package-lock.json\n|____package.json\n|____README.md\n|____src\n| |____App.vue\n| |____assets\n| |____components\n| |____main.js\n| |____view\n|____static\n|____test\n|____webpack.config.js\n```\n\n### webpack配置\n\n这是我摸索了几个钟弄出来的配置（不得不说webpack的配置是真的麻烦），以前都是懒所以直接使用vue-cli初始化出来的项目，webpack配置什么的都已经帮我配好了，这次自己动刀搭了一下才发现这么费劲，期间不断地报错，再加上由于用了4.0版本，也出现了一些坑，这里一并也记录一下，以后再遇到的时候好回头翻翻。\n\n 首先是最基础的webpack框架，不清楚的可以去到[webpack官网](https://www.webpackjs.com/configuration/#%E9%80%89%E9%A1%B9)上找（现在都已经有翻译很好的中文网啦，哪像以前那么苦还要去啃英文 (T^T) ）。当然我们也只会用到其中的几个属性。\n\n```\nconst path = require('path')\nmodule.exports = {\n  entry: '',\n  output: {},\n  module: {\n  \trules: []\n  },\n  plugins: []\n}\n```\n\nOK,这就完成了webpack最基本的框架，接下来我们要分别搭建不同方式启动webpack的方案。（其实这两者在实现原理上本没有什么区别，而对于我们使用者来说区别最大的大概就是工程目录的划分和关于wepback-dev-server的配置）\n\n### 基于webpack-dev-server插件来启动webpack\n\n基于`webpack-dev-server`这种方式启动webpack，我们首先把之前的webpack的配置文件命名为`webpack.config.js`并放在项目的根目录下。然后在`package.json`里的`script`对象添加一个`dev`属性，并在后面添加脚本`webpack-dev-server --inline --hot`再保存。例如：\n\n```\n// package.json\n\n{\n  ...\n  \"scripts\": {\n    \"dev\": \"webpack-dev-server --inline --hot\",\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  ...\n}\n```\n\n然后我们在webpack.config.js文件里添加devServer配置：\n\n```\n// webpack.config.js\n\nconst path = require('path')\n\nmodule.exports = {\n  entry: './src/main.js',\n  output: {\n    path: path.resolve(__dirname, './dist'),\n    publicPath: '/dist/',\n    filename: 'build.js'\n  },\n  module: {\n    rules: []\n  },\n  plugins: [],\n  devServer: {\n    // contentBase: path.join(__dirname, \"dist\"),\n    // 确保 publicPath 总是以斜杠(/)开头和结尾。\n    // 默认会取output.path的值，设置之后会覆盖使用devServer.publicPath的值\n    // publicPath: \"/\",\n    historyApiFallback: true,\n    compress: true,\n    proxy: { // proxy URLs to backend development server\n      // '/api': 'http://localhost:3000',\n      // '/api': {\n      //   target: 'http://localhost:3000',\n      //   pathRewrite: {'^/api' : ''}\n      // }\n    },\n    hot: true,\n    inline: true\n  },\n  devtool: '#eval-source-map'\n}\n```\n\n这样就可以把webpack-dev-server启动起来啦~~\n\n### 基于node + express 方式来启动webpack\n\n### 基本可以运行Vue项目的webpack配置\n\n完成了上面的步骤之后，接下来就是配置vue相关的东西了，先回想在使用vue开发的时候，我们会新建一个vue后缀的文件，所以我们就需要一个loader来解析和读取.vue文件的内容。先安装：\n\n```\nnpm install --save-dev vue-loader vue-template-compiler\n```\n\n然后我们再在wepback配置中的module.rules中使用：\n\n```\n// webpack.config.js/webpack.base.conf.js\n\nmodule.exports = {\n  ...\n  module: {\n    rules: [\n      {\n        test: /\\.vue$/,\n        loader: 'vue-loader',\n        options: {}\n      }\n    ]\n  },\n  ...\n```\n\n至于这里为什么要安装`vue-template-compiler`，是因为单纯使用`vue-loader`启动的时候会报错，提示在没有`vue-template-compiler`的情况下使用`vue-loader`，我在网上查了一下也有人写了[blog](https://blog.csdn.net/cominglately/article/details/80555210)说明了这一情况，意思大概是升级到webpack 4.0之后会出现的问题。为了解决这个问题我们要在webpack配置上使用一下。\n\n```\n// webpack.config.js/webpack.base.conf.js\n\nconst path = require('path')\nconst VueLoaderPlugin = require('vue-loader/lib/plugin');\n\nmodule.exports = {\n  ...\n  module: {\n    rules: [\n      {\n        test: /\\.vue$/,\n        loader: 'vue-loader',\n        options: {}\n      }\n    ]\n  },\n  plugins: [\n    new VueLoaderPlugin()\n  ],\n  ...\n```\n现在就可以读vue文件了，接下来就是对vue文件里的css、非标准的js、图片分别配置，也让webpack可以有能力解析。\n\n解析css（css-loader是解析css的，style-loader是把css以<style></style>内嵌的方式注入到html中）:\n```\nnpm install --save-dev style-loader css-loader\n```\n\n解析非标准的js（[使用babel](https://www.babeljs.cn/docs/setup/#installation)）:\n```\nnpm install --save-dev babel-loader babel-preset-env\n```\n\n解析img:\n```\nnpm install --save-dev file-loader\n```\n\n然后再分别写到rules里面，就完成了。整个配置如下：\n\n```\n// webpack.config.js/webpack.base.conf.js\n\nconst path = require('path')\nconst VueLoaderPlugin = require('vue-loader/lib/plugin');\n\nmodule.exports = {\n  entry: './src/main.js',\n  output: {\n    path: path.resolve(__dirname, './dist'),\n    publicPath: '/dist/',\n    filename: 'build.js'\n  },\n  module: {\n    rules: [{\n        test: /\\.css$/,\n        use: [\n          'vue-style-loader',\n          'css-loader'\n        ]\n      },\n      {\n        test: /\\.js$/,\n        loader: 'babel-loader',\n        exclude: /node_modules/\n      },\n      {\n        test: /\\.vue$/,\n        loader: 'vue-loader',\n        options: {}\n      },\n      {\n        test: /\\.(png|jpg|gif|svg)$/,\n        loader: 'file-loader',\n        options: {\n          name: '[name].[ext]?[hash]'\n        }\n      }\n    ]\n  },\n  plugins: [\n    new VueLoaderPlugin()\n  ],\n  devServer: {\n    // contentBase: path.join(__dirname, \"dist\"),\n    // 确保 publicPath 总是以斜杠(/)开头和结尾。\n    // 默认会取output.path的值，设置之后会覆盖使用devServer.publicPath的值\n    // publicPath: \"/\",\n    historyApiFallback: true,\n    compress: true,\n    proxy: { // proxy URLs to backend development server\n      // '/api': 'http://localhost:3000',\n      // '/api': {\n      //   target: 'http://localhost:3000',\n      //   pathRewrite: {'^/api' : ''}\n      // }\n    },\n    hot: true,\n    inline: true\n  },\n  devtool: '#eval-source-map'\n}\n```\n\n### 项目优化\n\n按照刚刚的步骤进行操作的话，会发现当项目运行起来的时候webpack会报如下错误，现在慢慢地按照提示来对项目进行优化。\n\n[![qqEhK.png](https://s1.ax2x.com/2018/07/19/qqEhK.png)](https://simimg.com/i/qqEhK)\n\n#### WARNING in configuration\n\n```\nThe 'mode' option has not been set, webpack will fallback to 'production' for this value. Set 'mode' option to 'development' or 'production' to enable defaults for each environment.\nYou can also set it to 'none' to disable any default behavior. Learn more: https://webpack.js.org/concepts/mode/\n```\n翻译成中文的意思大概是：`mode`这个选项没有被设置，webpack将会默认设置为`production`。你可以把`mode`选项设置为`development`或者`production`，以让webpack以指定的环境启动。你也可以设置为`none`以禁用任何的默认行为。[了解更多：https://webpack.js.org/concepts/mode/](https://webpack.js.org/concepts/mode/)。\n\n这个问题主要是告诉我们要让webpack知道现是要按什么环境去构建应用，通常我们会通过一个配置文件来记录所有会用到的环境，然后在调用的时候通过传入参数的形式来指定使用哪一个环境。\n\n我们新建一个目录`config`，在目录里面再分别建立不同环境的配置，如：\n\n```\n├── config\n│   ├── dev.js\n│   ├── index.js\n│   ├── prod.js\n│   └── test.js\n```\n\n我们分别区别了开发环境、生产环境、和测试环境，然后再通过一个index.js来判断当前使用哪一个环境：\n\n```\n// index.js\nconst prod = require('./prod')\nconst dev = require('./dev')\nconst test = require('./test')\n\nlet env = prod;\n\nswitch (process.env.NODE_ENV) {\n  case 'development':\n    env = dev;\n    break;\n    // case 'test':\n    //   env = test;\n    //   break;\n  default:\n    env = prod;\n}\n\nmodule.exports = env\n```\n\n这里的`process.env`是node.js的一个环境变量对象，挂载到这个对象上的属性可以在node的全局运行环境中访问到，而`NODE_ENV`是node社区约定作为当前运行环境的属性（当然你也可以用其它属性代替）。\n\n为了我们在启动的时候可以为node指定当前运行环境，我们新加入一个依赖包叫[cross-env](https://www.npmjs.com/package/cross-env)，然后修改`package.json`文件里的运行脚本命令，添加`cross-env NODE_ENV=[prototype]`在命令前面即可，如：\n\n```\n// package.json\n\n...\n\"scripts\": {\n  \"dev\": \"cross-env NODE_ENV=development webpack-dev-server --inline --hot\",\n  \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n},\n...\n```\n\n#### WARNING in asset size limit\n\n```\nThe following asset(s) exceed the recommended size limit (244 KiB).\nThis can impact web performance.\nAssets:\n  build.js (2.13 MiB)\n```\n\n#### WARNING in entrypoint size limit\n\n```\nThe following entrypoint(s) combined asset size exceeds the recommended limit (244 KiB). This can impact web performance.\nEntrypoints:\n  main (2.13 MiB)\n      build.js\n      0.9256098444c5c2f2e51c.hot-update.js\n```\n\n#### WARNING in webpack performance recommendations\n\n```\nYou can limit the size of your bundles by using import() or require.ensure to lazy load some parts of your application.\nFor more info visit https://webpack.js.org/guides/code-splitting/\n```\n\n","slug":"0to1-build-vue-project","published":1,"updated":"2023-04-11T03:30:27.108Z","comments":1,"photos":[],"link":"","_id":"clgbppeb50007bvch2hcz1hve","content":"<h2><a href=\"#kai-pian-qian-ji\" class=\"header-anchor\"></a><span id=\"kai-pian-qian-ji\">开篇前记</span></h2><p>入门前端有一段时间了，从大学就开始学习前端，到现在刚好毕业就整整4年，其中学习了不少东西，也新出不了少东西，前段的发展总是很快的，一不小心之前所学的技术就开始落后了。以前刚开始学的时候还在学html,css,js三件套，当然还会有JQuery，现在有些人入门都开始直接学Vue框架了。踩过很多坑。但是坑还要一个一个地爬出来，未知的东西还是要一个一个地探索，所以才有了冲动来写这篇文章，第一是为了总结我之前学过的知识和经验，比如Vue全家桶，wepback构建Vue环境等。其次是在我没有实践过的领域进行探索的同时记录下来拿，以后有需要的时候再看回这篇文章。</p>\n<h2><a href=\"#zhai-yao\" class=\"header-anchor\"></a><span id=\"zhai-yao\">摘要</span></h2><p>我把这篇文章的内容拆成几个版块，作为一个连载的文章。首先列一下主要章节内容：</p>\n<ul>\n<li>搭建一个运行Vue的webpack环境</li>\n<li>加入Vue全家桶</li>\n<li>编写项目工程代码</li>\n<li>总结Vue测试</li>\n<li>关于项目的持续集成</li>\n<li>项目总结</li>\n</ul>\n<p>因为在编写项目的时候总会附上对应的测试代码，但这样有时候需要看关于Vue测试的内容时会过于零散，所以在写完项目之后专门给了一个小节来写关于Vue的测试内容。当然如果你是从头往下看的话可以跳过这一小节。最后项目 弄好了按照国际惯例总是要总结一下经验的。</p>\n<h2><a href=\"#da-jian-yun-xing-vue-de-webpack-huan-jing\" class=\"header-anchor\"></a><span id=\"da-jian-yun-xing-vue-de-webpack-huan-jing\">搭建运行Vue的webpack环境</span></h2><h3><a href=\"#gong-cheng-mu-lu\" class=\"header-anchor\"></a><span id=\"gong-cheng-mu-lu\">工程目录</span></h3><pre><code>|____.gitignore\n|____index.html\n|____LICENSE\n|____package-lock.json\n|____package.json\n|____README.md\n|____src\n| |____App.vue\n| |____assets\n| |____components\n| |____main.js\n| |____view\n|____static\n|____test\n|____webpack.config.js\n</code></pre>\n<h3><a href=\"#webpack-pei-zhi\" class=\"header-anchor\"></a><span id=\"webpack-pei-zhi\">webpack配置</span></h3><p>这是我摸索了几个钟弄出来的配置（不得不说webpack的配置是真的麻烦），以前都是懒所以直接使用vue-cli初始化出来的项目，webpack配置什么的都已经帮我配好了，这次自己动刀搭了一下才发现这么费劲，期间不断地报错，再加上由于用了4.0版本，也出现了一些坑，这里一并也记录一下，以后再遇到的时候好回头翻翻。</p>\n<p> 首先是最基础的webpack框架，不清楚的可以去到<a href=\"https://www.webpackjs.com/configuration/#%E9%80%89%E9%A1%B9\">webpack官网</a>上找（现在都已经有翻译很好的中文网啦，哪像以前那么苦还要去啃英文 (T^T) ）。当然我们也只会用到其中的几个属性。</p>\n<pre><code>const path = require(&#39;path&#39;)\nmodule.exports = &#123;\n  entry: &#39;&#39;,\n  output: &#123;&#125;,\n  module: &#123;\n      rules: []\n  &#125;,\n  plugins: []\n&#125;\n</code></pre>\n<p>OK,这就完成了webpack最基本的框架，接下来我们要分别搭建不同方式启动webpack的方案。（其实这两者在实现原理上本没有什么区别，而对于我们使用者来说区别最大的大概就是工程目录的划分和关于wepback-dev-server的配置）</p>\n<h3><a href=\"#ji-yu-webpack-dev-server-cha-jian-lai-qi-dong-webpack\" class=\"header-anchor\"></a><span id=\"ji-yu-webpack-dev-server-cha-jian-lai-qi-dong-webpack\">基于webpack-dev-server插件来启动webpack</span></h3><p>基于<code>webpack-dev-server</code>这种方式启动webpack，我们首先把之前的webpack的配置文件命名为<code>webpack.config.js</code>并放在项目的根目录下。然后在<code>package.json</code>里的<code>script</code>对象添加一个<code>dev</code>属性，并在后面添加脚本<code>webpack-dev-server --inline --hot</code>再保存。例如：</p>\n<pre><code>// package.json\n\n&#123;\n  ...\n  &quot;scripts&quot;: &#123;\n    &quot;dev&quot;: &quot;webpack-dev-server --inline --hot&quot;,\n    &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;\n  &#125;,\n  ...\n&#125;\n</code></pre>\n<p>然后我们在webpack.config.js文件里添加devServer配置：</p>\n<pre><code>// webpack.config.js\n\nconst path = require(&#39;path&#39;)\n\nmodule.exports = &#123;\n  entry: &#39;./src/main.js&#39;,\n  output: &#123;\n    path: path.resolve(__dirname, &#39;./dist&#39;),\n    publicPath: &#39;/dist/&#39;,\n    filename: &#39;build.js&#39;\n  &#125;,\n  module: &#123;\n    rules: []\n  &#125;,\n  plugins: [],\n  devServer: &#123;\n    // contentBase: path.join(__dirname, &quot;dist&quot;),\n    // 确保 publicPath 总是以斜杠(/)开头和结尾。\n    // 默认会取output.path的值，设置之后会覆盖使用devServer.publicPath的值\n    // publicPath: &quot;/&quot;,\n    historyApiFallback: true,\n    compress: true,\n    proxy: &#123; // proxy URLs to backend development server\n      // &#39;/api&#39;: &#39;http://localhost:3000&#39;,\n      // &#39;/api&#39;: &#123;\n      //   target: &#39;http://localhost:3000&#39;,\n      //   pathRewrite: &#123;&#39;^/api&#39; : &#39;&#39;&#125;\n      // &#125;\n    &#125;,\n    hot: true,\n    inline: true\n  &#125;,\n  devtool: &#39;#eval-source-map&#39;\n&#125;\n</code></pre>\n<p>这样就可以把webpack-dev-server启动起来啦~~</p>\n<h3><a href=\"#ji-yu-node-express-fang-shi-lai-qi-dong-webpack\" class=\"header-anchor\"></a><span id=\"ji-yu-node-express-fang-shi-lai-qi-dong-webpack\">基于node + express 方式来启动webpack</span></h3><h3><a href=\"#ji-ben-ke-yi-yun-xing-vue-xiang-mu-de-webpack-pei-zhi\" class=\"header-anchor\"></a><span id=\"ji-ben-ke-yi-yun-xing-vue-xiang-mu-de-webpack-pei-zhi\">基本可以运行Vue项目的webpack配置</span></h3><p>完成了上面的步骤之后，接下来就是配置vue相关的东西了，先回想在使用vue开发的时候，我们会新建一个vue后缀的文件，所以我们就需要一个loader来解析和读取.vue文件的内容。先安装：</p>\n<pre><code>npm install --save-dev vue-loader vue-template-compiler\n</code></pre>\n<p>然后我们再在wepback配置中的module.rules中使用：</p>\n<pre><code>// webpack.config.js/webpack.base.conf.js\n\nmodule.exports = &#123;\n  ...\n  module: &#123;\n    rules: [\n      &#123;\n        test: /\\.vue$/,\n        loader: &#39;vue-loader&#39;,\n        options: &#123;&#125;\n      &#125;\n    ]\n  &#125;,\n  ...\n</code></pre>\n<p>至于这里为什么要安装<code>vue-template-compiler</code>，是因为单纯使用<code>vue-loader</code>启动的时候会报错，提示在没有<code>vue-template-compiler</code>的情况下使用<code>vue-loader</code>，我在网上查了一下也有人写了<a href=\"https://blog.csdn.net/cominglately/article/details/80555210\">blog</a>说明了这一情况，意思大概是升级到webpack 4.0之后会出现的问题。为了解决这个问题我们要在webpack配置上使用一下。</p>\n<pre><code>// webpack.config.js/webpack.base.conf.js\n\nconst path = require(&#39;path&#39;)\nconst VueLoaderPlugin = require(&#39;vue-loader/lib/plugin&#39;);\n\nmodule.exports = &#123;\n  ...\n  module: &#123;\n    rules: [\n      &#123;\n        test: /\\.vue$/,\n        loader: &#39;vue-loader&#39;,\n        options: &#123;&#125;\n      &#125;\n    ]\n  &#125;,\n  plugins: [\n    new VueLoaderPlugin()\n  ],\n  ...\n</code></pre>\n<p>现在就可以读vue文件了，接下来就是对vue文件里的css、非标准的js、图片分别配置，也让webpack可以有能力解析。</p>\n<p>解析css（css-loader是解析css的，style-loader是把css以<style></style>内嵌的方式注入到html中）:</p>\n<pre><code>npm install --save-dev style-loader css-loader\n</code></pre>\n<p>解析非标准的js（<a href=\"https://www.babeljs.cn/docs/setup/#installation\">使用babel</a>）:</p>\n<pre><code>npm install --save-dev babel-loader babel-preset-env\n</code></pre>\n<p>解析img:</p>\n<pre><code>npm install --save-dev file-loader\n</code></pre>\n<p>然后再分别写到rules里面，就完成了。整个配置如下：</p>\n<pre><code>// webpack.config.js/webpack.base.conf.js\n\nconst path = require(&#39;path&#39;)\nconst VueLoaderPlugin = require(&#39;vue-loader/lib/plugin&#39;);\n\nmodule.exports = &#123;\n  entry: &#39;./src/main.js&#39;,\n  output: &#123;\n    path: path.resolve(__dirname, &#39;./dist&#39;),\n    publicPath: &#39;/dist/&#39;,\n    filename: &#39;build.js&#39;\n  &#125;,\n  module: &#123;\n    rules: [&#123;\n        test: /\\.css$/,\n        use: [\n          &#39;vue-style-loader&#39;,\n          &#39;css-loader&#39;\n        ]\n      &#125;,\n      &#123;\n        test: /\\.js$/,\n        loader: &#39;babel-loader&#39;,\n        exclude: /node_modules/\n      &#125;,\n      &#123;\n        test: /\\.vue$/,\n        loader: &#39;vue-loader&#39;,\n        options: &#123;&#125;\n      &#125;,\n      &#123;\n        test: /\\.(png|jpg|gif|svg)$/,\n        loader: &#39;file-loader&#39;,\n        options: &#123;\n          name: &#39;[name].[ext]?[hash]&#39;\n        &#125;\n      &#125;\n    ]\n  &#125;,\n  plugins: [\n    new VueLoaderPlugin()\n  ],\n  devServer: &#123;\n    // contentBase: path.join(__dirname, &quot;dist&quot;),\n    // 确保 publicPath 总是以斜杠(/)开头和结尾。\n    // 默认会取output.path的值，设置之后会覆盖使用devServer.publicPath的值\n    // publicPath: &quot;/&quot;,\n    historyApiFallback: true,\n    compress: true,\n    proxy: &#123; // proxy URLs to backend development server\n      // &#39;/api&#39;: &#39;http://localhost:3000&#39;,\n      // &#39;/api&#39;: &#123;\n      //   target: &#39;http://localhost:3000&#39;,\n      //   pathRewrite: &#123;&#39;^/api&#39; : &#39;&#39;&#125;\n      // &#125;\n    &#125;,\n    hot: true,\n    inline: true\n  &#125;,\n  devtool: &#39;#eval-source-map&#39;\n&#125;\n</code></pre>\n<h3><a href=\"#xiang-mu-you-hua\" class=\"header-anchor\"></a><span id=\"xiang-mu-you-hua\">项目优化</span></h3><p>按照刚刚的步骤进行操作的话，会发现当项目运行起来的时候webpack会报如下错误，现在慢慢地按照提示来对项目进行优化。</p>\n<p><a href=\"https://simimg.com/i/qqEhK\"><img src=\"https://s1.ax2x.com/2018/07/19/qqEhK.png\" alt=\"qqEhK.png\"></a></p>\n<h4><a href=\"#warning-in-configuration\" class=\"header-anchor\"></a><span id=\"warning-in-configuration\">WARNING in configuration</span></h4><pre><code>The &#39;mode&#39; option has not been set, webpack will fallback to &#39;production&#39; for this value. Set &#39;mode&#39; option to &#39;development&#39; or &#39;production&#39; to enable defaults for each environment.\nYou can also set it to &#39;none&#39; to disable any default behavior. Learn more: https://webpack.js.org/concepts/mode/\n</code></pre>\n<p>翻译成中文的意思大概是：<code>mode</code>这个选项没有被设置，webpack将会默认设置为<code>production</code>。你可以把<code>mode</code>选项设置为<code>development</code>或者<code>production</code>，以让webpack以指定的环境启动。你也可以设置为<code>none</code>以禁用任何的默认行为。<a href=\"https://webpack.js.org/concepts/mode/\">了解更多：https://webpack.js.org/concepts/mode/</a>。</p>\n<p>这个问题主要是告诉我们要让webpack知道现是要按什么环境去构建应用，通常我们会通过一个配置文件来记录所有会用到的环境，然后在调用的时候通过传入参数的形式来指定使用哪一个环境。</p>\n<p>我们新建一个目录<code>config</code>，在目录里面再分别建立不同环境的配置，如：</p>\n<pre><code>├── config\n│   ├── dev.js\n│   ├── index.js\n│   ├── prod.js\n│   └── test.js\n</code></pre>\n<p>我们分别区别了开发环境、生产环境、和测试环境，然后再通过一个index.js来判断当前使用哪一个环境：</p>\n<pre><code>// index.js\nconst prod = require(&#39;./prod&#39;)\nconst dev = require(&#39;./dev&#39;)\nconst test = require(&#39;./test&#39;)\n\nlet env = prod;\n\nswitch (process.env.NODE_ENV) &#123;\n  case &#39;development&#39;:\n    env = dev;\n    break;\n    // case &#39;test&#39;:\n    //   env = test;\n    //   break;\n  default:\n    env = prod;\n&#125;\n\nmodule.exports = env\n</code></pre>\n<p>这里的<code>process.env</code>是node.js的一个环境变量对象，挂载到这个对象上的属性可以在node的全局运行环境中访问到，而<code>NODE_ENV</code>是node社区约定作为当前运行环境的属性（当然你也可以用其它属性代替）。</p>\n<p>为了我们在启动的时候可以为node指定当前运行环境，我们新加入一个依赖包叫<a href=\"https://www.npmjs.com/package/cross-env\">cross-env</a>，然后修改<code>package.json</code>文件里的运行脚本命令，添加<code>cross-env NODE_ENV=[prototype]</code>在命令前面即可，如：</p>\n<pre><code>// package.json\n\n...\n&quot;scripts&quot;: &#123;\n  &quot;dev&quot;: &quot;cross-env NODE_ENV=development webpack-dev-server --inline --hot&quot;,\n  &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;\n&#125;,\n...\n</code></pre>\n<h4><a href=\"#warning-in-asset-size-limit\" class=\"header-anchor\"></a><span id=\"warning-in-asset-size-limit\">WARNING in asset size limit</span></h4><pre><code>The following asset(s) exceed the recommended size limit (244 KiB).\nThis can impact web performance.\nAssets:\n  build.js (2.13 MiB)\n</code></pre>\n<h4><a href=\"#warning-in-entrypoint-size-limit\" class=\"header-anchor\"></a><span id=\"warning-in-entrypoint-size-limit\">WARNING in entrypoint size limit</span></h4><pre><code>The following entrypoint(s) combined asset size exceeds the recommended limit (244 KiB). This can impact web performance.\nEntrypoints:\n  main (2.13 MiB)\n      build.js\n      0.9256098444c5c2f2e51c.hot-update.js\n</code></pre>\n<h4><a href=\"#warning-in-webpack-performance-recommendations\" class=\"header-anchor\"></a><span id=\"warning-in-webpack-performance-recommendations\">WARNING in webpack performance recommendations</span></h4><pre><code>You can limit the size of your bundles by using import() or require.ensure to lazy load some parts of your application.\nFor more info visit https://webpack.js.org/guides/code-splitting/\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"开篇前记\"><a href=\"#开篇前记\" class=\"headerlink\" title=\"开篇前记\"></a>开篇前记</h2><p>入门前端有一段时间了，从大学就开始学习前端，到现在刚好毕业就整整4年，其中学习了不少东西，也新出不了少东西，前段的发展总是很快的，一不小心之前所学的技术就开始落后了。以前刚开始学的时候还在学html,css,js三件套，当然还会有JQuery，现在有些人入门都开始直接学Vue框架了。踩过很多坑。但是坑还要一个一个地爬出来，未知的东西还是要一个一个地探索，所以才有了冲动来写这篇文章，第一是为了总结我之前学过的知识和经验，比如Vue全家桶，wepback构建Vue环境等。其次是在我没有实践过的领域进行探索的同时记录下来拿，以后有需要的时候再看回这篇文章。</p>\n<h2 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h2><p>我把这篇文章的内容拆成几个版块，作为一个连载的文章。首先列一下主要章节内容：</p>\n<ul>\n<li>搭建一个运行Vue的webpack环境</li>\n<li>加入Vue全家桶</li>\n<li>编写项目工程代码</li>\n<li>总结Vue测试</li>\n<li>关于项目的持续集成</li>\n<li>项目总结</li>\n</ul>\n<p>因为在编写项目的时候总会附上对应的测试代码，但这样有时候需要看关于Vue测试的内容时会过于零散，所以在写完项目之后专门给了一个小节来写关于Vue的测试内容。当然如果你是从头往下看的话可以跳过这一小节。最后项目 弄好了按照国际惯例总是要总结一下经验的。</p>\n<h2 id=\"搭建运行Vue的webpack环境\"><a href=\"#搭建运行Vue的webpack环境\" class=\"headerlink\" title=\"搭建运行Vue的webpack环境\"></a>搭建运行Vue的webpack环境</h2><h3 id=\"工程目录\"><a href=\"#工程目录\" class=\"headerlink\" title=\"工程目录\"></a>工程目录</h3><pre><code>|____.gitignore\n|____index.html\n|____LICENSE\n|____package-lock.json\n|____package.json\n|____README.md\n|____src\n| |____App.vue\n| |____assets\n| |____components\n| |____main.js\n| |____view\n|____static\n|____test\n|____webpack.config.js\n</code></pre>\n<h3 id=\"webpack配置\"><a href=\"#webpack配置\" class=\"headerlink\" title=\"webpack配置\"></a>webpack配置</h3><p>这是我摸索了几个钟弄出来的配置（不得不说webpack的配置是真的麻烦），以前都是懒所以直接使用vue-cli初始化出来的项目，webpack配置什么的都已经帮我配好了，这次自己动刀搭了一下才发现这么费劲，期间不断地报错，再加上由于用了4.0版本，也出现了一些坑，这里一并也记录一下，以后再遇到的时候好回头翻翻。</p>\n<p> 首先是最基础的webpack框架，不清楚的可以去到<a href=\"https://www.webpackjs.com/configuration/#%E9%80%89%E9%A1%B9\">webpack官网</a>上找（现在都已经有翻译很好的中文网啦，哪像以前那么苦还要去啃英文 (T^T) ）。当然我们也只会用到其中的几个属性。</p>\n<pre><code>const path = require(&#39;path&#39;)\nmodule.exports = &#123;\n  entry: &#39;&#39;,\n  output: &#123;&#125;,\n  module: &#123;\n      rules: []\n  &#125;,\n  plugins: []\n&#125;\n</code></pre>\n<p>OK,这就完成了webpack最基本的框架，接下来我们要分别搭建不同方式启动webpack的方案。（其实这两者在实现原理上本没有什么区别，而对于我们使用者来说区别最大的大概就是工程目录的划分和关于wepback-dev-server的配置）</p>\n<h3 id=\"基于webpack-dev-server插件来启动webpack\"><a href=\"#基于webpack-dev-server插件来启动webpack\" class=\"headerlink\" title=\"基于webpack-dev-server插件来启动webpack\"></a>基于webpack-dev-server插件来启动webpack</h3><p>基于<code>webpack-dev-server</code>这种方式启动webpack，我们首先把之前的webpack的配置文件命名为<code>webpack.config.js</code>并放在项目的根目录下。然后在<code>package.json</code>里的<code>script</code>对象添加一个<code>dev</code>属性，并在后面添加脚本<code>webpack-dev-server --inline --hot</code>再保存。例如：</p>\n<pre><code>// package.json\n\n&#123;\n  ...\n  &quot;scripts&quot;: &#123;\n    &quot;dev&quot;: &quot;webpack-dev-server --inline --hot&quot;,\n    &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;\n  &#125;,\n  ...\n&#125;\n</code></pre>\n<p>然后我们在webpack.config.js文件里添加devServer配置：</p>\n<pre><code>// webpack.config.js\n\nconst path = require(&#39;path&#39;)\n\nmodule.exports = &#123;\n  entry: &#39;./src/main.js&#39;,\n  output: &#123;\n    path: path.resolve(__dirname, &#39;./dist&#39;),\n    publicPath: &#39;/dist/&#39;,\n    filename: &#39;build.js&#39;\n  &#125;,\n  module: &#123;\n    rules: []\n  &#125;,\n  plugins: [],\n  devServer: &#123;\n    // contentBase: path.join(__dirname, &quot;dist&quot;),\n    // 确保 publicPath 总是以斜杠(/)开头和结尾。\n    // 默认会取output.path的值，设置之后会覆盖使用devServer.publicPath的值\n    // publicPath: &quot;/&quot;,\n    historyApiFallback: true,\n    compress: true,\n    proxy: &#123; // proxy URLs to backend development server\n      // &#39;/api&#39;: &#39;http://localhost:3000&#39;,\n      // &#39;/api&#39;: &#123;\n      //   target: &#39;http://localhost:3000&#39;,\n      //   pathRewrite: &#123;&#39;^/api&#39; : &#39;&#39;&#125;\n      // &#125;\n    &#125;,\n    hot: true,\n    inline: true\n  &#125;,\n  devtool: &#39;#eval-source-map&#39;\n&#125;\n</code></pre>\n<p>这样就可以把webpack-dev-server启动起来啦~~</p>\n<h3 id=\"基于node-express-方式来启动webpack\"><a href=\"#基于node-express-方式来启动webpack\" class=\"headerlink\" title=\"基于node + express 方式来启动webpack\"></a>基于node + express 方式来启动webpack</h3><h3 id=\"基本可以运行Vue项目的webpack配置\"><a href=\"#基本可以运行Vue项目的webpack配置\" class=\"headerlink\" title=\"基本可以运行Vue项目的webpack配置\"></a>基本可以运行Vue项目的webpack配置</h3><p>完成了上面的步骤之后，接下来就是配置vue相关的东西了，先回想在使用vue开发的时候，我们会新建一个vue后缀的文件，所以我们就需要一个loader来解析和读取.vue文件的内容。先安装：</p>\n<pre><code>npm install --save-dev vue-loader vue-template-compiler\n</code></pre>\n<p>然后我们再在wepback配置中的module.rules中使用：</p>\n<pre><code>// webpack.config.js/webpack.base.conf.js\n\nmodule.exports = &#123;\n  ...\n  module: &#123;\n    rules: [\n      &#123;\n        test: /\\.vue$/,\n        loader: &#39;vue-loader&#39;,\n        options: &#123;&#125;\n      &#125;\n    ]\n  &#125;,\n  ...\n</code></pre>\n<p>至于这里为什么要安装<code>vue-template-compiler</code>，是因为单纯使用<code>vue-loader</code>启动的时候会报错，提示在没有<code>vue-template-compiler</code>的情况下使用<code>vue-loader</code>，我在网上查了一下也有人写了<a href=\"https://blog.csdn.net/cominglately/article/details/80555210\">blog</a>说明了这一情况，意思大概是升级到webpack 4.0之后会出现的问题。为了解决这个问题我们要在webpack配置上使用一下。</p>\n<pre><code>// webpack.config.js/webpack.base.conf.js\n\nconst path = require(&#39;path&#39;)\nconst VueLoaderPlugin = require(&#39;vue-loader/lib/plugin&#39;);\n\nmodule.exports = &#123;\n  ...\n  module: &#123;\n    rules: [\n      &#123;\n        test: /\\.vue$/,\n        loader: &#39;vue-loader&#39;,\n        options: &#123;&#125;\n      &#125;\n    ]\n  &#125;,\n  plugins: [\n    new VueLoaderPlugin()\n  ],\n  ...\n</code></pre>\n<p>现在就可以读vue文件了，接下来就是对vue文件里的css、非标准的js、图片分别配置，也让webpack可以有能力解析。</p>\n<p>解析css（css-loader是解析css的，style-loader是把css以<style></style>内嵌的方式注入到html中）:</p>\n<pre><code>npm install --save-dev style-loader css-loader\n</code></pre>\n<p>解析非标准的js（<a href=\"https://www.babeljs.cn/docs/setup/#installation\">使用babel</a>）:</p>\n<pre><code>npm install --save-dev babel-loader babel-preset-env\n</code></pre>\n<p>解析img:</p>\n<pre><code>npm install --save-dev file-loader\n</code></pre>\n<p>然后再分别写到rules里面，就完成了。整个配置如下：</p>\n<pre><code>// webpack.config.js/webpack.base.conf.js\n\nconst path = require(&#39;path&#39;)\nconst VueLoaderPlugin = require(&#39;vue-loader/lib/plugin&#39;);\n\nmodule.exports = &#123;\n  entry: &#39;./src/main.js&#39;,\n  output: &#123;\n    path: path.resolve(__dirname, &#39;./dist&#39;),\n    publicPath: &#39;/dist/&#39;,\n    filename: &#39;build.js&#39;\n  &#125;,\n  module: &#123;\n    rules: [&#123;\n        test: /\\.css$/,\n        use: [\n          &#39;vue-style-loader&#39;,\n          &#39;css-loader&#39;\n        ]\n      &#125;,\n      &#123;\n        test: /\\.js$/,\n        loader: &#39;babel-loader&#39;,\n        exclude: /node_modules/\n      &#125;,\n      &#123;\n        test: /\\.vue$/,\n        loader: &#39;vue-loader&#39;,\n        options: &#123;&#125;\n      &#125;,\n      &#123;\n        test: /\\.(png|jpg|gif|svg)$/,\n        loader: &#39;file-loader&#39;,\n        options: &#123;\n          name: &#39;[name].[ext]?[hash]&#39;\n        &#125;\n      &#125;\n    ]\n  &#125;,\n  plugins: [\n    new VueLoaderPlugin()\n  ],\n  devServer: &#123;\n    // contentBase: path.join(__dirname, &quot;dist&quot;),\n    // 确保 publicPath 总是以斜杠(/)开头和结尾。\n    // 默认会取output.path的值，设置之后会覆盖使用devServer.publicPath的值\n    // publicPath: &quot;/&quot;,\n    historyApiFallback: true,\n    compress: true,\n    proxy: &#123; // proxy URLs to backend development server\n      // &#39;/api&#39;: &#39;http://localhost:3000&#39;,\n      // &#39;/api&#39;: &#123;\n      //   target: &#39;http://localhost:3000&#39;,\n      //   pathRewrite: &#123;&#39;^/api&#39; : &#39;&#39;&#125;\n      // &#125;\n    &#125;,\n    hot: true,\n    inline: true\n  &#125;,\n  devtool: &#39;#eval-source-map&#39;\n&#125;\n</code></pre>\n<h3 id=\"项目优化\"><a href=\"#项目优化\" class=\"headerlink\" title=\"项目优化\"></a>项目优化</h3><p>按照刚刚的步骤进行操作的话，会发现当项目运行起来的时候webpack会报如下错误，现在慢慢地按照提示来对项目进行优化。</p>\n<p><a href=\"https://simimg.com/i/qqEhK\"><img src=\"https://s1.ax2x.com/2018/07/19/qqEhK.png\" alt=\"qqEhK.png\"></a></p>\n<h4 id=\"WARNING-in-configuration\"><a href=\"#WARNING-in-configuration\" class=\"headerlink\" title=\"WARNING in configuration\"></a>WARNING in configuration</h4><pre><code>The &#39;mode&#39; option has not been set, webpack will fallback to &#39;production&#39; for this value. Set &#39;mode&#39; option to &#39;development&#39; or &#39;production&#39; to enable defaults for each environment.\nYou can also set it to &#39;none&#39; to disable any default behavior. Learn more: https://webpack.js.org/concepts/mode/\n</code></pre>\n<p>翻译成中文的意思大概是：<code>mode</code>这个选项没有被设置，webpack将会默认设置为<code>production</code>。你可以把<code>mode</code>选项设置为<code>development</code>或者<code>production</code>，以让webpack以指定的环境启动。你也可以设置为<code>none</code>以禁用任何的默认行为。<a href=\"https://webpack.js.org/concepts/mode/\">了解更多：https://webpack.js.org/concepts/mode/</a>。</p>\n<p>这个问题主要是告诉我们要让webpack知道现是要按什么环境去构建应用，通常我们会通过一个配置文件来记录所有会用到的环境，然后在调用的时候通过传入参数的形式来指定使用哪一个环境。</p>\n<p>我们新建一个目录<code>config</code>，在目录里面再分别建立不同环境的配置，如：</p>\n<pre><code>├── config\n│   ├── dev.js\n│   ├── index.js\n│   ├── prod.js\n│   └── test.js\n</code></pre>\n<p>我们分别区别了开发环境、生产环境、和测试环境，然后再通过一个index.js来判断当前使用哪一个环境：</p>\n<pre><code>// index.js\nconst prod = require(&#39;./prod&#39;)\nconst dev = require(&#39;./dev&#39;)\nconst test = require(&#39;./test&#39;)\n\nlet env = prod;\n\nswitch (process.env.NODE_ENV) &#123;\n  case &#39;development&#39;:\n    env = dev;\n    break;\n    // case &#39;test&#39;:\n    //   env = test;\n    //   break;\n  default:\n    env = prod;\n&#125;\n\nmodule.exports = env\n</code></pre>\n<p>这里的<code>process.env</code>是node.js的一个环境变量对象，挂载到这个对象上的属性可以在node的全局运行环境中访问到，而<code>NODE_ENV</code>是node社区约定作为当前运行环境的属性（当然你也可以用其它属性代替）。</p>\n<p>为了我们在启动的时候可以为node指定当前运行环境，我们新加入一个依赖包叫<a href=\"https://www.npmjs.com/package/cross-env\">cross-env</a>，然后修改<code>package.json</code>文件里的运行脚本命令，添加<code>cross-env NODE_ENV=[prototype]</code>在命令前面即可，如：</p>\n<pre><code>// package.json\n\n...\n&quot;scripts&quot;: &#123;\n  &quot;dev&quot;: &quot;cross-env NODE_ENV=development webpack-dev-server --inline --hot&quot;,\n  &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;\n&#125;,\n...\n</code></pre>\n<h4 id=\"WARNING-in-asset-size-limit\"><a href=\"#WARNING-in-asset-size-limit\" class=\"headerlink\" title=\"WARNING in asset size limit\"></a>WARNING in asset size limit</h4><pre><code>The following asset(s) exceed the recommended size limit (244 KiB).\nThis can impact web performance.\nAssets:\n  build.js (2.13 MiB)\n</code></pre>\n<h4 id=\"WARNING-in-entrypoint-size-limit\"><a href=\"#WARNING-in-entrypoint-size-limit\" class=\"headerlink\" title=\"WARNING in entrypoint size limit\"></a>WARNING in entrypoint size limit</h4><pre><code>The following entrypoint(s) combined asset size exceeds the recommended limit (244 KiB). This can impact web performance.\nEntrypoints:\n  main (2.13 MiB)\n      build.js\n      0.9256098444c5c2f2e51c.hot-update.js\n</code></pre>\n<h4 id=\"WARNING-in-webpack-performance-recommendations\"><a href=\"#WARNING-in-webpack-performance-recommendations\" class=\"headerlink\" title=\"WARNING in webpack performance recommendations\"></a>WARNING in webpack performance recommendations</h4><pre><code>You can limit the size of your bundles by using import() or require.ensure to lazy load some parts of your application.\nFor more info visit https://webpack.js.org/guides/code-splitting/\n</code></pre>\n"},{"title":"Database Relationship","date":"2023-04-10T09:38:51.000Z","_content":"\n> 在 Youtube 上刷到了一个关于数据库设计的视频，看了一下感觉还不错，这几天应该都会看一点然后每天做一下记录。视频地址：[Database Design Course](https://www.youtube.com/watch?v=ztHopE5Wnpc&list=PLo47zzoJD98Jn5Z3e3003jzqTaATKuDnI)\n\nDatabase Design Course：\n\nhttps://www.youtube.com/watch?v=ztHopE5Wnpc&list=PLo47zzoJD98Jn5Z3e3003jzqTaATKuDnI\n\n## 为什么要使用关系？\n\n使用关系关联的目的是为了减少**数据冗余**，比如我们要记录用户和用户卡片相关的信息，如果不使用关联关系，则数据存储如下：\n\n| user_id | user_name | age       | sex       | card_id   | card_name |\n|---------|-----------|-----------|-----------|-----------|-----------|\n| 001     | John      | 24        | man       | 1         | GoldCard  |\n| 002     | Mary      | 22        | female    | null      | null      |\n\n不难发现，因为不是每个人都会拥有卡片，当遇到那些没有卡片的人时，卡片信息的相关字段便会**记录为没有意义的null，空间被白白浪费掉**。这时如果使用关联关系则会如下：\n\n| user_id | user_name | age       | sex       |\n|---------|-----------|-----------|-----------|\n| 001     | John      | 24        | man       |\n| 002     | Mary      | 22        | female    |\n\n| card_id   | card_name | belong_user_id |\n|-----------|-----------|---------|\n| 1         | GoldCard  | 001       |\n\n用户表通过 foreign key(belong_card_id)与卡片表的primary key(card_id)相关联，从而达到减少数据冗余的情况。\n\n当然除了一对一的关系，也可能存在一个人有多张卡的情况，也有可能一张卡被多个人共用的情况，这就是一对多和多对一的关联关系了。\n\n**在有关联关系的两个表之间，必定有一个是父表（parent table），另一个为子表（child table），父表不知道有哪些子表关联着它，而子表可以通过 foregin key 从父表中查找出对于关联的信息。**\n\n一般情况下，关系型数据可以通过使用 Primary Key 和 Foreign Key 来很好地处理 One to One（一对一）, One to Many（一对多）, Many to One（多对一）的关系，但是对于 Many to Many（多对多）的关系是需要一些技巧来处理的。\n\n对于多对多的关联关系，我们通常使用 **中间表（Intermediary Table）** 的技巧来优化我们的表数据。\n\n我们假设一个人可以有多张卡，一张卡也可以被多个人共同使用，那么表结构如下：  \n\n用户表：\n| user_id | user_name | age       | sex       |\n|---------|-----------|-----------|-----------|\n| 001     | John      | 24        | man       |\n| 002     | Mary      | 22        | female    |\n\n卡片表：\n| card_id   | card_name |\n|-----------|-----------|\n| 1         | GoldCard  |\n\n用户、卡片关系表：\n| user_id   | card_id |\n|-----------|---------|\n| 001       | 1       |\n\n通过用户、卡片关系表可以得知，001用户拥有编号为1的卡片，如果001还拥有其他卡片，都可以通过该表查出对应的卡片信息。","source":"_posts/Database-Relationship.md","raw":"---\ntitle: Database Relationship\ntags:\n  - 个人总结\ncategories:\n  - Database\ndate: 2023-04-10 17:38:51\n---\n\n> 在 Youtube 上刷到了一个关于数据库设计的视频，看了一下感觉还不错，这几天应该都会看一点然后每天做一下记录。视频地址：[Database Design Course](https://www.youtube.com/watch?v=ztHopE5Wnpc&list=PLo47zzoJD98Jn5Z3e3003jzqTaATKuDnI)\n\nDatabase Design Course：\n\nhttps://www.youtube.com/watch?v=ztHopE5Wnpc&list=PLo47zzoJD98Jn5Z3e3003jzqTaATKuDnI\n\n## 为什么要使用关系？\n\n使用关系关联的目的是为了减少**数据冗余**，比如我们要记录用户和用户卡片相关的信息，如果不使用关联关系，则数据存储如下：\n\n| user_id | user_name | age       | sex       | card_id   | card_name |\n|---------|-----------|-----------|-----------|-----------|-----------|\n| 001     | John      | 24        | man       | 1         | GoldCard  |\n| 002     | Mary      | 22        | female    | null      | null      |\n\n不难发现，因为不是每个人都会拥有卡片，当遇到那些没有卡片的人时，卡片信息的相关字段便会**记录为没有意义的null，空间被白白浪费掉**。这时如果使用关联关系则会如下：\n\n| user_id | user_name | age       | sex       |\n|---------|-----------|-----------|-----------|\n| 001     | John      | 24        | man       |\n| 002     | Mary      | 22        | female    |\n\n| card_id   | card_name | belong_user_id |\n|-----------|-----------|---------|\n| 1         | GoldCard  | 001       |\n\n用户表通过 foreign key(belong_card_id)与卡片表的primary key(card_id)相关联，从而达到减少数据冗余的情况。\n\n当然除了一对一的关系，也可能存在一个人有多张卡的情况，也有可能一张卡被多个人共用的情况，这就是一对多和多对一的关联关系了。\n\n**在有关联关系的两个表之间，必定有一个是父表（parent table），另一个为子表（child table），父表不知道有哪些子表关联着它，而子表可以通过 foregin key 从父表中查找出对于关联的信息。**\n\n一般情况下，关系型数据可以通过使用 Primary Key 和 Foreign Key 来很好地处理 One to One（一对一）, One to Many（一对多）, Many to One（多对一）的关系，但是对于 Many to Many（多对多）的关系是需要一些技巧来处理的。\n\n对于多对多的关联关系，我们通常使用 **中间表（Intermediary Table）** 的技巧来优化我们的表数据。\n\n我们假设一个人可以有多张卡，一张卡也可以被多个人共同使用，那么表结构如下：  \n\n用户表：\n| user_id | user_name | age       | sex       |\n|---------|-----------|-----------|-----------|\n| 001     | John      | 24        | man       |\n| 002     | Mary      | 22        | female    |\n\n卡片表：\n| card_id   | card_name |\n|-----------|-----------|\n| 1         | GoldCard  |\n\n用户、卡片关系表：\n| user_id   | card_id |\n|-----------|---------|\n| 001       | 1       |\n\n通过用户、卡片关系表可以得知，001用户拥有编号为1的卡片，如果001还拥有其他卡片，都可以通过该表查出对应的卡片信息。","slug":"Database-Relationship","published":1,"updated":"2023-04-11T03:30:27.109Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgbppeb60009bvch05742uss","content":"<blockquote>\n<p>在 Youtube 上刷到了一个关于数据库设计的视频，看了一下感觉还不错，这几天应该都会看一点然后每天做一下记录。视频地址：<a href=\"https://www.youtube.com/watch?v=ztHopE5Wnpc&list=PLo47zzoJD98Jn5Z3e3003jzqTaATKuDnI\">Database Design Course</a></p>\n</blockquote>\n<p>Database Design Course：</p>\n<p><a href=\"https://www.youtube.com/watch?v=ztHopE5Wnpc&amp;list=PLo47zzoJD98Jn5Z3e3003jzqTaATKuDnI\">https://www.youtube.com/watch?v=ztHopE5Wnpc&amp;list=PLo47zzoJD98Jn5Z3e3003jzqTaATKuDnI</a></p>\n<h2><a href=\"#wei-shi-me-yao-shi-yong-guan-xi\" class=\"header-anchor\"></a><span id=\"wei-shi-me-yao-shi-yong-guan-xi\">为什么要使用关系？</span></h2><p>使用关系关联的目的是为了减少<strong>数据冗余</strong>，比如我们要记录用户和用户卡片相关的信息，如果不使用关联关系，则数据存储如下：</p>\n<table>\n<thead>\n<tr>\n<th>user_id</th>\n<th>user_name</th>\n<th>age</th>\n<th>sex</th>\n<th>card_id</th>\n<th>card_name</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>001</td>\n<td>John</td>\n<td>24</td>\n<td>man</td>\n<td>1</td>\n<td>GoldCard</td>\n</tr>\n<tr>\n<td>002</td>\n<td>Mary</td>\n<td>22</td>\n<td>female</td>\n<td>null</td>\n<td>null</td>\n</tr>\n</tbody></table>\n<p>不难发现，因为不是每个人都会拥有卡片，当遇到那些没有卡片的人时，卡片信息的相关字段便会<strong>记录为没有意义的null，空间被白白浪费掉</strong>。这时如果使用关联关系则会如下：</p>\n<table>\n<thead>\n<tr>\n<th>user_id</th>\n<th>user_name</th>\n<th>age</th>\n<th>sex</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>001</td>\n<td>John</td>\n<td>24</td>\n<td>man</td>\n</tr>\n<tr>\n<td>002</td>\n<td>Mary</td>\n<td>22</td>\n<td>female</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>card_id</th>\n<th>card_name</th>\n<th>belong_user_id</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>GoldCard</td>\n<td>001</td>\n</tr>\n</tbody></table>\n<p>用户表通过 foreign key(belong_card_id)与卡片表的primary key(card_id)相关联，从而达到减少数据冗余的情况。</p>\n<p>当然除了一对一的关系，也可能存在一个人有多张卡的情况，也有可能一张卡被多个人共用的情况，这就是一对多和多对一的关联关系了。</p>\n<p><strong>在有关联关系的两个表之间，必定有一个是父表（parent table），另一个为子表（child table），父表不知道有哪些子表关联着它，而子表可以通过 foregin key 从父表中查找出对于关联的信息。</strong></p>\n<p>一般情况下，关系型数据可以通过使用 Primary Key 和 Foreign Key 来很好地处理 One to One（一对一）, One to Many（一对多）, Many to One（多对一）的关系，但是对于 Many to Many（多对多）的关系是需要一些技巧来处理的。</p>\n<p>对于多对多的关联关系，我们通常使用 <strong>中间表（Intermediary Table）</strong> 的技巧来优化我们的表数据。</p>\n<p>我们假设一个人可以有多张卡，一张卡也可以被多个人共同使用，那么表结构如下：  </p>\n<p>用户表：</p>\n<table>\n<thead>\n<tr>\n<th>user_id</th>\n<th>user_name</th>\n<th>age</th>\n<th>sex</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>001</td>\n<td>John</td>\n<td>24</td>\n<td>man</td>\n</tr>\n<tr>\n<td>002</td>\n<td>Mary</td>\n<td>22</td>\n<td>female</td>\n</tr>\n</tbody></table>\n<p>卡片表：</p>\n<table>\n<thead>\n<tr>\n<th>card_id</th>\n<th>card_name</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>GoldCard</td>\n</tr>\n</tbody></table>\n<p>用户、卡片关系表：</p>\n<table>\n<thead>\n<tr>\n<th>user_id</th>\n<th>card_id</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>001</td>\n<td>1</td>\n</tr>\n</tbody></table>\n<p>通过用户、卡片关系表可以得知，001用户拥有编号为1的卡片，如果001还拥有其他卡片，都可以通过该表查出对应的卡片信息。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>在 Youtube 上刷到了一个关于数据库设计的视频，看了一下感觉还不错，这几天应该都会看一点然后每天做一下记录。视频地址：<a href=\"https://www.youtube.com/watch?v=ztHopE5Wnpc&list=PLo47zzoJD98Jn5Z3e3003jzqTaATKuDnI\">Database Design Course</a></p>\n</blockquote>\n<p>Database Design Course：</p>\n<p><a href=\"https://www.youtube.com/watch?v=ztHopE5Wnpc&amp;list=PLo47zzoJD98Jn5Z3e3003jzqTaATKuDnI\">https://www.youtube.com/watch?v=ztHopE5Wnpc&amp;list=PLo47zzoJD98Jn5Z3e3003jzqTaATKuDnI</a></p>\n<h2 id=\"为什么要使用关系？\"><a href=\"#为什么要使用关系？\" class=\"headerlink\" title=\"为什么要使用关系？\"></a>为什么要使用关系？</h2><p>使用关系关联的目的是为了减少<strong>数据冗余</strong>，比如我们要记录用户和用户卡片相关的信息，如果不使用关联关系，则数据存储如下：</p>\n<table>\n<thead>\n<tr>\n<th>user_id</th>\n<th>user_name</th>\n<th>age</th>\n<th>sex</th>\n<th>card_id</th>\n<th>card_name</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>001</td>\n<td>John</td>\n<td>24</td>\n<td>man</td>\n<td>1</td>\n<td>GoldCard</td>\n</tr>\n<tr>\n<td>002</td>\n<td>Mary</td>\n<td>22</td>\n<td>female</td>\n<td>null</td>\n<td>null</td>\n</tr>\n</tbody></table>\n<p>不难发现，因为不是每个人都会拥有卡片，当遇到那些没有卡片的人时，卡片信息的相关字段便会<strong>记录为没有意义的null，空间被白白浪费掉</strong>。这时如果使用关联关系则会如下：</p>\n<table>\n<thead>\n<tr>\n<th>user_id</th>\n<th>user_name</th>\n<th>age</th>\n<th>sex</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>001</td>\n<td>John</td>\n<td>24</td>\n<td>man</td>\n</tr>\n<tr>\n<td>002</td>\n<td>Mary</td>\n<td>22</td>\n<td>female</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>card_id</th>\n<th>card_name</th>\n<th>belong_user_id</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>GoldCard</td>\n<td>001</td>\n</tr>\n</tbody></table>\n<p>用户表通过 foreign key(belong_card_id)与卡片表的primary key(card_id)相关联，从而达到减少数据冗余的情况。</p>\n<p>当然除了一对一的关系，也可能存在一个人有多张卡的情况，也有可能一张卡被多个人共用的情况，这就是一对多和多对一的关联关系了。</p>\n<p><strong>在有关联关系的两个表之间，必定有一个是父表（parent table），另一个为子表（child table），父表不知道有哪些子表关联着它，而子表可以通过 foregin key 从父表中查找出对于关联的信息。</strong></p>\n<p>一般情况下，关系型数据可以通过使用 Primary Key 和 Foreign Key 来很好地处理 One to One（一对一）, One to Many（一对多）, Many to One（多对一）的关系，但是对于 Many to Many（多对多）的关系是需要一些技巧来处理的。</p>\n<p>对于多对多的关联关系，我们通常使用 <strong>中间表（Intermediary Table）</strong> 的技巧来优化我们的表数据。</p>\n<p>我们假设一个人可以有多张卡，一张卡也可以被多个人共同使用，那么表结构如下：  </p>\n<p>用户表：</p>\n<table>\n<thead>\n<tr>\n<th>user_id</th>\n<th>user_name</th>\n<th>age</th>\n<th>sex</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>001</td>\n<td>John</td>\n<td>24</td>\n<td>man</td>\n</tr>\n<tr>\n<td>002</td>\n<td>Mary</td>\n<td>22</td>\n<td>female</td>\n</tr>\n</tbody></table>\n<p>卡片表：</p>\n<table>\n<thead>\n<tr>\n<th>card_id</th>\n<th>card_name</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>GoldCard</td>\n</tr>\n</tbody></table>\n<p>用户、卡片关系表：</p>\n<table>\n<thead>\n<tr>\n<th>user_id</th>\n<th>card_id</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>001</td>\n<td>1</td>\n</tr>\n</tbody></table>\n<p>通过用户、卡片关系表可以得知，001用户拥有编号为1的卡片，如果001还拥有其他卡片，都可以通过该表查出对应的卡片信息。</p>\n"},{"title":"Database-Key-and-Index","date":"2023-04-10T16:53:04.000Z","_content":"\n> 在 Youtube 上刷到了一个关于数据库设计的视频，看了一下感觉还不错，这几天应该都会看一点然后每天做一下记录。视频地址：[Database Design Course](https://www.youtube.com/watch?v=ztHopE5Wnpc&list=PLo47zzoJD98Jn5Z3e3003jzqTaATKuDnI)\n\n## 什么是键（Key）\n\n> KEY is something on the logical level, describes your table and database design (i.e. enforces referential integrity …)\n\n键（KEY）是数据库中常见的概念，通常用来描述数据库中表字段的性质和它们之间的关系，是逻辑层面的概念。比如有以下用户表：\n| user_id | user_name | age       | sex       | email   |\n|---------|-----------|-----------|-----------|-----------|\n| 001     | John      | 24        | man       | abc@gmail.com  |\n| 002     | Mary      | 22        | female    | bcd@gmail.com | \n\n如果想要从表中识别出每一条数据，那么必定会存在一个字段，它的每一行的值都不一样，就比如表中的 `user_id` 字段，而这个字段常常被称之为用户表的 主键（PRIMARY_KEY）。\n\n假如还有一个卡片表：\n| card_id   | card_name | belong_user_id |\n|-----------|-----------|---------|\n| 1         | GoldCard  | 001       |\n\n它的某个字段（belong_user_id）关联着其他表的主键（user_id），那么这个字段常常称之为表的 外键（FOREIGN_KEY）。\n\n在数据库设计与实践中，往往会遵循 键（Key）的三个特征：\n\n1. 唯一性（Unique）。\n2. 不可修改性（Nerver Changing）。\n3. 不能为空（Never Null）。\n\n\t**唯一性（Unique）**： 因为 **键（KEY) 的作用是帮助我们可以在数据库中找出对应的数据** ，所以如果想要从表中的海量数据找到对应的一条数据，那么 键（KEY)  必定是表中不能重复的字段，否则使用这个 键（KEY)  就不能找出对应的一条数据。\n\n\t**不可修改性（Nerver Changing）**：我们除了使用 键（KEY)  来查找表中对应的数据，也常常会使用 键（KEY) 来关联不同表中的数据。比如在上面的用户表外，还有一个 课程表 关联了这个学生表，还有 教师表 关联了 学生表等等，如果我们修改了学生表的 键（KEY) ，那么其他以这个键（KEY)  关联学生表的关联关系都要做改变，这些改变往往会容易引起程序错误，在迫不得已的时候，我们应该遵循 键（KEY)  的不可修改性。\n\n\t**不能为空（Never Null）**：这个很容易理解，如果 键（KEY)  为空，那么我们便从表中查找不出任何数据，也关联不上任务数据。 \n\n## 什么是索引（Index）\n\n>INDEX is something on the physical level, helps improve access time for table operations. Behind every PK there is (usually) unique index created (automatically).\n\n索引（INDEX) 也是数据库中另一种常见的概念，通常用来优化数据库的查询工作，是数据库物理层面上的概念，索引（INDEX) 通常记录在数据库的默认表中，由数据库程序自己维护。而刚刚我们提到的 键（KEY）其实是 索引（INDEX）的一种实现。\n\n我们可以使用表中的一个字段作为索引（INDEX) ，也可以使用多个字段的组合成为索引（INDEX) ，例如在下方的用户表中， 可以使用 `user_id（主键）` 作为索引（INDEX) ，也可以使用  `user_name` 和 `age`  的组合来作为表的 索引（INDEX) 。\n\n| user_id | user_name | age       | sex       | email   |\n|---------|-----------|-----------|-----------|-----------|\n| 001     | John      | 24        | man       | abc@gmail.com  |\n| 002     | Mary      | 22        | female    | bcd@gmail.com | \n\n理论上我们可以随意挑选表中的字段作为 索引（INDEX），但是在实践中需要选择那些可以识别出每行数据的字段或字段组合作为 索引（INDEX) ，否则便失去了 索引（INDEX) 的意义。\n\n要想从数据库中的表查找出其中一行数据，常用 SELECT * FROM `table_name` WHERE `column` = `condition` 。在 SELECT 语句中的 WHERE 条件就用到 **索引（INDEX）**。而使用 SELECT 语句查找数据最基本的方法就是从表的第一行找到表的最后一行。如果事先明确知道要查找用户的 `user_id（主键）` ，那么是可以通过查找一遍所有的表数据来找到想要的数据。但是如果假设我们只知道用户的叫 `Jonh` 且他的邮箱是 `adc@gmail.com`，那么就需要最多查找 m^2 次：第一遍找出符合用户名的人，第二遍找出符合邮箱的人，最后把两遍的结果组合起来。\n\n如果我们给用户表设置了以用户用户名和邮箱这两个字段组合而成的 索引（INDEX)，那么在数据库内部就已经存放着对应索引所代表的记录，当要查询时只需要查找一遍便可得到想要的结果。\n\n因此，在数据库的表中选用哪些字段作为 键（KEY），往往会影响整个表的查询效率。\n","source":"_posts/Database-Key-and-Index.md","raw":"---\ntitle: Database-Key-and-Index\ntags:\n  - 个人总结\ncategories:\n  - Database\ndate: 2023-04-11 00:53:04\n---\n\n> 在 Youtube 上刷到了一个关于数据库设计的视频，看了一下感觉还不错，这几天应该都会看一点然后每天做一下记录。视频地址：[Database Design Course](https://www.youtube.com/watch?v=ztHopE5Wnpc&list=PLo47zzoJD98Jn5Z3e3003jzqTaATKuDnI)\n\n## 什么是键（Key）\n\n> KEY is something on the logical level, describes your table and database design (i.e. enforces referential integrity …)\n\n键（KEY）是数据库中常见的概念，通常用来描述数据库中表字段的性质和它们之间的关系，是逻辑层面的概念。比如有以下用户表：\n| user_id | user_name | age       | sex       | email   |\n|---------|-----------|-----------|-----------|-----------|\n| 001     | John      | 24        | man       | abc@gmail.com  |\n| 002     | Mary      | 22        | female    | bcd@gmail.com | \n\n如果想要从表中识别出每一条数据，那么必定会存在一个字段，它的每一行的值都不一样，就比如表中的 `user_id` 字段，而这个字段常常被称之为用户表的 主键（PRIMARY_KEY）。\n\n假如还有一个卡片表：\n| card_id   | card_name | belong_user_id |\n|-----------|-----------|---------|\n| 1         | GoldCard  | 001       |\n\n它的某个字段（belong_user_id）关联着其他表的主键（user_id），那么这个字段常常称之为表的 外键（FOREIGN_KEY）。\n\n在数据库设计与实践中，往往会遵循 键（Key）的三个特征：\n\n1. 唯一性（Unique）。\n2. 不可修改性（Nerver Changing）。\n3. 不能为空（Never Null）。\n\n\t**唯一性（Unique）**： 因为 **键（KEY) 的作用是帮助我们可以在数据库中找出对应的数据** ，所以如果想要从表中的海量数据找到对应的一条数据，那么 键（KEY)  必定是表中不能重复的字段，否则使用这个 键（KEY)  就不能找出对应的一条数据。\n\n\t**不可修改性（Nerver Changing）**：我们除了使用 键（KEY)  来查找表中对应的数据，也常常会使用 键（KEY) 来关联不同表中的数据。比如在上面的用户表外，还有一个 课程表 关联了这个学生表，还有 教师表 关联了 学生表等等，如果我们修改了学生表的 键（KEY) ，那么其他以这个键（KEY)  关联学生表的关联关系都要做改变，这些改变往往会容易引起程序错误，在迫不得已的时候，我们应该遵循 键（KEY)  的不可修改性。\n\n\t**不能为空（Never Null）**：这个很容易理解，如果 键（KEY)  为空，那么我们便从表中查找不出任何数据，也关联不上任务数据。 \n\n## 什么是索引（Index）\n\n>INDEX is something on the physical level, helps improve access time for table operations. Behind every PK there is (usually) unique index created (automatically).\n\n索引（INDEX) 也是数据库中另一种常见的概念，通常用来优化数据库的查询工作，是数据库物理层面上的概念，索引（INDEX) 通常记录在数据库的默认表中，由数据库程序自己维护。而刚刚我们提到的 键（KEY）其实是 索引（INDEX）的一种实现。\n\n我们可以使用表中的一个字段作为索引（INDEX) ，也可以使用多个字段的组合成为索引（INDEX) ，例如在下方的用户表中， 可以使用 `user_id（主键）` 作为索引（INDEX) ，也可以使用  `user_name` 和 `age`  的组合来作为表的 索引（INDEX) 。\n\n| user_id | user_name | age       | sex       | email   |\n|---------|-----------|-----------|-----------|-----------|\n| 001     | John      | 24        | man       | abc@gmail.com  |\n| 002     | Mary      | 22        | female    | bcd@gmail.com | \n\n理论上我们可以随意挑选表中的字段作为 索引（INDEX），但是在实践中需要选择那些可以识别出每行数据的字段或字段组合作为 索引（INDEX) ，否则便失去了 索引（INDEX) 的意义。\n\n要想从数据库中的表查找出其中一行数据，常用 SELECT * FROM `table_name` WHERE `column` = `condition` 。在 SELECT 语句中的 WHERE 条件就用到 **索引（INDEX）**。而使用 SELECT 语句查找数据最基本的方法就是从表的第一行找到表的最后一行。如果事先明确知道要查找用户的 `user_id（主键）` ，那么是可以通过查找一遍所有的表数据来找到想要的数据。但是如果假设我们只知道用户的叫 `Jonh` 且他的邮箱是 `adc@gmail.com`，那么就需要最多查找 m^2 次：第一遍找出符合用户名的人，第二遍找出符合邮箱的人，最后把两遍的结果组合起来。\n\n如果我们给用户表设置了以用户用户名和邮箱这两个字段组合而成的 索引（INDEX)，那么在数据库内部就已经存放着对应索引所代表的记录，当要查询时只需要查找一遍便可得到想要的结果。\n\n因此，在数据库的表中选用哪些字段作为 键（KEY），往往会影响整个表的查询效率。\n","slug":"Database-Key-and-Index","published":1,"updated":"2023-04-11T03:30:27.109Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgbppeb6000abvch5yu5c9rh","content":"<blockquote>\n<p>在 Youtube 上刷到了一个关于数据库设计的视频，看了一下感觉还不错，这几天应该都会看一点然后每天做一下记录。视频地址：<a href=\"https://www.youtube.com/watch?v=ztHopE5Wnpc&list=PLo47zzoJD98Jn5Z3e3003jzqTaATKuDnI\">Database Design Course</a></p>\n</blockquote>\n<h2><a href=\"#shi-me-shi-jian-key\" class=\"header-anchor\"></a><span id=\"shi-me-shi-jian-key\">什么是键（Key）</span></h2><blockquote>\n<p>KEY is something on the logical level, describes your table and database design (i.e. enforces referential integrity …)</p>\n</blockquote>\n<p>键（KEY）是数据库中常见的概念，通常用来描述数据库中表字段的性质和它们之间的关系，是逻辑层面的概念。比如有以下用户表：</p>\n<table>\n<thead>\n<tr>\n<th>user_id</th>\n<th>user_name</th>\n<th>age</th>\n<th>sex</th>\n<th>email</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>001</td>\n<td>John</td>\n<td>24</td>\n<td>man</td>\n<td><a href=\"mailto:&#97;&#98;&#99;&#64;&#103;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#111;&#109;\">&#97;&#98;&#99;&#64;&#103;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#111;&#109;</a></td>\n</tr>\n<tr>\n<td>002</td>\n<td>Mary</td>\n<td>22</td>\n<td>female</td>\n<td><a href=\"mailto:&#98;&#x63;&#x64;&#64;&#103;&#109;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#109;\">&#98;&#x63;&#x64;&#64;&#103;&#109;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#109;</a></td>\n</tr>\n</tbody></table>\n<p>如果想要从表中识别出每一条数据，那么必定会存在一个字段，它的每一行的值都不一样，就比如表中的 <code>user_id</code> 字段，而这个字段常常被称之为用户表的 主键（PRIMARY_KEY）。</p>\n<p>假如还有一个卡片表：</p>\n<table>\n<thead>\n<tr>\n<th>card_id</th>\n<th>card_name</th>\n<th>belong_user_id</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>GoldCard</td>\n<td>001</td>\n</tr>\n</tbody></table>\n<p>它的某个字段（belong_user_id）关联着其他表的主键（user_id），那么这个字段常常称之为表的 外键（FOREIGN_KEY）。</p>\n<p>在数据库设计与实践中，往往会遵循 键（Key）的三个特征：</p>\n<ol>\n<li><p>唯一性（Unique）。</p>\n</li>\n<li><p>不可修改性（Nerver Changing）。</p>\n</li>\n<li><p>不能为空（Never Null）。</p>\n<p> <strong>唯一性（Unique）</strong>： 因为 <strong>键（KEY) 的作用是帮助我们可以在数据库中找出对应的数据</strong> ，所以如果想要从表中的海量数据找到对应的一条数据，那么 键（KEY)  必定是表中不能重复的字段，否则使用这个 键（KEY)  就不能找出对应的一条数据。</p>\n<p> <strong>不可修改性（Nerver Changing）</strong>：我们除了使用 键（KEY)  来查找表中对应的数据，也常常会使用 键（KEY) 来关联不同表中的数据。比如在上面的用户表外，还有一个 课程表 关联了这个学生表，还有 教师表 关联了 学生表等等，如果我们修改了学生表的 键（KEY) ，那么其他以这个键（KEY)  关联学生表的关联关系都要做改变，这些改变往往会容易引起程序错误，在迫不得已的时候，我们应该遵循 键（KEY)  的不可修改性。</p>\n<p> <strong>不能为空（Never Null）</strong>：这个很容易理解，如果 键（KEY)  为空，那么我们便从表中查找不出任何数据，也关联不上任务数据。</p>\n</li>\n</ol>\n<h2><a href=\"#shi-me-shi-suo-yin-index\" class=\"header-anchor\"></a><span id=\"shi-me-shi-suo-yin-index\">什么是索引（Index）</span></h2><blockquote>\n<p>INDEX is something on the physical level, helps improve access time for table operations. Behind every PK there is (usually) unique index created (automatically).</p>\n</blockquote>\n<p>索引（INDEX) 也是数据库中另一种常见的概念，通常用来优化数据库的查询工作，是数据库物理层面上的概念，索引（INDEX) 通常记录在数据库的默认表中，由数据库程序自己维护。而刚刚我们提到的 键（KEY）其实是 索引（INDEX）的一种实现。</p>\n<p>我们可以使用表中的一个字段作为索引（INDEX) ，也可以使用多个字段的组合成为索引（INDEX) ，例如在下方的用户表中， 可以使用 <code>user_id（主键）</code> 作为索引（INDEX) ，也可以使用  <code>user_name</code> 和 <code>age</code>  的组合来作为表的 索引（INDEX) 。</p>\n<table>\n<thead>\n<tr>\n<th>user_id</th>\n<th>user_name</th>\n<th>age</th>\n<th>sex</th>\n<th>email</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>001</td>\n<td>John</td>\n<td>24</td>\n<td>man</td>\n<td><a href=\"mailto:&#x61;&#98;&#99;&#x40;&#x67;&#109;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#109;\">&#x61;&#98;&#99;&#x40;&#x67;&#109;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#109;</a></td>\n</tr>\n<tr>\n<td>002</td>\n<td>Mary</td>\n<td>22</td>\n<td>female</td>\n<td><a href=\"mailto:&#98;&#99;&#x64;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#x63;&#111;&#x6d;\">&#98;&#99;&#x64;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#x63;&#111;&#x6d;</a></td>\n</tr>\n</tbody></table>\n<p>理论上我们可以随意挑选表中的字段作为 索引（INDEX），但是在实践中需要选择那些可以识别出每行数据的字段或字段组合作为 索引（INDEX) ，否则便失去了 索引（INDEX) 的意义。</p>\n<p>要想从数据库中的表查找出其中一行数据，常用 SELECT * FROM <code>table_name</code> WHERE <code>column</code> &#x3D; <code>condition</code> 。在 SELECT 语句中的 WHERE 条件就用到 <strong>索引（INDEX）</strong>。而使用 SELECT 语句查找数据最基本的方法就是从表的第一行找到表的最后一行。如果事先明确知道要查找用户的 <code>user_id（主键）</code> ，那么是可以通过查找一遍所有的表数据来找到想要的数据。但是如果假设我们只知道用户的叫 <code>Jonh</code> 且他的邮箱是 <code>adc@gmail.com</code>，那么就需要最多查找 m^2 次：第一遍找出符合用户名的人，第二遍找出符合邮箱的人，最后把两遍的结果组合起来。</p>\n<p>如果我们给用户表设置了以用户用户名和邮箱这两个字段组合而成的 索引（INDEX)，那么在数据库内部就已经存放着对应索引所代表的记录，当要查询时只需要查找一遍便可得到想要的结果。</p>\n<p>因此，在数据库的表中选用哪些字段作为 键（KEY），往往会影响整个表的查询效率。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>在 Youtube 上刷到了一个关于数据库设计的视频，看了一下感觉还不错，这几天应该都会看一点然后每天做一下记录。视频地址：<a href=\"https://www.youtube.com/watch?v=ztHopE5Wnpc&list=PLo47zzoJD98Jn5Z3e3003jzqTaATKuDnI\">Database Design Course</a></p>\n</blockquote>\n<h2 id=\"什么是键（Key）\"><a href=\"#什么是键（Key）\" class=\"headerlink\" title=\"什么是键（Key）\"></a>什么是键（Key）</h2><blockquote>\n<p>KEY is something on the logical level, describes your table and database design (i.e. enforces referential integrity …)</p>\n</blockquote>\n<p>键（KEY）是数据库中常见的概念，通常用来描述数据库中表字段的性质和它们之间的关系，是逻辑层面的概念。比如有以下用户表：</p>\n<table>\n<thead>\n<tr>\n<th>user_id</th>\n<th>user_name</th>\n<th>age</th>\n<th>sex</th>\n<th>email</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>001</td>\n<td>John</td>\n<td>24</td>\n<td>man</td>\n<td><a href=\"mailto:&#97;&#98;&#99;&#64;&#103;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#111;&#109;\">&#97;&#98;&#99;&#64;&#103;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#111;&#109;</a></td>\n</tr>\n<tr>\n<td>002</td>\n<td>Mary</td>\n<td>22</td>\n<td>female</td>\n<td><a href=\"mailto:&#98;&#x63;&#x64;&#64;&#103;&#109;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#109;\">&#98;&#x63;&#x64;&#64;&#103;&#109;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#109;</a></td>\n</tr>\n</tbody></table>\n<p>如果想要从表中识别出每一条数据，那么必定会存在一个字段，它的每一行的值都不一样，就比如表中的 <code>user_id</code> 字段，而这个字段常常被称之为用户表的 主键（PRIMARY_KEY）。</p>\n<p>假如还有一个卡片表：</p>\n<table>\n<thead>\n<tr>\n<th>card_id</th>\n<th>card_name</th>\n<th>belong_user_id</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>GoldCard</td>\n<td>001</td>\n</tr>\n</tbody></table>\n<p>它的某个字段（belong_user_id）关联着其他表的主键（user_id），那么这个字段常常称之为表的 外键（FOREIGN_KEY）。</p>\n<p>在数据库设计与实践中，往往会遵循 键（Key）的三个特征：</p>\n<ol>\n<li><p>唯一性（Unique）。</p>\n</li>\n<li><p>不可修改性（Nerver Changing）。</p>\n</li>\n<li><p>不能为空（Never Null）。</p>\n<p> <strong>唯一性（Unique）</strong>： 因为 <strong>键（KEY) 的作用是帮助我们可以在数据库中找出对应的数据</strong> ，所以如果想要从表中的海量数据找到对应的一条数据，那么 键（KEY)  必定是表中不能重复的字段，否则使用这个 键（KEY)  就不能找出对应的一条数据。</p>\n<p> <strong>不可修改性（Nerver Changing）</strong>：我们除了使用 键（KEY)  来查找表中对应的数据，也常常会使用 键（KEY) 来关联不同表中的数据。比如在上面的用户表外，还有一个 课程表 关联了这个学生表，还有 教师表 关联了 学生表等等，如果我们修改了学生表的 键（KEY) ，那么其他以这个键（KEY)  关联学生表的关联关系都要做改变，这些改变往往会容易引起程序错误，在迫不得已的时候，我们应该遵循 键（KEY)  的不可修改性。</p>\n<p> <strong>不能为空（Never Null）</strong>：这个很容易理解，如果 键（KEY)  为空，那么我们便从表中查找不出任何数据，也关联不上任务数据。</p>\n</li>\n</ol>\n<h2 id=\"什么是索引（Index）\"><a href=\"#什么是索引（Index）\" class=\"headerlink\" title=\"什么是索引（Index）\"></a>什么是索引（Index）</h2><blockquote>\n<p>INDEX is something on the physical level, helps improve access time for table operations. Behind every PK there is (usually) unique index created (automatically).</p>\n</blockquote>\n<p>索引（INDEX) 也是数据库中另一种常见的概念，通常用来优化数据库的查询工作，是数据库物理层面上的概念，索引（INDEX) 通常记录在数据库的默认表中，由数据库程序自己维护。而刚刚我们提到的 键（KEY）其实是 索引（INDEX）的一种实现。</p>\n<p>我们可以使用表中的一个字段作为索引（INDEX) ，也可以使用多个字段的组合成为索引（INDEX) ，例如在下方的用户表中， 可以使用 <code>user_id（主键）</code> 作为索引（INDEX) ，也可以使用  <code>user_name</code> 和 <code>age</code>  的组合来作为表的 索引（INDEX) 。</p>\n<table>\n<thead>\n<tr>\n<th>user_id</th>\n<th>user_name</th>\n<th>age</th>\n<th>sex</th>\n<th>email</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>001</td>\n<td>John</td>\n<td>24</td>\n<td>man</td>\n<td><a href=\"mailto:&#x61;&#98;&#99;&#x40;&#x67;&#109;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#109;\">&#x61;&#98;&#99;&#x40;&#x67;&#109;&#97;&#x69;&#108;&#46;&#x63;&#x6f;&#109;</a></td>\n</tr>\n<tr>\n<td>002</td>\n<td>Mary</td>\n<td>22</td>\n<td>female</td>\n<td><a href=\"mailto:&#98;&#99;&#x64;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#x63;&#111;&#x6d;\">&#98;&#99;&#x64;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#x63;&#111;&#x6d;</a></td>\n</tr>\n</tbody></table>\n<p>理论上我们可以随意挑选表中的字段作为 索引（INDEX），但是在实践中需要选择那些可以识别出每行数据的字段或字段组合作为 索引（INDEX) ，否则便失去了 索引（INDEX) 的意义。</p>\n<p>要想从数据库中的表查找出其中一行数据，常用 SELECT * FROM <code>table_name</code> WHERE <code>column</code> &#x3D; <code>condition</code> 。在 SELECT 语句中的 WHERE 条件就用到 <strong>索引（INDEX）</strong>。而使用 SELECT 语句查找数据最基本的方法就是从表的第一行找到表的最后一行。如果事先明确知道要查找用户的 <code>user_id（主键）</code> ，那么是可以通过查找一遍所有的表数据来找到想要的数据。但是如果假设我们只知道用户的叫 <code>Jonh</code> 且他的邮箱是 <code>adc@gmail.com</code>，那么就需要最多查找 m^2 次：第一遍找出符合用户名的人，第二遍找出符合邮箱的人，最后把两遍的结果组合起来。</p>\n<p>如果我们给用户表设置了以用户用户名和邮箱这两个字段组合而成的 索引（INDEX)，那么在数据库内部就已经存放着对应索引所代表的记录，当要查询时只需要查找一遍便可得到想要的结果。</p>\n<p>因此，在数据库的表中选用哪些字段作为 键（KEY），往往会影响整个表的查询效率。</p>\n"},{"title":"Git 实战场景","date":"2019-12-19T11:54:00.000Z","_content":"### 情景一：开发中途添加远端仓库\n\n##### 通常情况\n\n这个场景通常是：开发者在接到新项目时直接在本地开发，到了开发中途才发现需要把工程纳入到版本管理，这个时候他在代码托管平台上新建了一个空的远程仓库，然后执行一下命令：\n\n```bash\n// 添加远程仓库地址并命名为origin\ngit remote add origin [URL]\n\n// 提交代码到远程仓库并将origin设置为默认提交仓库\ngit push -u origin master\n```\n\n> 设置了默认提交仓库后，以后再往origin这个远程仓库提交代码就可以不用指定直接执行`git push`就可以了。\n\n##### 特殊情况\n\n但由于一般的代码托管平台在新建仓库时可以选择**初始化仓库**，也就是会新建一个**README.md**文件并生成一次提交。如下图：\n\n![upload successful](/images/image-20191128113937513.png)\n\n如果不小心在新建的时候勾选了这个一个选项，那么你将可以有一下方法处理：\n\n一、 删掉重建\n\n- 删掉刚刚新建的远程仓库。\n- 重新再建一个空的仓库。\n- 按照**通常情况**的流程走一遍就可以了。\n\n这个是最安全又快捷的方法，但如果你出于某些原因无法再新建一个仓库，比如说你没有删除仓库的权限，而你又不想麻烦你的上级来处理这种低级的问题，怕上级会因此怀疑你的能力，那么你可以尝试下面的操作。\n\n二、本地合并\n\n- 根据本地的master分支新建一个备份分支master_backup。\n- 切换到备份分支，然后删除本地的master分支。\n- 本地切换到master分支。\n- 切换回master_bakcup分支并变基到master。\n- master分支合并master_backup分支（Fast-forward)。\n- 删除master_bakcup分支。\n\n一开始仓库的图为如下：\n\n![upload successful](/images/image-20191128140108874.png)\n\n然后使用`git branch master_backup `命令把master上的代码备份到`master_backup`分支上，再使用`git checkout master_backup`切换到`master_backup`分支，使用` git branch -D master`删除本地的`master`分支。操作完如下图所示：\n\n![upload successful](/images/image-20191128142021000.png)\n\n接着使用`git checkout mater`切换到master分支，这步操作会直接从远端的master上拉取代码，并在本地上新建一个master分支。确认本地存在了master分支后，就可以使用`git checkout master_backup`切换回master_backup分支，最后使用`git rebase master`将maser_backup上的代码变基到master上。变基完如下图：\n\n![upload successful](/images/image-20191128142447611.png)\n\n可以看到，本地的master分支和master_backup分支已经连成一条直线了。最后再切换回master分支，然后使用`git merge master_backup`合并（Fost-forward）master_backup分支就完成了代码的迁移了。此时master_backup分支上的代码就可以删除掉了。最后分支图如下：\n\n![upload successful](/images/image-20191128142917368.png)\n\n\n\n## 场景二：忘记把忽略文件添加到.gitignore中\n\n当你忘记添加 .gitignore 文件，不小心把一个很大的不需要追踪的文件添加到暂存区时（还没有提交），比如没有排除`node_modules`文件夹并执行了`git add -A`操作。如图：\n\n![upload successful](/images/image-20191128182507434.png)\n\n这个时候你想把`node_modules`文件夹下的文件从追踪列表中移除，可以使用一下命令：\n\n```bash\ngit rm --cached node_modules -r\n```\n\n![upload successful](/images/image-20191128182813621.png)\n\n这样`node_modules`里的文件就已经从追踪列表中移除了，这个时候就可以在.gitignore文件中添加node_modules目录了。\n\n## 情景三：使用别名\n\n","source":"_posts/Developer-Git-Situation-Solutions.md","raw":"title: Git 实战场景\ntags:\n  - 备忘翻阅\ncategories:\n  - Git\ndate: 2019-12-19 19:54:00\n---\n### 情景一：开发中途添加远端仓库\n\n##### 通常情况\n\n这个场景通常是：开发者在接到新项目时直接在本地开发，到了开发中途才发现需要把工程纳入到版本管理，这个时候他在代码托管平台上新建了一个空的远程仓库，然后执行一下命令：\n\n```bash\n// 添加远程仓库地址并命名为origin\ngit remote add origin [URL]\n\n// 提交代码到远程仓库并将origin设置为默认提交仓库\ngit push -u origin master\n```\n\n> 设置了默认提交仓库后，以后再往origin这个远程仓库提交代码就可以不用指定直接执行`git push`就可以了。\n\n##### 特殊情况\n\n但由于一般的代码托管平台在新建仓库时可以选择**初始化仓库**，也就是会新建一个**README.md**文件并生成一次提交。如下图：\n\n![upload successful](/images/image-20191128113937513.png)\n\n如果不小心在新建的时候勾选了这个一个选项，那么你将可以有一下方法处理：\n\n一、 删掉重建\n\n- 删掉刚刚新建的远程仓库。\n- 重新再建一个空的仓库。\n- 按照**通常情况**的流程走一遍就可以了。\n\n这个是最安全又快捷的方法，但如果你出于某些原因无法再新建一个仓库，比如说你没有删除仓库的权限，而你又不想麻烦你的上级来处理这种低级的问题，怕上级会因此怀疑你的能力，那么你可以尝试下面的操作。\n\n二、本地合并\n\n- 根据本地的master分支新建一个备份分支master_backup。\n- 切换到备份分支，然后删除本地的master分支。\n- 本地切换到master分支。\n- 切换回master_bakcup分支并变基到master。\n- master分支合并master_backup分支（Fast-forward)。\n- 删除master_bakcup分支。\n\n一开始仓库的图为如下：\n\n![upload successful](/images/image-20191128140108874.png)\n\n然后使用`git branch master_backup `命令把master上的代码备份到`master_backup`分支上，再使用`git checkout master_backup`切换到`master_backup`分支，使用` git branch -D master`删除本地的`master`分支。操作完如下图所示：\n\n![upload successful](/images/image-20191128142021000.png)\n\n接着使用`git checkout mater`切换到master分支，这步操作会直接从远端的master上拉取代码，并在本地上新建一个master分支。确认本地存在了master分支后，就可以使用`git checkout master_backup`切换回master_backup分支，最后使用`git rebase master`将maser_backup上的代码变基到master上。变基完如下图：\n\n![upload successful](/images/image-20191128142447611.png)\n\n可以看到，本地的master分支和master_backup分支已经连成一条直线了。最后再切换回master分支，然后使用`git merge master_backup`合并（Fost-forward）master_backup分支就完成了代码的迁移了。此时master_backup分支上的代码就可以删除掉了。最后分支图如下：\n\n![upload successful](/images/image-20191128142917368.png)\n\n\n\n## 场景二：忘记把忽略文件添加到.gitignore中\n\n当你忘记添加 .gitignore 文件，不小心把一个很大的不需要追踪的文件添加到暂存区时（还没有提交），比如没有排除`node_modules`文件夹并执行了`git add -A`操作。如图：\n\n![upload successful](/images/image-20191128182507434.png)\n\n这个时候你想把`node_modules`文件夹下的文件从追踪列表中移除，可以使用一下命令：\n\n```bash\ngit rm --cached node_modules -r\n```\n\n![upload successful](/images/image-20191128182813621.png)\n\n这样`node_modules`里的文件就已经从追踪列表中移除了，这个时候就可以在.gitignore文件中添加node_modules目录了。\n\n## 情景三：使用别名\n\n","slug":"Developer-Git-Situation-Solutions","published":1,"updated":"2023-04-11T03:30:27.110Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgbppeb7000ebvchbig1bvaw","content":"<h3><a href=\"#qing-jing-yi-kai-fa-zhong-tu-tian-jia-yuan-duan-cang-ku\" class=\"header-anchor\"></a><span id=\"qing-jing-yi-kai-fa-zhong-tu-tian-jia-yuan-duan-cang-ku\">情景一：开发中途添加远端仓库</span></h3><h5><a href=\"#tong-chang-qing-kuang\" class=\"header-anchor\"></a><span id=\"tong-chang-qing-kuang\">通常情况</span></h5><p>这个场景通常是：开发者在接到新项目时直接在本地开发，到了开发中途才发现需要把工程纳入到版本管理，这个时候他在代码托管平台上新建了一个空的远程仓库，然后执行一下命令：</p>\n<pre><code class=\"bash\">// 添加远程仓库地址并命名为origin\ngit remote add origin [URL]\n\n// 提交代码到远程仓库并将origin设置为默认提交仓库\ngit push -u origin master\n</code></pre>\n<blockquote>\n<p>设置了默认提交仓库后，以后再往origin这个远程仓库提交代码就可以不用指定直接执行<code>git push</code>就可以了。</p>\n</blockquote>\n<h5><a href=\"#te-shu-qing-kuang\" class=\"header-anchor\"></a><span id=\"te-shu-qing-kuang\">特殊情况</span></h5><p>但由于一般的代码托管平台在新建仓库时可以选择<strong>初始化仓库</strong>，也就是会新建一个<strong>README.md</strong>文件并生成一次提交。如下图：</p>\n<p><img src=\"/images/image-20191128113937513.png\" alt=\"upload successful\"></p>\n<p>如果不小心在新建的时候勾选了这个一个选项，那么你将可以有一下方法处理：</p>\n<p>一、 删掉重建</p>\n<ul>\n<li>删掉刚刚新建的远程仓库。</li>\n<li>重新再建一个空的仓库。</li>\n<li>按照<strong>通常情况</strong>的流程走一遍就可以了。</li>\n</ul>\n<p>这个是最安全又快捷的方法，但如果你出于某些原因无法再新建一个仓库，比如说你没有删除仓库的权限，而你又不想麻烦你的上级来处理这种低级的问题，怕上级会因此怀疑你的能力，那么你可以尝试下面的操作。</p>\n<p>二、本地合并</p>\n<ul>\n<li>根据本地的master分支新建一个备份分支master_backup。</li>\n<li>切换到备份分支，然后删除本地的master分支。</li>\n<li>本地切换到master分支。</li>\n<li>切换回master_bakcup分支并变基到master。</li>\n<li>master分支合并master_backup分支（Fast-forward)。</li>\n<li>删除master_bakcup分支。</li>\n</ul>\n<p>一开始仓库的图为如下：</p>\n<p><img src=\"/images/image-20191128140108874.png\" alt=\"upload successful\"></p>\n<p>然后使用<code>git branch master_backup </code>命令把master上的代码备份到<code>master_backup</code>分支上，再使用<code>git checkout master_backup</code>切换到<code>master_backup</code>分支，使用<code> git branch -D master</code>删除本地的<code>master</code>分支。操作完如下图所示：</p>\n<p><img src=\"/images/image-20191128142021000.png\" alt=\"upload successful\"></p>\n<p>接着使用<code>git checkout mater</code>切换到master分支，这步操作会直接从远端的master上拉取代码，并在本地上新建一个master分支。确认本地存在了master分支后，就可以使用<code>git checkout master_backup</code>切换回master_backup分支，最后使用<code>git rebase master</code>将maser_backup上的代码变基到master上。变基完如下图：</p>\n<p><img src=\"/images/image-20191128142447611.png\" alt=\"upload successful\"></p>\n<p>可以看到，本地的master分支和master_backup分支已经连成一条直线了。最后再切换回master分支，然后使用<code>git merge master_backup</code>合并（Fost-forward）master_backup分支就完成了代码的迁移了。此时master_backup分支上的代码就可以删除掉了。最后分支图如下：</p>\n<p><img src=\"/images/image-20191128142917368.png\" alt=\"upload successful\"></p>\n<h2><a href=\"#chang-jing-er-wang-ji-ba-hu-lue-wen-jian-tian-jia-dao-gitignore-zhong\" class=\"header-anchor\"></a><span id=\"chang-jing-er-wang-ji-ba-hu-lue-wen-jian-tian-jia-dao-gitignore-zhong\">场景二：忘记把忽略文件添加到.gitignore中</span></h2><p>当你忘记添加 .gitignore 文件，不小心把一个很大的不需要追踪的文件添加到暂存区时（还没有提交），比如没有排除<code>node_modules</code>文件夹并执行了<code>git add -A</code>操作。如图：</p>\n<p><img src=\"/images/image-20191128182507434.png\" alt=\"upload successful\"></p>\n<p>这个时候你想把<code>node_modules</code>文件夹下的文件从追踪列表中移除，可以使用一下命令：</p>\n<pre><code class=\"bash\">git rm --cached node_modules -r\n</code></pre>\n<p><img src=\"/images/image-20191128182813621.png\" alt=\"upload successful\"></p>\n<p>这样<code>node_modules</code>里的文件就已经从追踪列表中移除了，这个时候就可以在.gitignore文件中添加node_modules目录了。</p>\n<h2><a href=\"#qing-jing-san-shi-yong-bie-ming\" class=\"header-anchor\"></a><span id=\"qing-jing-san-shi-yong-bie-ming\">情景三：使用别名</span></h2>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"情景一：开发中途添加远端仓库\"><a href=\"#情景一：开发中途添加远端仓库\" class=\"headerlink\" title=\"情景一：开发中途添加远端仓库\"></a>情景一：开发中途添加远端仓库</h3><h5 id=\"通常情况\"><a href=\"#通常情况\" class=\"headerlink\" title=\"通常情况\"></a>通常情况</h5><p>这个场景通常是：开发者在接到新项目时直接在本地开发，到了开发中途才发现需要把工程纳入到版本管理，这个时候他在代码托管平台上新建了一个空的远程仓库，然后执行一下命令：</p>\n<pre><code class=\"bash\">// 添加远程仓库地址并命名为origin\ngit remote add origin [URL]\n\n// 提交代码到远程仓库并将origin设置为默认提交仓库\ngit push -u origin master\n</code></pre>\n<blockquote>\n<p>设置了默认提交仓库后，以后再往origin这个远程仓库提交代码就可以不用指定直接执行<code>git push</code>就可以了。</p>\n</blockquote>\n<h5 id=\"特殊情况\"><a href=\"#特殊情况\" class=\"headerlink\" title=\"特殊情况\"></a>特殊情况</h5><p>但由于一般的代码托管平台在新建仓库时可以选择<strong>初始化仓库</strong>，也就是会新建一个<strong>README.md</strong>文件并生成一次提交。如下图：</p>\n<p><img src=\"/images/image-20191128113937513.png\" alt=\"upload successful\"></p>\n<p>如果不小心在新建的时候勾选了这个一个选项，那么你将可以有一下方法处理：</p>\n<p>一、 删掉重建</p>\n<ul>\n<li>删掉刚刚新建的远程仓库。</li>\n<li>重新再建一个空的仓库。</li>\n<li>按照<strong>通常情况</strong>的流程走一遍就可以了。</li>\n</ul>\n<p>这个是最安全又快捷的方法，但如果你出于某些原因无法再新建一个仓库，比如说你没有删除仓库的权限，而你又不想麻烦你的上级来处理这种低级的问题，怕上级会因此怀疑你的能力，那么你可以尝试下面的操作。</p>\n<p>二、本地合并</p>\n<ul>\n<li>根据本地的master分支新建一个备份分支master_backup。</li>\n<li>切换到备份分支，然后删除本地的master分支。</li>\n<li>本地切换到master分支。</li>\n<li>切换回master_bakcup分支并变基到master。</li>\n<li>master分支合并master_backup分支（Fast-forward)。</li>\n<li>删除master_bakcup分支。</li>\n</ul>\n<p>一开始仓库的图为如下：</p>\n<p><img src=\"/images/image-20191128140108874.png\" alt=\"upload successful\"></p>\n<p>然后使用<code>git branch master_backup </code>命令把master上的代码备份到<code>master_backup</code>分支上，再使用<code>git checkout master_backup</code>切换到<code>master_backup</code>分支，使用<code> git branch -D master</code>删除本地的<code>master</code>分支。操作完如下图所示：</p>\n<p><img src=\"/images/image-20191128142021000.png\" alt=\"upload successful\"></p>\n<p>接着使用<code>git checkout mater</code>切换到master分支，这步操作会直接从远端的master上拉取代码，并在本地上新建一个master分支。确认本地存在了master分支后，就可以使用<code>git checkout master_backup</code>切换回master_backup分支，最后使用<code>git rebase master</code>将maser_backup上的代码变基到master上。变基完如下图：</p>\n<p><img src=\"/images/image-20191128142447611.png\" alt=\"upload successful\"></p>\n<p>可以看到，本地的master分支和master_backup分支已经连成一条直线了。最后再切换回master分支，然后使用<code>git merge master_backup</code>合并（Fost-forward）master_backup分支就完成了代码的迁移了。此时master_backup分支上的代码就可以删除掉了。最后分支图如下：</p>\n<p><img src=\"/images/image-20191128142917368.png\" alt=\"upload successful\"></p>\n<h2 id=\"场景二：忘记把忽略文件添加到-gitignore中\"><a href=\"#场景二：忘记把忽略文件添加到-gitignore中\" class=\"headerlink\" title=\"场景二：忘记把忽略文件添加到.gitignore中\"></a>场景二：忘记把忽略文件添加到.gitignore中</h2><p>当你忘记添加 .gitignore 文件，不小心把一个很大的不需要追踪的文件添加到暂存区时（还没有提交），比如没有排除<code>node_modules</code>文件夹并执行了<code>git add -A</code>操作。如图：</p>\n<p><img src=\"/images/image-20191128182507434.png\" alt=\"upload successful\"></p>\n<p>这个时候你想把<code>node_modules</code>文件夹下的文件从追踪列表中移除，可以使用一下命令：</p>\n<pre><code class=\"bash\">git rm --cached node_modules -r\n</code></pre>\n<p><img src=\"/images/image-20191128182813621.png\" alt=\"upload successful\"></p>\n<p>这样<code>node_modules</code>里的文件就已经从追踪列表中移除了，这个时候就可以在.gitignore文件中添加node_modules目录了。</p>\n<h2 id=\"情景三：使用别名\"><a href=\"#情景三：使用别名\" class=\"headerlink\" title=\"情景三：使用别名\"></a>情景三：使用别名</h2>"},{"title":"并发和并行的区别","date":"2019-11-21T15:38:00.000Z","_content":"在学习NodeJs中事件循环机制的时候遇到了两个不太清楚的概念：并发和并行。文章是这样说的，NodeJs由于是单线程运行的，所以它是无法进行真正意义上的并行操作，准确来说应该是并发。下面记录一下。\n\n### 并发（concurrency）\n\n并发是指具有处理多个任务的能力，是指逻辑上的同时任务，不是说物理上的，并发事件不一定要同一时刻发生。\n\n通俗形象一点就是说，当遇到许多任务的时候，可以把其中一个大任务拆解成多个小任务，然后这些被拆解的小任务交叉执行（一般这个过程由操作系统完成），而实际上在某一时刻还是只执行一个任务，所以本质上还是串行的。\n\n![concurrency.png](/images/concurrency.png)\n\n### 并行（parallelism）\n\n并行是指具有同时处理多个任务的能力，是真正意义上的同时执行。\n\n![parallelism.png](/images/parallelism.png)\n\n### 计算机中的并发和并行\n\n对于一台单核CPU的计算机来说，即使使用了多线程或者多进程来执行任务，在真实环境中也是不可能并行执行的，简单道理就是一个CPU在某一时刻只能执行一条指令。所以在这种情况下他们只能说是并发执行。\n\n换个角度说，并行执行只能出现在多核CPU上。","source":"_posts/Difference-Between-Concurrency-And-Parallelism.md","raw":"title: 并发和并行的区别\ntags:\n  - 个人总结\ncategories:\n  - NodeJs\ndate: 2019-11-21 23:38:00\n---\n在学习NodeJs中事件循环机制的时候遇到了两个不太清楚的概念：并发和并行。文章是这样说的，NodeJs由于是单线程运行的，所以它是无法进行真正意义上的并行操作，准确来说应该是并发。下面记录一下。\n\n### 并发（concurrency）\n\n并发是指具有处理多个任务的能力，是指逻辑上的同时任务，不是说物理上的，并发事件不一定要同一时刻发生。\n\n通俗形象一点就是说，当遇到许多任务的时候，可以把其中一个大任务拆解成多个小任务，然后这些被拆解的小任务交叉执行（一般这个过程由操作系统完成），而实际上在某一时刻还是只执行一个任务，所以本质上还是串行的。\n\n![concurrency.png](/images/concurrency.png)\n\n### 并行（parallelism）\n\n并行是指具有同时处理多个任务的能力，是真正意义上的同时执行。\n\n![parallelism.png](/images/parallelism.png)\n\n### 计算机中的并发和并行\n\n对于一台单核CPU的计算机来说，即使使用了多线程或者多进程来执行任务，在真实环境中也是不可能并行执行的，简单道理就是一个CPU在某一时刻只能执行一条指令。所以在这种情况下他们只能说是并发执行。\n\n换个角度说，并行执行只能出现在多核CPU上。","slug":"Difference-Between-Concurrency-And-Parallelism","published":1,"updated":"2023-04-11T03:30:27.110Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgbppeb8000gbvch8btybupi","content":"<p>在学习NodeJs中事件循环机制的时候遇到了两个不太清楚的概念：并发和并行。文章是这样说的，NodeJs由于是单线程运行的，所以它是无法进行真正意义上的并行操作，准确来说应该是并发。下面记录一下。</p>\n<h3><a href=\"#bing-fa-concurrency\" class=\"header-anchor\"></a><span id=\"bing-fa-concurrency\">并发（concurrency）</span></h3><p>并发是指具有处理多个任务的能力，是指逻辑上的同时任务，不是说物理上的，并发事件不一定要同一时刻发生。</p>\n<p>通俗形象一点就是说，当遇到许多任务的时候，可以把其中一个大任务拆解成多个小任务，然后这些被拆解的小任务交叉执行（一般这个过程由操作系统完成），而实际上在某一时刻还是只执行一个任务，所以本质上还是串行的。</p>\n<p><img src=\"/images/concurrency.png\" alt=\"concurrency.png\"></p>\n<h3><a href=\"#bing-xing-parallelism\" class=\"header-anchor\"></a><span id=\"bing-xing-parallelism\">并行（parallelism）</span></h3><p>并行是指具有同时处理多个任务的能力，是真正意义上的同时执行。</p>\n<p><img src=\"/images/parallelism.png\" alt=\"parallelism.png\"></p>\n<h3><a href=\"#ji-suan-ji-zhong-de-bing-fa-he-bing-xing\" class=\"header-anchor\"></a><span id=\"ji-suan-ji-zhong-de-bing-fa-he-bing-xing\">计算机中的并发和并行</span></h3><p>对于一台单核CPU的计算机来说，即使使用了多线程或者多进程来执行任务，在真实环境中也是不可能并行执行的，简单道理就是一个CPU在某一时刻只能执行一条指令。所以在这种情况下他们只能说是并发执行。</p>\n<p>换个角度说，并行执行只能出现在多核CPU上。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在学习NodeJs中事件循环机制的时候遇到了两个不太清楚的概念：并发和并行。文章是这样说的，NodeJs由于是单线程运行的，所以它是无法进行真正意义上的并行操作，准确来说应该是并发。下面记录一下。</p>\n<h3 id=\"并发（concurrency）\"><a href=\"#并发（concurrency）\" class=\"headerlink\" title=\"并发（concurrency）\"></a>并发（concurrency）</h3><p>并发是指具有处理多个任务的能力，是指逻辑上的同时任务，不是说物理上的，并发事件不一定要同一时刻发生。</p>\n<p>通俗形象一点就是说，当遇到许多任务的时候，可以把其中一个大任务拆解成多个小任务，然后这些被拆解的小任务交叉执行（一般这个过程由操作系统完成），而实际上在某一时刻还是只执行一个任务，所以本质上还是串行的。</p>\n<p><img src=\"/images/concurrency.png\" alt=\"concurrency.png\"></p>\n<h3 id=\"并行（parallelism）\"><a href=\"#并行（parallelism）\" class=\"headerlink\" title=\"并行（parallelism）\"></a>并行（parallelism）</h3><p>并行是指具有同时处理多个任务的能力，是真正意义上的同时执行。</p>\n<p><img src=\"/images/parallelism.png\" alt=\"parallelism.png\"></p>\n<h3 id=\"计算机中的并发和并行\"><a href=\"#计算机中的并发和并行\" class=\"headerlink\" title=\"计算机中的并发和并行\"></a>计算机中的并发和并行</h3><p>对于一台单核CPU的计算机来说，即使使用了多线程或者多进程来执行任务，在真实环境中也是不可能并行执行的，简单道理就是一个CPU在某一时刻只能执行一条指令。所以在这种情况下他们只能说是并发执行。</p>\n<p>换个角度说，并行执行只能出现在多核CPU上。</p>\n"},{"title":"Docker中容器的网络配置常用命令","date":"2019-11-21T07:22:00.000Z","_content":"## 网络基础配置\n\n虽然Docker可以根据镜像“多开”容器，并而每个容器互不影响，但并不代表容器与容器之间是完全决裂的。Docker在运行镜像的时候提供了映射容器端口到宿主主机、容器端口到另一个容器的网络互联功能，使得容器与宿主主机、容器与容器之间可以相互通信。\n\n###　从外部访问容器应用\n\n在启动容器的时候，如果不指定对应的参数，在容器外是无法通过网络来访问容器内的网络应用和服务的。当容器中运行一些需要被外部访问的网络应用时，可以通过-P或者-p参数来指定端口映射。当使用-P标记时，Docker会随机映射一个49000~49900的端口至容器内部开放的网络端口：\n\n```\ndocker run -d -p [mirror ID or TAG]\n```\n\n使用-p （小写）则可以指定要映射的端口，并且在一个指定端口上只可以绑定一个容器。支持的格式有ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort。\n\n#### 映射所有接口地址\n\n使用hostPort:containerPort将本地的5000端口映射到容器的5000端口：\n\n```\ndocker run -d -p 5000:5000 training/webapp python app.py\n```\n\n此时默认会绑定本地所有接口上的所有地址。多次使用-p标记可以绑定多个端口：\n\n```\ndocker run -d -p 5000:5000 -p 3000:80 training/webapp python app.py\n```\n\n#### 映射到指定地址的指定端口\n\n可以使用ip:hostPort:containerPort格式指定映射使用一个特定地址，比如localhost地址127.0.0.1:\n\n```\ndocker run -d -p 127.0.0.1:5000:5000 training/webapp python app.py\n```\n\n> 也可以是内部其它容器的IP地址。\n\n#### 映射到指定地址的任意端口\n\n使用ip::containerPort绑定localhost的任意端口到容器5000端口，本地主机会自动分配一个端口：\n\n```\ndocker run -d -p 127.0.0.1::5000 training/webapp python app.py\n```\n\n还可以使用udp标记来指定udp端口：\n\n```\ndocker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py\n```\n\n#### 查看映射端口配置\n\n使用docker port查看当前映射的端口配置，也可以查看到绑定的地址：\n\n```\ndocker port nostalgic_morse 5000\n```\n\n> 容器有自己的内部网络和IP地址（使用docker inspect+容器ID可以获取所有的变量值）。\n\n### 容器互联实现容器间的互通信\n\n容器的连接系统是除了端口映射外另一种可以与容器中应用进行交互的方式。它会在源和接收容器之间创建一个隧道，接收容器可以看到源容器指定的信息。\n\n#### 自定义容器命名\n\n连接系统依据容器的名称来执行。因此首先需要自定义一个好记的容器命名。\n虽然当创建容器的时候，系统默认会分配一个名字，但自定义命名容器有两个好处：\n\n- 自定义的命名比较好记\n- 当要连接其它容器时，可以作为一个有用的参数点，比如连接web容器到db容器。\n\n使用--name标记可以为容器自定义命名：\n\n```\ndocker run -d -p --name web training/webapp python app.py\n```\n\n使用docker ps可以查看命名，或者使用docker inspect来查看容器的名字：\n\n```\ndocker inspect -f \"{{name}}\" [mirror ID]\n```\n\n> 容器的名称是唯一的，如果已经命名了一个叫web的容器，必须先用docker rm命令来删除这个容器，才能再以web这个名称创建新容器。\n\n容器互联\n\n使用--link参数可以让容器之间安全地进行交互。\n\n--link参数格式是--link name:alias，其中name是要链接容器的名称，alias是这个连接的别名。\n\n比如我们先创建一个新的数据库容器：\n\n```\ndocker run -d --name db training/postgres\n```\n\n然后再创建一个web容器，并将它连接到db容器：\n\n```\ndocker run -d -p --name web --link db:db training/webapp python app.py\n```\n\n这个时候db容器就与web容器可以互相通信了。可以使用docker ps来查看容器的连接。\n\n> 使用--link参数可以让Docker在两个容器之间通过一个安全的隧道互相通信，而不用通过开放端口的方式来实现，避免了把端口暴露到外部网络上。\n\n#### 查看公开容器的接连信息\n\n- 环境变量：使用env命令来查看容器的环境变量\n\n```\ndocker run --name web --link db:db training/webapp env\n```\n\n- /etc/hosts文件：使用link参数时，Docker会添加host信息到父容器的/etc/hosts的文件。下面是父容器web的hosts文件\n\n```\ndocker run -t -i --link db:db training/webapp /bin/bash\nroot@aed84ee21bd3:/opt/webapp# cat /etc/hosts\n127.17.0.7 aed84ee21bde\n...\n172.17.0.5 db\n```\n\n第一个是web容器的host信息，默认用自己的id为主机名。第二个是db容器的ip和主机名。\n\n---\n\n## 更多阅读\n\nDocker系列文章：\n\n1. [Docker中镜像、容器的常用命令](https://juejin.im/post/5d8820cae51d453b1e478b91)\n2. [Docker仓库常用命令](https://juejin.im/post/5d9f53d26fb9a04e3142120c)\n3. [Docker中容器的网络配置常用命令](https://juejin.im/post/5d9f4f86e51d4577f3534ead)","source":"_posts/Frequently-Used-Docker-Container-Network-Command.md","raw":"title: Docker中容器的网络配置常用命令\ntags:\n  - 备忘翻阅\n  - ''\ncategories:\n  - Docker\ndate: 2019-11-21 15:22:00\n---\n## 网络基础配置\n\n虽然Docker可以根据镜像“多开”容器，并而每个容器互不影响，但并不代表容器与容器之间是完全决裂的。Docker在运行镜像的时候提供了映射容器端口到宿主主机、容器端口到另一个容器的网络互联功能，使得容器与宿主主机、容器与容器之间可以相互通信。\n\n###　从外部访问容器应用\n\n在启动容器的时候，如果不指定对应的参数，在容器外是无法通过网络来访问容器内的网络应用和服务的。当容器中运行一些需要被外部访问的网络应用时，可以通过-P或者-p参数来指定端口映射。当使用-P标记时，Docker会随机映射一个49000~49900的端口至容器内部开放的网络端口：\n\n```\ndocker run -d -p [mirror ID or TAG]\n```\n\n使用-p （小写）则可以指定要映射的端口，并且在一个指定端口上只可以绑定一个容器。支持的格式有ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort。\n\n#### 映射所有接口地址\n\n使用hostPort:containerPort将本地的5000端口映射到容器的5000端口：\n\n```\ndocker run -d -p 5000:5000 training/webapp python app.py\n```\n\n此时默认会绑定本地所有接口上的所有地址。多次使用-p标记可以绑定多个端口：\n\n```\ndocker run -d -p 5000:5000 -p 3000:80 training/webapp python app.py\n```\n\n#### 映射到指定地址的指定端口\n\n可以使用ip:hostPort:containerPort格式指定映射使用一个特定地址，比如localhost地址127.0.0.1:\n\n```\ndocker run -d -p 127.0.0.1:5000:5000 training/webapp python app.py\n```\n\n> 也可以是内部其它容器的IP地址。\n\n#### 映射到指定地址的任意端口\n\n使用ip::containerPort绑定localhost的任意端口到容器5000端口，本地主机会自动分配一个端口：\n\n```\ndocker run -d -p 127.0.0.1::5000 training/webapp python app.py\n```\n\n还可以使用udp标记来指定udp端口：\n\n```\ndocker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py\n```\n\n#### 查看映射端口配置\n\n使用docker port查看当前映射的端口配置，也可以查看到绑定的地址：\n\n```\ndocker port nostalgic_morse 5000\n```\n\n> 容器有自己的内部网络和IP地址（使用docker inspect+容器ID可以获取所有的变量值）。\n\n### 容器互联实现容器间的互通信\n\n容器的连接系统是除了端口映射外另一种可以与容器中应用进行交互的方式。它会在源和接收容器之间创建一个隧道，接收容器可以看到源容器指定的信息。\n\n#### 自定义容器命名\n\n连接系统依据容器的名称来执行。因此首先需要自定义一个好记的容器命名。\n虽然当创建容器的时候，系统默认会分配一个名字，但自定义命名容器有两个好处：\n\n- 自定义的命名比较好记\n- 当要连接其它容器时，可以作为一个有用的参数点，比如连接web容器到db容器。\n\n使用--name标记可以为容器自定义命名：\n\n```\ndocker run -d -p --name web training/webapp python app.py\n```\n\n使用docker ps可以查看命名，或者使用docker inspect来查看容器的名字：\n\n```\ndocker inspect -f \"{{name}}\" [mirror ID]\n```\n\n> 容器的名称是唯一的，如果已经命名了一个叫web的容器，必须先用docker rm命令来删除这个容器，才能再以web这个名称创建新容器。\n\n容器互联\n\n使用--link参数可以让容器之间安全地进行交互。\n\n--link参数格式是--link name:alias，其中name是要链接容器的名称，alias是这个连接的别名。\n\n比如我们先创建一个新的数据库容器：\n\n```\ndocker run -d --name db training/postgres\n```\n\n然后再创建一个web容器，并将它连接到db容器：\n\n```\ndocker run -d -p --name web --link db:db training/webapp python app.py\n```\n\n这个时候db容器就与web容器可以互相通信了。可以使用docker ps来查看容器的连接。\n\n> 使用--link参数可以让Docker在两个容器之间通过一个安全的隧道互相通信，而不用通过开放端口的方式来实现，避免了把端口暴露到外部网络上。\n\n#### 查看公开容器的接连信息\n\n- 环境变量：使用env命令来查看容器的环境变量\n\n```\ndocker run --name web --link db:db training/webapp env\n```\n\n- /etc/hosts文件：使用link参数时，Docker会添加host信息到父容器的/etc/hosts的文件。下面是父容器web的hosts文件\n\n```\ndocker run -t -i --link db:db training/webapp /bin/bash\nroot@aed84ee21bd3:/opt/webapp# cat /etc/hosts\n127.17.0.7 aed84ee21bde\n...\n172.17.0.5 db\n```\n\n第一个是web容器的host信息，默认用自己的id为主机名。第二个是db容器的ip和主机名。\n\n---\n\n## 更多阅读\n\nDocker系列文章：\n\n1. [Docker中镜像、容器的常用命令](https://juejin.im/post/5d8820cae51d453b1e478b91)\n2. [Docker仓库常用命令](https://juejin.im/post/5d9f53d26fb9a04e3142120c)\n3. [Docker中容器的网络配置常用命令](https://juejin.im/post/5d9f4f86e51d4577f3534ead)","slug":"Frequently-Used-Docker-Container-Network-Command","published":1,"updated":"2023-04-11T03:30:27.110Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgbppeb9000lbvche3r61ye7","content":"<h2><a href=\"#wang-luo-ji-chu-pei-zhi\" class=\"header-anchor\"></a><span id=\"wang-luo-ji-chu-pei-zhi\">网络基础配置</span></h2><p>虽然Docker可以根据镜像“多开”容器，并而每个容器互不影响，但并不代表容器与容器之间是完全决裂的。Docker在运行镜像的时候提供了映射容器端口到宿主主机、容器端口到另一个容器的网络互联功能，使得容器与宿主主机、容器与容器之间可以相互通信。</p>\n<h3><a href=\"#cong-wai-bu-fang-wen-rong-qi-ying-yong\" class=\"header-anchor\"></a><span id=\"cong-wai-bu-fang-wen-rong-qi-ying-yong\">从外部访问容器应用</span></h3><p>在启动容器的时候，如果不指定对应的参数，在容器外是无法通过网络来访问容器内的网络应用和服务的。当容器中运行一些需要被外部访问的网络应用时，可以通过-P或者-p参数来指定端口映射。当使用-P标记时，Docker会随机映射一个49000~49900的端口至容器内部开放的网络端口：</p>\n<pre><code>docker run -d -p [mirror ID or TAG]\n</code></pre>\n<p>使用-p （小写）则可以指定要映射的端口，并且在一个指定端口上只可以绑定一个容器。支持的格式有ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort。</p>\n<h4><a href=\"#ying-she-suo-you-jie-kou-di-zhi\" class=\"header-anchor\"></a><span id=\"ying-she-suo-you-jie-kou-di-zhi\">映射所有接口地址</span></h4><p>使用hostPort:containerPort将本地的5000端口映射到容器的5000端口：</p>\n<pre><code>docker run -d -p 5000:5000 training/webapp python app.py\n</code></pre>\n<p>此时默认会绑定本地所有接口上的所有地址。多次使用-p标记可以绑定多个端口：</p>\n<pre><code>docker run -d -p 5000:5000 -p 3000:80 training/webapp python app.py\n</code></pre>\n<h4><a href=\"#ying-she-dao-zhi-ding-di-zhi-de-zhi-ding-duan-kou\" class=\"header-anchor\"></a><span id=\"ying-she-dao-zhi-ding-di-zhi-de-zhi-ding-duan-kou\">映射到指定地址的指定端口</span></h4><p>可以使用ip:hostPort:containerPort格式指定映射使用一个特定地址，比如localhost地址127.0.0.1:</p>\n<pre><code>docker run -d -p 127.0.0.1:5000:5000 training/webapp python app.py\n</code></pre>\n<blockquote>\n<p>也可以是内部其它容器的IP地址。</p>\n</blockquote>\n<h4><a href=\"#ying-she-dao-zhi-ding-di-zhi-de-ren-yi-duan-kou\" class=\"header-anchor\"></a><span id=\"ying-she-dao-zhi-ding-di-zhi-de-ren-yi-duan-kou\">映射到指定地址的任意端口</span></h4><p>使用ip::containerPort绑定localhost的任意端口到容器5000端口，本地主机会自动分配一个端口：</p>\n<pre><code>docker run -d -p 127.0.0.1::5000 training/webapp python app.py\n</code></pre>\n<p>还可以使用udp标记来指定udp端口：</p>\n<pre><code>docker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py\n</code></pre>\n<h4><a href=\"#cha-kan-ying-she-duan-kou-pei-zhi\" class=\"header-anchor\"></a><span id=\"cha-kan-ying-she-duan-kou-pei-zhi\">查看映射端口配置</span></h4><p>使用docker port查看当前映射的端口配置，也可以查看到绑定的地址：</p>\n<pre><code>docker port nostalgic_morse 5000\n</code></pre>\n<blockquote>\n<p>容器有自己的内部网络和IP地址（使用docker inspect+容器ID可以获取所有的变量值）。</p>\n</blockquote>\n<h3><a href=\"#rong-qi-hu-lian-shi-xian-rong-qi-jian-de-hu-tong-xin\" class=\"header-anchor\"></a><span id=\"rong-qi-hu-lian-shi-xian-rong-qi-jian-de-hu-tong-xin\">容器互联实现容器间的互通信</span></h3><p>容器的连接系统是除了端口映射外另一种可以与容器中应用进行交互的方式。它会在源和接收容器之间创建一个隧道，接收容器可以看到源容器指定的信息。</p>\n<h4><a href=\"#zi-ding-yi-rong-qi-ming-ming\" class=\"header-anchor\"></a><span id=\"zi-ding-yi-rong-qi-ming-ming\">自定义容器命名</span></h4><p>连接系统依据容器的名称来执行。因此首先需要自定义一个好记的容器命名。<br>虽然当创建容器的时候，系统默认会分配一个名字，但自定义命名容器有两个好处：</p>\n<ul>\n<li>自定义的命名比较好记</li>\n<li>当要连接其它容器时，可以作为一个有用的参数点，比如连接web容器到db容器。</li>\n</ul>\n<p>使用–name标记可以为容器自定义命名：</p>\n<pre><code>docker run -d -p --name web training/webapp python app.py\n</code></pre>\n<p>使用docker ps可以查看命名，或者使用docker inspect来查看容器的名字：</p>\n<pre><code>docker inspect -f &quot;&#123;&#123;name&#125;&#125;&quot; [mirror ID]\n</code></pre>\n<blockquote>\n<p>容器的名称是唯一的，如果已经命名了一个叫web的容器，必须先用docker rm命令来删除这个容器，才能再以web这个名称创建新容器。</p>\n</blockquote>\n<p>容器互联</p>\n<p>使用–link参数可以让容器之间安全地进行交互。</p>\n<p>–link参数格式是–link name:alias，其中name是要链接容器的名称，alias是这个连接的别名。</p>\n<p>比如我们先创建一个新的数据库容器：</p>\n<pre><code>docker run -d --name db training/postgres\n</code></pre>\n<p>然后再创建一个web容器，并将它连接到db容器：</p>\n<pre><code>docker run -d -p --name web --link db:db training/webapp python app.py\n</code></pre>\n<p>这个时候db容器就与web容器可以互相通信了。可以使用docker ps来查看容器的连接。</p>\n<blockquote>\n<p>使用–link参数可以让Docker在两个容器之间通过一个安全的隧道互相通信，而不用通过开放端口的方式来实现，避免了把端口暴露到外部网络上。</p>\n</blockquote>\n<h4><a href=\"#cha-kan-gong-kai-rong-qi-de-jie-lian-xin-xi\" class=\"header-anchor\"></a><span id=\"cha-kan-gong-kai-rong-qi-de-jie-lian-xin-xi\">查看公开容器的接连信息</span></h4><ul>\n<li>环境变量：使用env命令来查看容器的环境变量</li>\n</ul>\n<pre><code>docker run --name web --link db:db training/webapp env\n</code></pre>\n<ul>\n<li>&#x2F;etc&#x2F;hosts文件：使用link参数时，Docker会添加host信息到父容器的&#x2F;etc&#x2F;hosts的文件。下面是父容器web的hosts文件</li>\n</ul>\n<pre><code>docker run -t -i --link db:db training/webapp /bin/bash\nroot@aed84ee21bd3:/opt/webapp# cat /etc/hosts\n127.17.0.7 aed84ee21bde\n...\n172.17.0.5 db\n</code></pre>\n<p>第一个是web容器的host信息，默认用自己的id为主机名。第二个是db容器的ip和主机名。</p>\n<hr>\n<h2><a href=\"#geng-duo-yue-du\" class=\"header-anchor\"></a><span id=\"geng-duo-yue-du\">更多阅读</span></h2><p>Docker系列文章：</p>\n<ol>\n<li><a href=\"https://juejin.im/post/5d8820cae51d453b1e478b91\">Docker中镜像、容器的常用命令</a></li>\n<li><a href=\"https://juejin.im/post/5d9f53d26fb9a04e3142120c\">Docker仓库常用命令</a></li>\n<li><a href=\"https://juejin.im/post/5d9f4f86e51d4577f3534ead\">Docker中容器的网络配置常用命令</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"网络基础配置\"><a href=\"#网络基础配置\" class=\"headerlink\" title=\"网络基础配置\"></a>网络基础配置</h2><p>虽然Docker可以根据镜像“多开”容器，并而每个容器互不影响，但并不代表容器与容器之间是完全决裂的。Docker在运行镜像的时候提供了映射容器端口到宿主主机、容器端口到另一个容器的网络互联功能，使得容器与宿主主机、容器与容器之间可以相互通信。</p>\n<h3 id=\"从外部访问容器应用\"><a href=\"#从外部访问容器应用\" class=\"headerlink\" title=\"从外部访问容器应用\"></a>从外部访问容器应用</h3><p>在启动容器的时候，如果不指定对应的参数，在容器外是无法通过网络来访问容器内的网络应用和服务的。当容器中运行一些需要被外部访问的网络应用时，可以通过-P或者-p参数来指定端口映射。当使用-P标记时，Docker会随机映射一个49000~49900的端口至容器内部开放的网络端口：</p>\n<pre><code>docker run -d -p [mirror ID or TAG]\n</code></pre>\n<p>使用-p （小写）则可以指定要映射的端口，并且在一个指定端口上只可以绑定一个容器。支持的格式有ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort。</p>\n<h4 id=\"映射所有接口地址\"><a href=\"#映射所有接口地址\" class=\"headerlink\" title=\"映射所有接口地址\"></a>映射所有接口地址</h4><p>使用hostPort:containerPort将本地的5000端口映射到容器的5000端口：</p>\n<pre><code>docker run -d -p 5000:5000 training/webapp python app.py\n</code></pre>\n<p>此时默认会绑定本地所有接口上的所有地址。多次使用-p标记可以绑定多个端口：</p>\n<pre><code>docker run -d -p 5000:5000 -p 3000:80 training/webapp python app.py\n</code></pre>\n<h4 id=\"映射到指定地址的指定端口\"><a href=\"#映射到指定地址的指定端口\" class=\"headerlink\" title=\"映射到指定地址的指定端口\"></a>映射到指定地址的指定端口</h4><p>可以使用ip:hostPort:containerPort格式指定映射使用一个特定地址，比如localhost地址127.0.0.1:</p>\n<pre><code>docker run -d -p 127.0.0.1:5000:5000 training/webapp python app.py\n</code></pre>\n<blockquote>\n<p>也可以是内部其它容器的IP地址。</p>\n</blockquote>\n<h4 id=\"映射到指定地址的任意端口\"><a href=\"#映射到指定地址的任意端口\" class=\"headerlink\" title=\"映射到指定地址的任意端口\"></a>映射到指定地址的任意端口</h4><p>使用ip::containerPort绑定localhost的任意端口到容器5000端口，本地主机会自动分配一个端口：</p>\n<pre><code>docker run -d -p 127.0.0.1::5000 training/webapp python app.py\n</code></pre>\n<p>还可以使用udp标记来指定udp端口：</p>\n<pre><code>docker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py\n</code></pre>\n<h4 id=\"查看映射端口配置\"><a href=\"#查看映射端口配置\" class=\"headerlink\" title=\"查看映射端口配置\"></a>查看映射端口配置</h4><p>使用docker port查看当前映射的端口配置，也可以查看到绑定的地址：</p>\n<pre><code>docker port nostalgic_morse 5000\n</code></pre>\n<blockquote>\n<p>容器有自己的内部网络和IP地址（使用docker inspect+容器ID可以获取所有的变量值）。</p>\n</blockquote>\n<h3 id=\"容器互联实现容器间的互通信\"><a href=\"#容器互联实现容器间的互通信\" class=\"headerlink\" title=\"容器互联实现容器间的互通信\"></a>容器互联实现容器间的互通信</h3><p>容器的连接系统是除了端口映射外另一种可以与容器中应用进行交互的方式。它会在源和接收容器之间创建一个隧道，接收容器可以看到源容器指定的信息。</p>\n<h4 id=\"自定义容器命名\"><a href=\"#自定义容器命名\" class=\"headerlink\" title=\"自定义容器命名\"></a>自定义容器命名</h4><p>连接系统依据容器的名称来执行。因此首先需要自定义一个好记的容器命名。<br>虽然当创建容器的时候，系统默认会分配一个名字，但自定义命名容器有两个好处：</p>\n<ul>\n<li>自定义的命名比较好记</li>\n<li>当要连接其它容器时，可以作为一个有用的参数点，比如连接web容器到db容器。</li>\n</ul>\n<p>使用–name标记可以为容器自定义命名：</p>\n<pre><code>docker run -d -p --name web training/webapp python app.py\n</code></pre>\n<p>使用docker ps可以查看命名，或者使用docker inspect来查看容器的名字：</p>\n<pre><code>docker inspect -f &quot;&#123;&#123;name&#125;&#125;&quot; [mirror ID]\n</code></pre>\n<blockquote>\n<p>容器的名称是唯一的，如果已经命名了一个叫web的容器，必须先用docker rm命令来删除这个容器，才能再以web这个名称创建新容器。</p>\n</blockquote>\n<p>容器互联</p>\n<p>使用–link参数可以让容器之间安全地进行交互。</p>\n<p>–link参数格式是–link name:alias，其中name是要链接容器的名称，alias是这个连接的别名。</p>\n<p>比如我们先创建一个新的数据库容器：</p>\n<pre><code>docker run -d --name db training/postgres\n</code></pre>\n<p>然后再创建一个web容器，并将它连接到db容器：</p>\n<pre><code>docker run -d -p --name web --link db:db training/webapp python app.py\n</code></pre>\n<p>这个时候db容器就与web容器可以互相通信了。可以使用docker ps来查看容器的连接。</p>\n<blockquote>\n<p>使用–link参数可以让Docker在两个容器之间通过一个安全的隧道互相通信，而不用通过开放端口的方式来实现，避免了把端口暴露到外部网络上。</p>\n</blockquote>\n<h4 id=\"查看公开容器的接连信息\"><a href=\"#查看公开容器的接连信息\" class=\"headerlink\" title=\"查看公开容器的接连信息\"></a>查看公开容器的接连信息</h4><ul>\n<li>环境变量：使用env命令来查看容器的环境变量</li>\n</ul>\n<pre><code>docker run --name web --link db:db training/webapp env\n</code></pre>\n<ul>\n<li>&#x2F;etc&#x2F;hosts文件：使用link参数时，Docker会添加host信息到父容器的&#x2F;etc&#x2F;hosts的文件。下面是父容器web的hosts文件</li>\n</ul>\n<pre><code>docker run -t -i --link db:db training/webapp /bin/bash\nroot@aed84ee21bd3:/opt/webapp# cat /etc/hosts\n127.17.0.7 aed84ee21bde\n...\n172.17.0.5 db\n</code></pre>\n<p>第一个是web容器的host信息，默认用自己的id为主机名。第二个是db容器的ip和主机名。</p>\n<hr>\n<h2 id=\"更多阅读\"><a href=\"#更多阅读\" class=\"headerlink\" title=\"更多阅读\"></a>更多阅读</h2><p>Docker系列文章：</p>\n<ol>\n<li><a href=\"https://juejin.im/post/5d8820cae51d453b1e478b91\">Docker中镜像、容器的常用命令</a></li>\n<li><a href=\"https://juejin.im/post/5d9f53d26fb9a04e3142120c\">Docker仓库常用命令</a></li>\n<li><a href=\"https://juejin.im/post/5d9f4f86e51d4577f3534ead\">Docker中容器的网络配置常用命令</a></li>\n</ol>\n"},{"title":"Docker中镜像、容器的常用命令","date":"2019-11-21T07:15:00.000Z","_content":"## 简述\n\n对于Docker来说整体还是比较容易入门的，理解起来跟虚拟机差不多，只要知道了镜像、容器的概念后，其他的就要考验Linux的知识了。\n\n要理解Docker以及Docker里关于镜像、容器的概念，这里打个比方：\nDocker就像一台支持软件多开的机子，Docker的镜像就像一个软件，Docker的容器就是这个软件多开时运行的窗口。每一个镜像都可以独立运行在不同的容器，他们互不干扰。下面简单列举以下有关镜像、容器的命令：\n\n## Docker镜像\n\n### 从网络上下截镜像\n\n```\ndocker pull [mirror] NAME[:TAG]\n```\n\n例如：\n\n```\ndocker pull ubuntu\n```\n\n如果不显式地指定TAG，则默认会选择latest标签，即下载最新版本的镜像。\n\n想要下载指定版本的镜像，则在后面指明版本号：\n\n```\ndocker pull ubuntu:14.04\n```\n\n也可以指明其它注册服务商的仓库地址下载对应的镜像：\n\n```\nC:\\Users\\kunta>docker pull hub.c.163.com/public/ubuntu:16.04-tools\n16.04-tools: Pulling from public/ubuntu\n[DEPRECATION NOTICE] registry v2 schema1 support will be removed in an upcoming release. Please contact admins of the hub.c.163.com registry NOW to avoid future disruption.\n8a2df099fc1a: Pull complete\n09aa8e119200: Pull complete\n21a4b8922479: Pull complete\na3ed95caeb02: Pull complete\nbd2a9dfe68fa: Pull complete\nf132d6d54cc2: Pull complete\n099b34b8b564: Pull complete\n23afed40f2e5: Pull complete\n6d60d1682f8c: Pull complete\n97121ecff7e5: Pull complete\nef4015576a84: Pull complete\n94d536c3a549: Pull complete\nDigest: sha256:0fc4a48462a92b0a5a53b35540b8ca33a68606c6cd23c21df54c5f54bccbf33a\nStatus: Downloaded newer image for hub.c.163.com/public/ubuntu:16.04-tools\nhub.c.163.com/public/ubuntu:16.04-tools\n```\n\n### 查看本地的存在的镜像\n\n查看本地镜像可以执行`docker images`命令：\n\n```\nC:\\Users\\kunta>docker images\nREPOSITORY                           TAG                 IMAGE ID            CREATED             SIZE\nhub.c.163.com/kuntang/lingermarket   latest              c7a70a3810cf        23 months ago       418MB\nhub.c.163.com/public/centos          6.7-tools           b2ab0ed558bb        2 years ago         602MB\n```\n\n其中各字段含义如下：\n\n- REPOSITORY：镜像来自哪一个仓库\n- TAG：镜像的标签信息\n- IMAGE ID：镜像的ID号(唯一)\n- CREATED：创建时间\n- SIZE：镜像大小\n\n![](https://user-gold-cdn.xitu.io/2019/10/10/16db635dd1090a6e?w=993&h=519&f=png&s=25613)\n\n### 给本地镜像添加新标签\n\n```\ndocker tag [mirror ID] [NEW TAG]\n```\n\n为方便使用，我们应该用`docker tag`命令为镜像加上别名；\n\n```\nC:\\Users\\kunta>docker tag 119 ubuntu\n\nC:\\Users\\kunta>docker images\nREPOSITORY                           TAG                 IMAGE ID            CREATED             SIZE\nhub.c.163.com/kuntang/lingermarket   latest              c7a70a3810cf        23 months ago       418MB\nubuntu                               latest              1196ea15dad6        2 years ago         336MB\nhub.c.163.com/public/ubuntu          16.04-tools         1196ea15dad6        2 years ago         336MB\nhub.c.163.com/public/centos          6.7-tools           b2ab0ed558bb        2 years ago         602MB\n```\n\n或：\n\n```\nC:\\Users\\kunta>docker tag hub.c.163.com/public/ubuntu:16.04-tools ubuntu2:16.04\n\nC:\\Users\\kunta>docker images\nREPOSITORY                           TAG                 IMAGE ID            CREATED             SIZE\nhub.c.163.com/kuntang/lingermarket   latest              c7a70a3810cf        23 months ago       418MB\nubuntu2                              16.04               1196ea15dad6        2 years ago         336MB\nubuntu                               latest              1196ea15dad6        2 years ago         336MB\nhub.c.163.com/public/ubuntu          16.04-tools         1196ea15dad6        2 years ago         336MB\nhub.c.163.com/public/centos          6.7-tools           b2ab0ed558bb        2 years ago         602MB\n```\n\n实际上这个命令不会创建新的镜像，仔细比较一下新创建的镜像，它们的ID都是一样的，所以它们指向的是同一个镜像，这里的tag命令相当于给它们新建了一个快捷方式。\n\n### 查看镜像详细信息\n\n```\ndocker inspect [IMAGE ID]\n```\n\n这个命令将会返回一串JSON字符串，如果想要查看某一项的内容，可以使用`-f`来指定。如：\n\n```\ndocker inspect -f {{\".[字段名]\"}} [IMAGE ID]\n```\n\n> 注意：**字段名**前的`.`不能少。\n\n如想要查看镜像的ID信息:\n\n```\nC:\\Users\\kunta>docker inspect -f {{\".Id\"}} 119\nsha256:1196ea15dad679677c220abedb654d7e8f4402c88fc1985ef1e224b50206d729\n```\n\n### 搜寻镜像\n\n```\ndocker search TERM \n```\n\n支持参数包括 `--automated=false` 仅显示自动创建的镜像 `--no-trunc=false` 输出信息不截断显示 `-s, --start=0` 仅显示评价为指定星级以上的镜像\n\n### 删除镜像\n\n```\ndocker rmi [IMAGES ID or TAG]\n```\n** 当一个镜像拥有多个标签的时候，执行删除命令只会删除镜像对应的标签，当镜像只剩下最后一个标签时执行删除操作，则会彻底删除镜像 **\n\n强制删除镜像\n\n```\ndocker rmi -f [mirrors]\n```\n\n### 创建镜像\n\n```\ndocker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]\n```\n\n### 上传镜像\n\n```\ndocker push NAME[:TAG]\n```\n\n## Docker容器\n\n### 创建容器\n\n创建成功后返回容器ID\n\n```\ndocker create [mirrors]\n```\n\n### 运行容器\n\n```\ndocker start [mirrors ID]\n```\n\n### 创建并运行容器\n\n```\ndocker run -i -t [mirrors ID] /bin/bash\n```\n\n`-t`选项让Docker分配一个伪终端(pseudo-tty)并绑定到容器的标准输入上，`-i`则让容器的标准输入保持打开。\n\n在交互模式下，用户可以通过所创建的终端来输入命令，例如：\n\n```\nC:\\Users\\kunta>docker run -i -t b2a /bin/bash\n[root@3eb81b9ab5ba /]# pwd\n/\n[root@3eb81b9ab5ba /]# ls\nbin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  sbin  selinux  srv  sys  tmp  usr  var\n```\n\n用户可以使用`Ctrl+D`或者输入`exit`来退出交互模式。\n\n### 守护态运行\n\n```\ndocker run -d [mirrors ID]\n```\n\n### 进入容器\n在使用-d参数时，容器启动后会进入后台，用户无法看到容器中的信息。某些时候如果需要进入容器操作，有多种方法，包括使用docker attach命令、docker exec命令，以及nsenter工具等。\n\n#### attach命令\n\n```\ndocker attach [mirrors ID]\n```\n\n使用attach命令有时候并不方便，当多个窗口同时attach到同一个容器时，所有窗口都会同步显示。当某个窗口因命令阻塞时，其它容器也无法执行操作了。\n\n#### exec命令\n\nDocker自1.3版本起，提供了一个更加方便的工具exec，可以直接在窗口内运行命令。例如进入到刚创建的容器中，并启动一个bash：\n\n```\ndocker exec -it [mirrors ID] /bin/bash\n```\n\n### 终止容器\n\n```\ndocker stop [mirrors ID]\n```\n\n### 重启已经停止的容器\n\n重新启动一个容器\n```\ndocker restart [mirrors ID]\n```\n\n### 查看当前容器列表\n\n```\n列出正在运行的容器\ndocker ps\n列出所有的容器\ndocker ps -a\n```\n\n### 导出容器\n\n```\ndocker export [mirrors ID] >[name].tar\n```\n\n### 导入容器\n\n```\ndocker import - [name]\n```\n\n---\n\n## 更多阅读\n\nDocker系列文章：\n\n1. [Docker中镜像、容器的常用命令](https://juejin.im/post/5d8820cae51d453b1e478b91)\n2. [Docker仓库常用命令](https://juejin.im/post/5d9f53d26fb9a04e3142120c)\n3. [Docker中容器的网络配置常用命令](https://juejin.im/post/5d9f4f86e51d4577f3534ead)","source":"_posts/Frequently-Used-Docker-Container-Or-Image-Command.md","raw":"title: Docker中镜像、容器的常用命令\ntags:\n  - 备忘翻阅\ncategories:\n  - Docker\n  - ''\ndate: 2019-11-21 15:15:00\n---\n## 简述\n\n对于Docker来说整体还是比较容易入门的，理解起来跟虚拟机差不多，只要知道了镜像、容器的概念后，其他的就要考验Linux的知识了。\n\n要理解Docker以及Docker里关于镜像、容器的概念，这里打个比方：\nDocker就像一台支持软件多开的机子，Docker的镜像就像一个软件，Docker的容器就是这个软件多开时运行的窗口。每一个镜像都可以独立运行在不同的容器，他们互不干扰。下面简单列举以下有关镜像、容器的命令：\n\n## Docker镜像\n\n### 从网络上下截镜像\n\n```\ndocker pull [mirror] NAME[:TAG]\n```\n\n例如：\n\n```\ndocker pull ubuntu\n```\n\n如果不显式地指定TAG，则默认会选择latest标签，即下载最新版本的镜像。\n\n想要下载指定版本的镜像，则在后面指明版本号：\n\n```\ndocker pull ubuntu:14.04\n```\n\n也可以指明其它注册服务商的仓库地址下载对应的镜像：\n\n```\nC:\\Users\\kunta>docker pull hub.c.163.com/public/ubuntu:16.04-tools\n16.04-tools: Pulling from public/ubuntu\n[DEPRECATION NOTICE] registry v2 schema1 support will be removed in an upcoming release. Please contact admins of the hub.c.163.com registry NOW to avoid future disruption.\n8a2df099fc1a: Pull complete\n09aa8e119200: Pull complete\n21a4b8922479: Pull complete\na3ed95caeb02: Pull complete\nbd2a9dfe68fa: Pull complete\nf132d6d54cc2: Pull complete\n099b34b8b564: Pull complete\n23afed40f2e5: Pull complete\n6d60d1682f8c: Pull complete\n97121ecff7e5: Pull complete\nef4015576a84: Pull complete\n94d536c3a549: Pull complete\nDigest: sha256:0fc4a48462a92b0a5a53b35540b8ca33a68606c6cd23c21df54c5f54bccbf33a\nStatus: Downloaded newer image for hub.c.163.com/public/ubuntu:16.04-tools\nhub.c.163.com/public/ubuntu:16.04-tools\n```\n\n### 查看本地的存在的镜像\n\n查看本地镜像可以执行`docker images`命令：\n\n```\nC:\\Users\\kunta>docker images\nREPOSITORY                           TAG                 IMAGE ID            CREATED             SIZE\nhub.c.163.com/kuntang/lingermarket   latest              c7a70a3810cf        23 months ago       418MB\nhub.c.163.com/public/centos          6.7-tools           b2ab0ed558bb        2 years ago         602MB\n```\n\n其中各字段含义如下：\n\n- REPOSITORY：镜像来自哪一个仓库\n- TAG：镜像的标签信息\n- IMAGE ID：镜像的ID号(唯一)\n- CREATED：创建时间\n- SIZE：镜像大小\n\n![](https://user-gold-cdn.xitu.io/2019/10/10/16db635dd1090a6e?w=993&h=519&f=png&s=25613)\n\n### 给本地镜像添加新标签\n\n```\ndocker tag [mirror ID] [NEW TAG]\n```\n\n为方便使用，我们应该用`docker tag`命令为镜像加上别名；\n\n```\nC:\\Users\\kunta>docker tag 119 ubuntu\n\nC:\\Users\\kunta>docker images\nREPOSITORY                           TAG                 IMAGE ID            CREATED             SIZE\nhub.c.163.com/kuntang/lingermarket   latest              c7a70a3810cf        23 months ago       418MB\nubuntu                               latest              1196ea15dad6        2 years ago         336MB\nhub.c.163.com/public/ubuntu          16.04-tools         1196ea15dad6        2 years ago         336MB\nhub.c.163.com/public/centos          6.7-tools           b2ab0ed558bb        2 years ago         602MB\n```\n\n或：\n\n```\nC:\\Users\\kunta>docker tag hub.c.163.com/public/ubuntu:16.04-tools ubuntu2:16.04\n\nC:\\Users\\kunta>docker images\nREPOSITORY                           TAG                 IMAGE ID            CREATED             SIZE\nhub.c.163.com/kuntang/lingermarket   latest              c7a70a3810cf        23 months ago       418MB\nubuntu2                              16.04               1196ea15dad6        2 years ago         336MB\nubuntu                               latest              1196ea15dad6        2 years ago         336MB\nhub.c.163.com/public/ubuntu          16.04-tools         1196ea15dad6        2 years ago         336MB\nhub.c.163.com/public/centos          6.7-tools           b2ab0ed558bb        2 years ago         602MB\n```\n\n实际上这个命令不会创建新的镜像，仔细比较一下新创建的镜像，它们的ID都是一样的，所以它们指向的是同一个镜像，这里的tag命令相当于给它们新建了一个快捷方式。\n\n### 查看镜像详细信息\n\n```\ndocker inspect [IMAGE ID]\n```\n\n这个命令将会返回一串JSON字符串，如果想要查看某一项的内容，可以使用`-f`来指定。如：\n\n```\ndocker inspect -f {{\".[字段名]\"}} [IMAGE ID]\n```\n\n> 注意：**字段名**前的`.`不能少。\n\n如想要查看镜像的ID信息:\n\n```\nC:\\Users\\kunta>docker inspect -f {{\".Id\"}} 119\nsha256:1196ea15dad679677c220abedb654d7e8f4402c88fc1985ef1e224b50206d729\n```\n\n### 搜寻镜像\n\n```\ndocker search TERM \n```\n\n支持参数包括 `--automated=false` 仅显示自动创建的镜像 `--no-trunc=false` 输出信息不截断显示 `-s, --start=0` 仅显示评价为指定星级以上的镜像\n\n### 删除镜像\n\n```\ndocker rmi [IMAGES ID or TAG]\n```\n** 当一个镜像拥有多个标签的时候，执行删除命令只会删除镜像对应的标签，当镜像只剩下最后一个标签时执行删除操作，则会彻底删除镜像 **\n\n强制删除镜像\n\n```\ndocker rmi -f [mirrors]\n```\n\n### 创建镜像\n\n```\ndocker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]\n```\n\n### 上传镜像\n\n```\ndocker push NAME[:TAG]\n```\n\n## Docker容器\n\n### 创建容器\n\n创建成功后返回容器ID\n\n```\ndocker create [mirrors]\n```\n\n### 运行容器\n\n```\ndocker start [mirrors ID]\n```\n\n### 创建并运行容器\n\n```\ndocker run -i -t [mirrors ID] /bin/bash\n```\n\n`-t`选项让Docker分配一个伪终端(pseudo-tty)并绑定到容器的标准输入上，`-i`则让容器的标准输入保持打开。\n\n在交互模式下，用户可以通过所创建的终端来输入命令，例如：\n\n```\nC:\\Users\\kunta>docker run -i -t b2a /bin/bash\n[root@3eb81b9ab5ba /]# pwd\n/\n[root@3eb81b9ab5ba /]# ls\nbin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  sbin  selinux  srv  sys  tmp  usr  var\n```\n\n用户可以使用`Ctrl+D`或者输入`exit`来退出交互模式。\n\n### 守护态运行\n\n```\ndocker run -d [mirrors ID]\n```\n\n### 进入容器\n在使用-d参数时，容器启动后会进入后台，用户无法看到容器中的信息。某些时候如果需要进入容器操作，有多种方法，包括使用docker attach命令、docker exec命令，以及nsenter工具等。\n\n#### attach命令\n\n```\ndocker attach [mirrors ID]\n```\n\n使用attach命令有时候并不方便，当多个窗口同时attach到同一个容器时，所有窗口都会同步显示。当某个窗口因命令阻塞时，其它容器也无法执行操作了。\n\n#### exec命令\n\nDocker自1.3版本起，提供了一个更加方便的工具exec，可以直接在窗口内运行命令。例如进入到刚创建的容器中，并启动一个bash：\n\n```\ndocker exec -it [mirrors ID] /bin/bash\n```\n\n### 终止容器\n\n```\ndocker stop [mirrors ID]\n```\n\n### 重启已经停止的容器\n\n重新启动一个容器\n```\ndocker restart [mirrors ID]\n```\n\n### 查看当前容器列表\n\n```\n列出正在运行的容器\ndocker ps\n列出所有的容器\ndocker ps -a\n```\n\n### 导出容器\n\n```\ndocker export [mirrors ID] >[name].tar\n```\n\n### 导入容器\n\n```\ndocker import - [name]\n```\n\n---\n\n## 更多阅读\n\nDocker系列文章：\n\n1. [Docker中镜像、容器的常用命令](https://juejin.im/post/5d8820cae51d453b1e478b91)\n2. [Docker仓库常用命令](https://juejin.im/post/5d9f53d26fb9a04e3142120c)\n3. [Docker中容器的网络配置常用命令](https://juejin.im/post/5d9f4f86e51d4577f3534ead)","slug":"Frequently-Used-Docker-Container-Or-Image-Command","published":1,"updated":"2023-04-11T03:30:27.110Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgbppeba000nbvch2vvr3b9n","content":"<h2><a href=\"#jian-shu\" class=\"header-anchor\"></a><span id=\"jian-shu\">简述</span></h2><p>对于Docker来说整体还是比较容易入门的，理解起来跟虚拟机差不多，只要知道了镜像、容器的概念后，其他的就要考验Linux的知识了。</p>\n<p>要理解Docker以及Docker里关于镜像、容器的概念，这里打个比方：<br>Docker就像一台支持软件多开的机子，Docker的镜像就像一个软件，Docker的容器就是这个软件多开时运行的窗口。每一个镜像都可以独立运行在不同的容器，他们互不干扰。下面简单列举以下有关镜像、容器的命令：</p>\n<h2><a href=\"#docker-jing-xiang\" class=\"header-anchor\"></a><span id=\"docker-jing-xiang\">Docker镜像</span></h2><h3><a href=\"#cong-wang-luo-shang-xia-jie-jing-xiang\" class=\"header-anchor\"></a><span id=\"cong-wang-luo-shang-xia-jie-jing-xiang\">从网络上下截镜像</span></h3><pre><code>docker pull [mirror] NAME[:TAG]\n</code></pre>\n<p>例如：</p>\n<pre><code>docker pull ubuntu\n</code></pre>\n<p>如果不显式地指定TAG，则默认会选择latest标签，即下载最新版本的镜像。</p>\n<p>想要下载指定版本的镜像，则在后面指明版本号：</p>\n<pre><code>docker pull ubuntu:14.04\n</code></pre>\n<p>也可以指明其它注册服务商的仓库地址下载对应的镜像：</p>\n<pre><code>C:\\Users\\kunta&gt;docker pull hub.c.163.com/public/ubuntu:16.04-tools\n16.04-tools: Pulling from public/ubuntu\n[DEPRECATION NOTICE] registry v2 schema1 support will be removed in an upcoming release. Please contact admins of the hub.c.163.com registry NOW to avoid future disruption.\n8a2df099fc1a: Pull complete\n09aa8e119200: Pull complete\n21a4b8922479: Pull complete\na3ed95caeb02: Pull complete\nbd2a9dfe68fa: Pull complete\nf132d6d54cc2: Pull complete\n099b34b8b564: Pull complete\n23afed40f2e5: Pull complete\n6d60d1682f8c: Pull complete\n97121ecff7e5: Pull complete\nef4015576a84: Pull complete\n94d536c3a549: Pull complete\nDigest: sha256:0fc4a48462a92b0a5a53b35540b8ca33a68606c6cd23c21df54c5f54bccbf33a\nStatus: Downloaded newer image for hub.c.163.com/public/ubuntu:16.04-tools\nhub.c.163.com/public/ubuntu:16.04-tools\n</code></pre>\n<h3><a href=\"#cha-kan-ben-di-de-cun-zai-de-jing-xiang\" class=\"header-anchor\"></a><span id=\"cha-kan-ben-di-de-cun-zai-de-jing-xiang\">查看本地的存在的镜像</span></h3><p>查看本地镜像可以执行<code>docker images</code>命令：</p>\n<pre><code>C:\\Users\\kunta&gt;docker images\nREPOSITORY                           TAG                 IMAGE ID            CREATED             SIZE\nhub.c.163.com/kuntang/lingermarket   latest              c7a70a3810cf        23 months ago       418MB\nhub.c.163.com/public/centos          6.7-tools           b2ab0ed558bb        2 years ago         602MB\n</code></pre>\n<p>其中各字段含义如下：</p>\n<ul>\n<li>REPOSITORY：镜像来自哪一个仓库</li>\n<li>TAG：镜像的标签信息</li>\n<li>IMAGE ID：镜像的ID号(唯一)</li>\n<li>CREATED：创建时间</li>\n<li>SIZE：镜像大小</li>\n</ul>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/10/10/16db635dd1090a6e?w=993&h=519&f=png&s=25613\"></p>\n<h3><a href=\"#gei-ben-di-jing-xiang-tian-jia-xin-biao-qian\" class=\"header-anchor\"></a><span id=\"gei-ben-di-jing-xiang-tian-jia-xin-biao-qian\">给本地镜像添加新标签</span></h3><pre><code>docker tag [mirror ID] [NEW TAG]\n</code></pre>\n<p>为方便使用，我们应该用<code>docker tag</code>命令为镜像加上别名；</p>\n<pre><code>C:\\Users\\kunta&gt;docker tag 119 ubuntu\n\nC:\\Users\\kunta&gt;docker images\nREPOSITORY                           TAG                 IMAGE ID            CREATED             SIZE\nhub.c.163.com/kuntang/lingermarket   latest              c7a70a3810cf        23 months ago       418MB\nubuntu                               latest              1196ea15dad6        2 years ago         336MB\nhub.c.163.com/public/ubuntu          16.04-tools         1196ea15dad6        2 years ago         336MB\nhub.c.163.com/public/centos          6.7-tools           b2ab0ed558bb        2 years ago         602MB\n</code></pre>\n<p>或：</p>\n<pre><code>C:\\Users\\kunta&gt;docker tag hub.c.163.com/public/ubuntu:16.04-tools ubuntu2:16.04\n\nC:\\Users\\kunta&gt;docker images\nREPOSITORY                           TAG                 IMAGE ID            CREATED             SIZE\nhub.c.163.com/kuntang/lingermarket   latest              c7a70a3810cf        23 months ago       418MB\nubuntu2                              16.04               1196ea15dad6        2 years ago         336MB\nubuntu                               latest              1196ea15dad6        2 years ago         336MB\nhub.c.163.com/public/ubuntu          16.04-tools         1196ea15dad6        2 years ago         336MB\nhub.c.163.com/public/centos          6.7-tools           b2ab0ed558bb        2 years ago         602MB\n</code></pre>\n<p>实际上这个命令不会创建新的镜像，仔细比较一下新创建的镜像，它们的ID都是一样的，所以它们指向的是同一个镜像，这里的tag命令相当于给它们新建了一个快捷方式。</p>\n<h3><a href=\"#cha-kan-jing-xiang-xiang-xi-xin-xi\" class=\"header-anchor\"></a><span id=\"cha-kan-jing-xiang-xiang-xi-xin-xi\">查看镜像详细信息</span></h3><pre><code>docker inspect [IMAGE ID]\n</code></pre>\n<p>这个命令将会返回一串JSON字符串，如果想要查看某一项的内容，可以使用<code>-f</code>来指定。如：</p>\n<pre><code>docker inspect -f &#123;&#123;\".[字段名]\"&#125;&#125; [IMAGE ID]\n</code></pre>\n<blockquote>\n<p>注意：<strong>字段名</strong>前的<code>.</code>不能少。</p>\n</blockquote>\n<p>如想要查看镜像的ID信息:</p>\n<pre><code>C:\\Users\\kunta&gt;docker inspect -f &#123;&#123;\".Id\"&#125;&#125; 119\nsha256:1196ea15dad679677c220abedb654d7e8f4402c88fc1985ef1e224b50206d729\n</code></pre>\n<h3><a href=\"#sou-xun-jing-xiang\" class=\"header-anchor\"></a><span id=\"sou-xun-jing-xiang\">搜寻镜像</span></h3><pre><code>docker search TERM \n</code></pre>\n<p>支持参数包括 <code>--automated=false</code> 仅显示自动创建的镜像 <code>--no-trunc=false</code> 输出信息不截断显示 <code>-s, --start=0</code> 仅显示评价为指定星级以上的镜像</p>\n<h3><a href=\"#shan-chu-jing-xiang\" class=\"header-anchor\"></a><span id=\"shan-chu-jing-xiang\">删除镜像</span></h3><pre><code>docker rmi [IMAGES ID or TAG]\n</code></pre>\n<p>** 当一个镜像拥有多个标签的时候，执行删除命令只会删除镜像对应的标签，当镜像只剩下最后一个标签时执行删除操作，则会彻底删除镜像 **</p>\n<p>强制删除镜像</p>\n<pre><code>docker rmi -f [mirrors]\n</code></pre>\n<h3><a href=\"#chuang-jian-jing-xiang\" class=\"header-anchor\"></a><span id=\"chuang-jian-jing-xiang\">创建镜像</span></h3><pre><code>docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]\n</code></pre>\n<h3><a href=\"#shang-chuan-jing-xiang\" class=\"header-anchor\"></a><span id=\"shang-chuan-jing-xiang\">上传镜像</span></h3><pre><code>docker push NAME[:TAG]\n</code></pre>\n<h2><a href=\"#docker-rong-qi\" class=\"header-anchor\"></a><span id=\"docker-rong-qi\">Docker容器</span></h2><h3><a href=\"#chuang-jian-rong-qi\" class=\"header-anchor\"></a><span id=\"chuang-jian-rong-qi\">创建容器</span></h3><p>创建成功后返回容器ID</p>\n<pre><code>docker create [mirrors]\n</code></pre>\n<h3><a href=\"#yun-xing-rong-qi\" class=\"header-anchor\"></a><span id=\"yun-xing-rong-qi\">运行容器</span></h3><pre><code>docker start [mirrors ID]\n</code></pre>\n<h3><a href=\"#chuang-jian-bing-yun-xing-rong-qi\" class=\"header-anchor\"></a><span id=\"chuang-jian-bing-yun-xing-rong-qi\">创建并运行容器</span></h3><pre><code>docker run -i -t [mirrors ID] /bin/bash\n</code></pre>\n<p><code>-t</code>选项让Docker分配一个伪终端(pseudo-tty)并绑定到容器的标准输入上，<code>-i</code>则让容器的标准输入保持打开。</p>\n<p>在交互模式下，用户可以通过所创建的终端来输入命令，例如：</p>\n<pre><code>C:\\Users\\kunta&gt;docker run -i -t b2a /bin/bash\n[root@3eb81b9ab5ba /]# pwd\n/\n[root@3eb81b9ab5ba /]# ls\nbin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  sbin  selinux  srv  sys  tmp  usr  var\n</code></pre>\n<p>用户可以使用<code>Ctrl+D</code>或者输入<code>exit</code>来退出交互模式。</p>\n<h3><a href=\"#shou-hu-tai-yun-xing\" class=\"header-anchor\"></a><span id=\"shou-hu-tai-yun-xing\">守护态运行</span></h3><pre><code>docker run -d [mirrors ID]\n</code></pre>\n<h3><a href=\"#jin-ru-rong-qi\" class=\"header-anchor\"></a><span id=\"jin-ru-rong-qi\">进入容器</span></h3><p>在使用-d参数时，容器启动后会进入后台，用户无法看到容器中的信息。某些时候如果需要进入容器操作，有多种方法，包括使用docker attach命令、docker exec命令，以及nsenter工具等。</p>\n<h4><a href=\"#attach-ming-ling\" class=\"header-anchor\"></a><span id=\"attach-ming-ling\">attach命令</span></h4><pre><code>docker attach [mirrors ID]\n</code></pre>\n<p>使用attach命令有时候并不方便，当多个窗口同时attach到同一个容器时，所有窗口都会同步显示。当某个窗口因命令阻塞时，其它容器也无法执行操作了。</p>\n<h4><a href=\"#exec-ming-ling\" class=\"header-anchor\"></a><span id=\"exec-ming-ling\">exec命令</span></h4><p>Docker自1.3版本起，提供了一个更加方便的工具exec，可以直接在窗口内运行命令。例如进入到刚创建的容器中，并启动一个bash：</p>\n<pre><code>docker exec -it [mirrors ID] /bin/bash\n</code></pre>\n<h3><a href=\"#zhong-zhi-rong-qi\" class=\"header-anchor\"></a><span id=\"zhong-zhi-rong-qi\">终止容器</span></h3><pre><code>docker stop [mirrors ID]\n</code></pre>\n<h3><a href=\"#chong-qi-yi-jing-ting-zhi-de-rong-qi\" class=\"header-anchor\"></a><span id=\"chong-qi-yi-jing-ting-zhi-de-rong-qi\">重启已经停止的容器</span></h3><p>重新启动一个容器</p>\n<pre><code>docker restart [mirrors ID]\n</code></pre>\n<h3><a href=\"#cha-kan-dang-qian-rong-qi-lie-biao\" class=\"header-anchor\"></a><span id=\"cha-kan-dang-qian-rong-qi-lie-biao\">查看当前容器列表</span></h3><pre><code>列出正在运行的容器\ndocker ps\n列出所有的容器\ndocker ps -a\n</code></pre>\n<h3><a href=\"#dao-chu-rong-qi\" class=\"header-anchor\"></a><span id=\"dao-chu-rong-qi\">导出容器</span></h3><pre><code>docker export [mirrors ID] &gt;[name].tar\n</code></pre>\n<h3><a href=\"#dao-ru-rong-qi\" class=\"header-anchor\"></a><span id=\"dao-ru-rong-qi\">导入容器</span></h3><pre><code>docker import - [name]\n</code></pre>\n<hr>\n<h2><a href=\"#geng-duo-yue-du\" class=\"header-anchor\"></a><span id=\"geng-duo-yue-du\">更多阅读</span></h2><p>Docker系列文章：</p>\n<ol>\n<li><a href=\"https://juejin.im/post/5d8820cae51d453b1e478b91\">Docker中镜像、容器的常用命令</a></li>\n<li><a href=\"https://juejin.im/post/5d9f53d26fb9a04e3142120c\">Docker仓库常用命令</a></li>\n<li><a href=\"https://juejin.im/post/5d9f4f86e51d4577f3534ead\">Docker中容器的网络配置常用命令</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"简述\"><a href=\"#简述\" class=\"headerlink\" title=\"简述\"></a>简述</h2><p>对于Docker来说整体还是比较容易入门的，理解起来跟虚拟机差不多，只要知道了镜像、容器的概念后，其他的就要考验Linux的知识了。</p>\n<p>要理解Docker以及Docker里关于镜像、容器的概念，这里打个比方：<br>Docker就像一台支持软件多开的机子，Docker的镜像就像一个软件，Docker的容器就是这个软件多开时运行的窗口。每一个镜像都可以独立运行在不同的容器，他们互不干扰。下面简单列举以下有关镜像、容器的命令：</p>\n<h2 id=\"Docker镜像\"><a href=\"#Docker镜像\" class=\"headerlink\" title=\"Docker镜像\"></a>Docker镜像</h2><h3 id=\"从网络上下截镜像\"><a href=\"#从网络上下截镜像\" class=\"headerlink\" title=\"从网络上下截镜像\"></a>从网络上下截镜像</h3><pre><code>docker pull [mirror] NAME[:TAG]\n</code></pre>\n<p>例如：</p>\n<pre><code>docker pull ubuntu\n</code></pre>\n<p>如果不显式地指定TAG，则默认会选择latest标签，即下载最新版本的镜像。</p>\n<p>想要下载指定版本的镜像，则在后面指明版本号：</p>\n<pre><code>docker pull ubuntu:14.04\n</code></pre>\n<p>也可以指明其它注册服务商的仓库地址下载对应的镜像：</p>\n<pre><code>C:\\Users\\kunta&gt;docker pull hub.c.163.com/public/ubuntu:16.04-tools\n16.04-tools: Pulling from public/ubuntu\n[DEPRECATION NOTICE] registry v2 schema1 support will be removed in an upcoming release. Please contact admins of the hub.c.163.com registry NOW to avoid future disruption.\n8a2df099fc1a: Pull complete\n09aa8e119200: Pull complete\n21a4b8922479: Pull complete\na3ed95caeb02: Pull complete\nbd2a9dfe68fa: Pull complete\nf132d6d54cc2: Pull complete\n099b34b8b564: Pull complete\n23afed40f2e5: Pull complete\n6d60d1682f8c: Pull complete\n97121ecff7e5: Pull complete\nef4015576a84: Pull complete\n94d536c3a549: Pull complete\nDigest: sha256:0fc4a48462a92b0a5a53b35540b8ca33a68606c6cd23c21df54c5f54bccbf33a\nStatus: Downloaded newer image for hub.c.163.com/public/ubuntu:16.04-tools\nhub.c.163.com/public/ubuntu:16.04-tools\n</code></pre>\n<h3 id=\"查看本地的存在的镜像\"><a href=\"#查看本地的存在的镜像\" class=\"headerlink\" title=\"查看本地的存在的镜像\"></a>查看本地的存在的镜像</h3><p>查看本地镜像可以执行<code>docker images</code>命令：</p>\n<pre><code>C:\\Users\\kunta&gt;docker images\nREPOSITORY                           TAG                 IMAGE ID            CREATED             SIZE\nhub.c.163.com/kuntang/lingermarket   latest              c7a70a3810cf        23 months ago       418MB\nhub.c.163.com/public/centos          6.7-tools           b2ab0ed558bb        2 years ago         602MB\n</code></pre>\n<p>其中各字段含义如下：</p>\n<ul>\n<li>REPOSITORY：镜像来自哪一个仓库</li>\n<li>TAG：镜像的标签信息</li>\n<li>IMAGE ID：镜像的ID号(唯一)</li>\n<li>CREATED：创建时间</li>\n<li>SIZE：镜像大小</li>\n</ul>\n<p><img src=\"https://user-gold-cdn.xitu.io/2019/10/10/16db635dd1090a6e?w=993&h=519&f=png&s=25613\"></p>\n<h3 id=\"给本地镜像添加新标签\"><a href=\"#给本地镜像添加新标签\" class=\"headerlink\" title=\"给本地镜像添加新标签\"></a>给本地镜像添加新标签</h3><pre><code>docker tag [mirror ID] [NEW TAG]\n</code></pre>\n<p>为方便使用，我们应该用<code>docker tag</code>命令为镜像加上别名；</p>\n<pre><code>C:\\Users\\kunta&gt;docker tag 119 ubuntu\n\nC:\\Users\\kunta&gt;docker images\nREPOSITORY                           TAG                 IMAGE ID            CREATED             SIZE\nhub.c.163.com/kuntang/lingermarket   latest              c7a70a3810cf        23 months ago       418MB\nubuntu                               latest              1196ea15dad6        2 years ago         336MB\nhub.c.163.com/public/ubuntu          16.04-tools         1196ea15dad6        2 years ago         336MB\nhub.c.163.com/public/centos          6.7-tools           b2ab0ed558bb        2 years ago         602MB\n</code></pre>\n<p>或：</p>\n<pre><code>C:\\Users\\kunta&gt;docker tag hub.c.163.com/public/ubuntu:16.04-tools ubuntu2:16.04\n\nC:\\Users\\kunta&gt;docker images\nREPOSITORY                           TAG                 IMAGE ID            CREATED             SIZE\nhub.c.163.com/kuntang/lingermarket   latest              c7a70a3810cf        23 months ago       418MB\nubuntu2                              16.04               1196ea15dad6        2 years ago         336MB\nubuntu                               latest              1196ea15dad6        2 years ago         336MB\nhub.c.163.com/public/ubuntu          16.04-tools         1196ea15dad6        2 years ago         336MB\nhub.c.163.com/public/centos          6.7-tools           b2ab0ed558bb        2 years ago         602MB\n</code></pre>\n<p>实际上这个命令不会创建新的镜像，仔细比较一下新创建的镜像，它们的ID都是一样的，所以它们指向的是同一个镜像，这里的tag命令相当于给它们新建了一个快捷方式。</p>\n<h3 id=\"查看镜像详细信息\"><a href=\"#查看镜像详细信息\" class=\"headerlink\" title=\"查看镜像详细信息\"></a>查看镜像详细信息</h3><pre><code>docker inspect [IMAGE ID]\n</code></pre>\n<p>这个命令将会返回一串JSON字符串，如果想要查看某一项的内容，可以使用<code>-f</code>来指定。如：</p>\n<pre><code>docker inspect -f &#123;&#123;\".[字段名]\"&#125;&#125; [IMAGE ID]\n</code></pre>\n<blockquote>\n<p>注意：<strong>字段名</strong>前的<code>.</code>不能少。</p>\n</blockquote>\n<p>如想要查看镜像的ID信息:</p>\n<pre><code>C:\\Users\\kunta&gt;docker inspect -f &#123;&#123;\".Id\"&#125;&#125; 119\nsha256:1196ea15dad679677c220abedb654d7e8f4402c88fc1985ef1e224b50206d729\n</code></pre>\n<h3 id=\"搜寻镜像\"><a href=\"#搜寻镜像\" class=\"headerlink\" title=\"搜寻镜像\"></a>搜寻镜像</h3><pre><code>docker search TERM \n</code></pre>\n<p>支持参数包括 <code>--automated=false</code> 仅显示自动创建的镜像 <code>--no-trunc=false</code> 输出信息不截断显示 <code>-s, --start=0</code> 仅显示评价为指定星级以上的镜像</p>\n<h3 id=\"删除镜像\"><a href=\"#删除镜像\" class=\"headerlink\" title=\"删除镜像\"></a>删除镜像</h3><pre><code>docker rmi [IMAGES ID or TAG]\n</code></pre>\n<p>** 当一个镜像拥有多个标签的时候，执行删除命令只会删除镜像对应的标签，当镜像只剩下最后一个标签时执行删除操作，则会彻底删除镜像 **</p>\n<p>强制删除镜像</p>\n<pre><code>docker rmi -f [mirrors]\n</code></pre>\n<h3 id=\"创建镜像\"><a href=\"#创建镜像\" class=\"headerlink\" title=\"创建镜像\"></a>创建镜像</h3><pre><code>docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]\n</code></pre>\n<h3 id=\"上传镜像\"><a href=\"#上传镜像\" class=\"headerlink\" title=\"上传镜像\"></a>上传镜像</h3><pre><code>docker push NAME[:TAG]\n</code></pre>\n<h2 id=\"Docker容器\"><a href=\"#Docker容器\" class=\"headerlink\" title=\"Docker容器\"></a>Docker容器</h2><h3 id=\"创建容器\"><a href=\"#创建容器\" class=\"headerlink\" title=\"创建容器\"></a>创建容器</h3><p>创建成功后返回容器ID</p>\n<pre><code>docker create [mirrors]\n</code></pre>\n<h3 id=\"运行容器\"><a href=\"#运行容器\" class=\"headerlink\" title=\"运行容器\"></a>运行容器</h3><pre><code>docker start [mirrors ID]\n</code></pre>\n<h3 id=\"创建并运行容器\"><a href=\"#创建并运行容器\" class=\"headerlink\" title=\"创建并运行容器\"></a>创建并运行容器</h3><pre><code>docker run -i -t [mirrors ID] /bin/bash\n</code></pre>\n<p><code>-t</code>选项让Docker分配一个伪终端(pseudo-tty)并绑定到容器的标准输入上，<code>-i</code>则让容器的标准输入保持打开。</p>\n<p>在交互模式下，用户可以通过所创建的终端来输入命令，例如：</p>\n<pre><code>C:\\Users\\kunta&gt;docker run -i -t b2a /bin/bash\n[root@3eb81b9ab5ba /]# pwd\n/\n[root@3eb81b9ab5ba /]# ls\nbin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  sbin  selinux  srv  sys  tmp  usr  var\n</code></pre>\n<p>用户可以使用<code>Ctrl+D</code>或者输入<code>exit</code>来退出交互模式。</p>\n<h3 id=\"守护态运行\"><a href=\"#守护态运行\" class=\"headerlink\" title=\"守护态运行\"></a>守护态运行</h3><pre><code>docker run -d [mirrors ID]\n</code></pre>\n<h3 id=\"进入容器\"><a href=\"#进入容器\" class=\"headerlink\" title=\"进入容器\"></a>进入容器</h3><p>在使用-d参数时，容器启动后会进入后台，用户无法看到容器中的信息。某些时候如果需要进入容器操作，有多种方法，包括使用docker attach命令、docker exec命令，以及nsenter工具等。</p>\n<h4 id=\"attach命令\"><a href=\"#attach命令\" class=\"headerlink\" title=\"attach命令\"></a>attach命令</h4><pre><code>docker attach [mirrors ID]\n</code></pre>\n<p>使用attach命令有时候并不方便，当多个窗口同时attach到同一个容器时，所有窗口都会同步显示。当某个窗口因命令阻塞时，其它容器也无法执行操作了。</p>\n<h4 id=\"exec命令\"><a href=\"#exec命令\" class=\"headerlink\" title=\"exec命令\"></a>exec命令</h4><p>Docker自1.3版本起，提供了一个更加方便的工具exec，可以直接在窗口内运行命令。例如进入到刚创建的容器中，并启动一个bash：</p>\n<pre><code>docker exec -it [mirrors ID] /bin/bash\n</code></pre>\n<h3 id=\"终止容器\"><a href=\"#终止容器\" class=\"headerlink\" title=\"终止容器\"></a>终止容器</h3><pre><code>docker stop [mirrors ID]\n</code></pre>\n<h3 id=\"重启已经停止的容器\"><a href=\"#重启已经停止的容器\" class=\"headerlink\" title=\"重启已经停止的容器\"></a>重启已经停止的容器</h3><p>重新启动一个容器</p>\n<pre><code>docker restart [mirrors ID]\n</code></pre>\n<h3 id=\"查看当前容器列表\"><a href=\"#查看当前容器列表\" class=\"headerlink\" title=\"查看当前容器列表\"></a>查看当前容器列表</h3><pre><code>列出正在运行的容器\ndocker ps\n列出所有的容器\ndocker ps -a\n</code></pre>\n<h3 id=\"导出容器\"><a href=\"#导出容器\" class=\"headerlink\" title=\"导出容器\"></a>导出容器</h3><pre><code>docker export [mirrors ID] &gt;[name].tar\n</code></pre>\n<h3 id=\"导入容器\"><a href=\"#导入容器\" class=\"headerlink\" title=\"导入容器\"></a>导入容器</h3><pre><code>docker import - [name]\n</code></pre>\n<hr>\n<h2 id=\"更多阅读\"><a href=\"#更多阅读\" class=\"headerlink\" title=\"更多阅读\"></a>更多阅读</h2><p>Docker系列文章：</p>\n<ol>\n<li><a href=\"https://juejin.im/post/5d8820cae51d453b1e478b91\">Docker中镜像、容器的常用命令</a></li>\n<li><a href=\"https://juejin.im/post/5d9f53d26fb9a04e3142120c\">Docker仓库常用命令</a></li>\n<li><a href=\"https://juejin.im/post/5d9f4f86e51d4577f3534ead\">Docker中容器的网络配置常用命令</a></li>\n</ol>\n"},{"title":"Git常用命令","date":"2019-11-21T06:29:00.000Z","_content":"<!-- toc -->\n\n# Git常用命令\n\n## 本地仓库\n\n本地仓库位于自己的电脑里，我们首先在本地编写好代码，然后提交到本地的仓库，但是这些代码仅仅只是在本地，还没推送到服务器上。一开始对于本地仓库的操作也仅仅只是影响本地，只有推送了才应用到服务器仓库。因此在推送到远端之前，可以很大胆地进行各种操作而不用担心会对远程仓库造成什么影响。\n\n### 初始化仓库(Init Repository)\n\n为一个项目初始化为git仓库。\n\n```bash\ngit init\n```\n\n### 克隆仓库(Clone Repository)\n\n把远端的一个仓库下载到本地。\n\n```bash\ngit clone [url]\n```\n\n### 暂存新文件(Stage New File) & 暂存文件修改(Sage Modified File)\n\n把新建的文件或者文件的新修改放到暂存区。\n\n```bash\ngit add [file]\n```\n\n### 取消刚刚新暂存的文件(Unstage New File)\n\n对于未追踪的文件，可以使用一下命令来取消文件暂存：\n\n```bash\ngit rm --cached <file>\n```\n\n### 取消刚刚暂存的文件修改(Unstage Modified File)\n\n对于已经在追踪（之前通过`git add`添加过）的文件，要想取消刚刚暂存的文件修改，可以使用以下命令：\n\n```bash\ngit reset HEAD <file>\n```\n\n### 查看仓库状态（Check Repository Status）\n\n```bash\ngit status\n```\n\n查看状态简览\n\n`git status -s` 或者 `git status --short`\n\n### 查看未暂存的修改(Check Unstaged Modified File)\n\n```bash\ngit diff\n```\n\n此命令比较的是工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后还没有暂存起来的变化内容。\n\n### 查看已暂存的修改(Check Staged Modified File)\n\n```bash\ngit diff --cached\n```\n\n或者\n\n```bash\ngit diff --staged // Git 1.6.1 及更高版本\n```\n\n### 提交更新(Commit File)\n\n在提交之前先要执行`git add `操作把文件放到暂存区。\n\n```bash\ngit commit\n```\n\n这种方式会启动文本编辑器以便输入本次提交的说明。也可以在`git commit`后面带上`-m`参数使得提交信息与命令放在同一行\n\n```bash\ngit commit -m \"\"\n```\n\n如果想跳过暂存区直接提交更新：\n\n```bash\ngit commit -a -m \"\"\n```\n\n`-a` 参数会自动执行`git add `步骤，把**所有已经跟踪过的文件暂存起来 **。\n\n### 移除文件\n\n要把文件不纳入仓库中的版本管理中，首先要从已追踪文件列表中移除，然后再提交。\n\n```\ngit rm <file>\n```\n\n执行后会发现本地的文件被删除了，并且把修改放到了暂存区，因此只要把暂存区里的更改提交就完成移除文件的操作。\n\n当要移除被本地修改过的文件，应该使用：\n\n```bash\n// 从暂存区里不追踪文件，但是本地保留文件\ngit rm --cache <file>\n```\n\n或者：\n\n```bash\n// 从暂存区里不追踪文件并在本地删除文件\ngit rm -f <file>\n```\n\n### 移动文件（删除文件）\n\n要在 Git 中对文件改名，可以这么做: \n\n```bash\ngit mv [old fileName] [new fileName]\n```\n\n执行后如图所示：\n\n51AE82F6-D51D-43CC-9C1D-919CCEA100E7.png\n![upload successful](/images/git_move_file.png)\n可以看到Git变更出现了一个R的操作，代表着rename。\n\n`git mv [old fileName] [new fileName]`可以分解成以下三个命令：\n\n```bash\nmv [old fileName] [new fileName]\ngit rm [old fileName]\ngit add [new fileName]\n```\n\n上面三行命令同样可以完成文件的重命名操作。\n\n**注意:在window系统中进行重命名要主要大小写问题，一般来说在window下git对文件大小写不敏感，需要在git全局设置`git config core.ignorecase false`才能检测得到。**\n\n> **Git 并不显式跟踪文件移动操作，因为Git是根据文件内容来推断文件是否有更改的，所以如果在 Git 中重命名了某个文件，仓库中存储的元数据 并不会体现出这是一次改名操作。** \n\n### 查看提交历史 \n\n使用`git log`命令查看项目仓库的提交历史，默认不用任何参数的话，git log会按提交时间列出所有的更新，最近的更新排在最上面 。\n\n```bash\ngit log\n```\n\n`git log`常用的参数有：\n\n- -p：显示每次提交的内容差异。\n\n- -<n>：仅显示最近n次提交 。\n\n- --stat：查每次提交的简略的统计信息 。\n\n-  --pretty：指定使用不同于默认格式的方式展示提交历史 。\n\n  - --pretty=oneline： 将每个提交放在一行显示 。\n\n  - --pretty=short ：显示提交的简要信息。\n\n  - --pretty=full：显示完全的信息。\n\n  - --pretty=fuller：显示全部的信息。\n\n  - --pretty=format ：可以定制要显示的记录格式（这样的输出对后期提取分析格外有用 ）。\n\n    对于`git log --pretty=format`常用的格式占位符以及其代表的含义如下表：\n    \n\n| 选项  | 说明                                   |\n| ---- | --------------------------------------|\n| %H   | 提交对象(commit)的完整哈希字串            |\n| %h   | 提交对象的简短哈希字串                    |\n| %T   | 树对象（tree）的完整哈希字串              |\n| %t   | 树对象的简短哈希字串                      |\n| %P   | 父对象（parent）的完整哈希字串            |\n| %p   | 父对象的简短哈希字串                      |\n| %an  | 作者（author）的名字                      |\n| %ae  | 作者的电子邮箱地址                        |\n| %ad  | 作者修订日期(可以用 --date= 选项定制格式) |\n| %ar  | 作者修订日期，按多久以前的方式显示        |\n| %cn  | 提交者(committer)的名字                   |\n| %ce  | 提交者的电子邮件地址                      |\n| %cd  | 提交日期                                  |\n| %cr  | 提交日期，按多久以前的方式显示            |\n| %s   | 提交说明                                  |\n\n\n    > *作者* 和 *提交者* 之间究竟有何差别？其实作者指的是实际作出修改的人，提交者指的是最后将此工作成果提交到仓库的人。所以，当你为某个项目发布补丁，然后某个核心成员将你的补丁并入项目时，你就是作者，而那个核心成员就是提交者。 \n\n- --graph： 添加一些ASCII字符串来形象地展示你的分支、合并历史。\n\n### 撤销操作\n\n如果在刚刚提交完后马上发现还有东西需要修改，或者漏掉文件需要提交，或者提交信息写错了，可以使用以下命令覆盖上一次的提交：\n\n```bash\ngit commit --amend\n// git commit -m 'do some thing'\n// git add README.md\n// git commit --amend\n```\n\n这个命令会将暂存区中的文件提交，并启动一个文本编辑器，在里面可以看到之前提交的信息，你可以在文本编辑器里修改。编辑后保存会覆盖原来的提交信息。\n\n#### 取消暂存的文件\n\n当你误将一个未完成的文件添加到缓存区是，可以使用下面命令来撤销暂存：\n\n```bash\ngit reset HEAD <file> ...\n// git reset HEAD READMD.md\n```\n\n使用该命令后，目标文件将会退回**修改未暂存**的状态。\n\n#### 撤销文件的修改（还原文件）\n\n如果你在编写代码的过程中，突然需要丢弃刚刚所做的更改（比如说产品说这个功能不用做了），那么可以使用下面命令来还原文件：\n\n```\ngit checkout -- <file>\n// git checkout -- README.md\n```\n\n> **上面的命令只能对还没放到暂存区里的文件进行还原，如果文件在暂存区，则需要先执行 取消暂存文件 的命令。**\n\n**撤销的修改不能恢复**，如需要恢复建议使用**分支**。\n\n## 远程仓库\n\n远程仓库位于服务器上，是保存我们代码和与其他协作组同步代码的地方。\n\n### 查看远程仓库\n\n```bash\ngit remote\n```\n\n它会列出你指定的每一个远程服务器 的简写。如果你已经克隆了自己的仓库，那么至少应该能看到 origin - 这是 Git 给你克隆的仓库服务器的默认名字。\n\n添加参数`-v`可以显示简写及对于的URL。\n\n> **Git不想传统的CSV，它是分布式的，这也说明了一个仓库可以对应多个远程仓库进行同步。这在某些项目环境下会有应用。**\n\n如果想查看某个远程仓库的详细信息，可以使用下面命令：\n\n```bash\ngit remote show [remote-name]\n// git remote show master\n```\n\n### 修改Git 仓库地址\n\n```bash\ngit remote set-url origin [NEW_URL]\n```\n\n### 重命名远程仓库\n\n如果想要重命名引用的名字可以运行git remote rename去修改一个远程仓库的简写名。例如，想要将pb重命名为paul，可以用git remote rename这样做:  \n\n```bash\ngit remote rename [old-branch-name] [new-branch-name]\n// git remote rename pb paul\n```\n\n### 移除远程仓库\n\n如果因为一些原因想要移除一个远程仓库 - 你已经从服务器上搬走了或不再想使用某一个特定的镜像了，又或者 某一个贡献者不再贡献了-可以使用git remote rm: \n\n```bash\ngit remote rm [branch-name]\n```\n\n\n\n### 添加远程仓库地址\n\n```bash\ngit remote add origin git@github.com:<username>/<projectName>.git\n// username是你在github里注册的用户名，projectName则是你远程仓库的项目名称\ngit push -u origin master\n```\n\n### 从远程仓库中抓取与拉取\n\n```bash\ngit fetch [remote-name]\n// git fetch origin\n```\n\n这个命令会访问远程仓库，从中拉取你还没有的数据（拉取本地还没有的所有分支代码），你也可以指定一个分支名来拉取指定分支代码。\n\n```bash\ngit fetch [remote-name] [branch-name]\n// git fetch origin master\n```\n\n但是不管怎么样，这个操作不会把拉取下来的代码自动合并到当前的工作区，而要你手动将其合并到你想要的分支。\n\n如果你使用 clone 命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 “origin” 为简写 。这是可以使用`git pull`命令来抓取远程分支的代码并自动合并到当前分支 。\n\n### 推送到远程仓库 \n\n想把本地的提交推送到远程仓库，可以使用下面命令：\n\n```bash\ngit push [remote-name] [branch-name]\n// git push origin master\n```\n\n## 标签\n\nGit 可以给历史中的某一个提交打上标签，以示重要。比较有代表性的是人 们会使用这个功能来标记发布结点(v1.0 等等) 。\n\n### 列出标签\n\n使用下面的命令列出所有标签：\n\n```bash\ngit tag\n```\n\n这个命令以字母顺序列出标签，但是它们出现的顺序并不重要。\n\n可以使用`-l`参数来查找特定的标签 ，例如像看1.8.5系列的标签，可以执行：\n\n```\ngit tag -l 'v1.8.5*'\n```\n\n### 创建标签\n\nGit有两种类型的标签：\n\n- 轻量标签（lightweight）\n- 附注标签（annotated）\n\n轻量标签就像一个不会改变的分支（它只是一个特定提交的引用）。\n\n附注标签则是存储在Git数据库的一个完整对象，他们是可以被校验的，其中包括打标签者的名字、电子邮件地址、日期时间。并且可以使用GNU Privacy Guard(GPG)签名与验证。\n\n通常建议创建附注标签，这样可以拥有以上所有信息。但如果只是一个临时的标签，或者因为某些原因不想保留那些信息，则可以使用轻量标签。\n\n#### 创建轻量标签\n\n使用git tag即可为commit创建一个标签：\n\n```bash\ngit tag [tag-name]\n```\n\n#### 创建附注标签\n\n在git tag后面添加-a 指定标签名称，-m 指定附加的信息：\n\n```bash\ngit tag -a [tag-name] -m [message]\n// git tag -a v1.4 -m 'annotated tag message'\n```\n\n#### 对提交打标签\n\n对于以往的一次提交打标签，可以在最末尾指定提交的commit id：\n\n```bash\n// 对以往的提交添加轻量标签\ngit tag [tag-name] [commit-id]\n// 对以往的提交添加附注标签\ngit tag -a [tag-name] -m [tag-message] [commit-id]\n// git tag v1.2 9fcea32\n// git tag -a v1.2 -m 'message' 9fcea32\n```\n\n#### 推送标签\n\n默认情况下，git push命令并不会传送标签到远程仓库服务器上。在创建完标签后你必须显式地推送标签到共享服务器上。\n\n```bash\ngit push origin [tagname]\n// git push origin v1.3\n```\n\n如果想要一次性推送很多标签，也可以使用带有--tags选项的git push命令。这将会把所有不在远程仓库服务器上的标签全部传送到那里。 \n\n```bash\ngit push origin --tags\n```\n\n#### 检出标签 \n\n在 Git 中你并不能真的检出一个标签，因为它们并不能像分支一样来回移动。如果你想要工作目录与仓库中特定的标签版本完全一样，可以使用`git checkout -b [branchname] [tagname]`在特定的标签上创建一个新分支: \n\n```bash\ngit checkout -b [branchname] [tagname]\n// git checkout -b devCopy v1.3\n```\n\n>  **如果在这之后又进行了一次提交，devCopy 分支会因为改动向前移动了，那么 devCopy 分支就会和 v1.3 标签稍微有些不同，这时就应该当心了。 **\n\n###  Git 别名 \n\nGit 并不会在你输入部分命令时自动推断出你想要的命令。如果不想每次都输入完整的 Git 命令，可以通过 git config 文件来轻松地为每一个命令设置一个别名。\n\n```bash\ngit config --global alias.[name] [command]\n// git config --global alias.co checkout\n// git config --global alias.br branch\n// git config --global alias.ci commit\n// git config --global alias.st status\n```\n\n这意味着，当要输入`git commit`时，只需要输入 `git ci`即可。\n\n添加一个取消暂存文件的快捷别名：\n\n```bash\ngit config --global alias.unstage 'reset HEAD --' \n// git unstage fileA 等于 git reset HEAD -- fileA\n```\n\n添加一个 last 别名 快速查看最后一次提交：\n\n```bash\ngit config --global alias.last 'log -1 HEAD'\n// git last 等于 git log -1 HEAD\n```","source":"_posts/Frequently-Used-Git-Command.md","raw":"title: Git常用命令\ntags:\n  - 备忘翻阅\ncategories:\n  - Git\ndate: 2019-11-21 14:29:00\n---\n<!-- toc -->\n\n# Git常用命令\n\n## 本地仓库\n\n本地仓库位于自己的电脑里，我们首先在本地编写好代码，然后提交到本地的仓库，但是这些代码仅仅只是在本地，还没推送到服务器上。一开始对于本地仓库的操作也仅仅只是影响本地，只有推送了才应用到服务器仓库。因此在推送到远端之前，可以很大胆地进行各种操作而不用担心会对远程仓库造成什么影响。\n\n### 初始化仓库(Init Repository)\n\n为一个项目初始化为git仓库。\n\n```bash\ngit init\n```\n\n### 克隆仓库(Clone Repository)\n\n把远端的一个仓库下载到本地。\n\n```bash\ngit clone [url]\n```\n\n### 暂存新文件(Stage New File) & 暂存文件修改(Sage Modified File)\n\n把新建的文件或者文件的新修改放到暂存区。\n\n```bash\ngit add [file]\n```\n\n### 取消刚刚新暂存的文件(Unstage New File)\n\n对于未追踪的文件，可以使用一下命令来取消文件暂存：\n\n```bash\ngit rm --cached <file>\n```\n\n### 取消刚刚暂存的文件修改(Unstage Modified File)\n\n对于已经在追踪（之前通过`git add`添加过）的文件，要想取消刚刚暂存的文件修改，可以使用以下命令：\n\n```bash\ngit reset HEAD <file>\n```\n\n### 查看仓库状态（Check Repository Status）\n\n```bash\ngit status\n```\n\n查看状态简览\n\n`git status -s` 或者 `git status --short`\n\n### 查看未暂存的修改(Check Unstaged Modified File)\n\n```bash\ngit diff\n```\n\n此命令比较的是工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后还没有暂存起来的变化内容。\n\n### 查看已暂存的修改(Check Staged Modified File)\n\n```bash\ngit diff --cached\n```\n\n或者\n\n```bash\ngit diff --staged // Git 1.6.1 及更高版本\n```\n\n### 提交更新(Commit File)\n\n在提交之前先要执行`git add `操作把文件放到暂存区。\n\n```bash\ngit commit\n```\n\n这种方式会启动文本编辑器以便输入本次提交的说明。也可以在`git commit`后面带上`-m`参数使得提交信息与命令放在同一行\n\n```bash\ngit commit -m \"\"\n```\n\n如果想跳过暂存区直接提交更新：\n\n```bash\ngit commit -a -m \"\"\n```\n\n`-a` 参数会自动执行`git add `步骤，把**所有已经跟踪过的文件暂存起来 **。\n\n### 移除文件\n\n要把文件不纳入仓库中的版本管理中，首先要从已追踪文件列表中移除，然后再提交。\n\n```\ngit rm <file>\n```\n\n执行后会发现本地的文件被删除了，并且把修改放到了暂存区，因此只要把暂存区里的更改提交就完成移除文件的操作。\n\n当要移除被本地修改过的文件，应该使用：\n\n```bash\n// 从暂存区里不追踪文件，但是本地保留文件\ngit rm --cache <file>\n```\n\n或者：\n\n```bash\n// 从暂存区里不追踪文件并在本地删除文件\ngit rm -f <file>\n```\n\n### 移动文件（删除文件）\n\n要在 Git 中对文件改名，可以这么做: \n\n```bash\ngit mv [old fileName] [new fileName]\n```\n\n执行后如图所示：\n\n51AE82F6-D51D-43CC-9C1D-919CCEA100E7.png\n![upload successful](/images/git_move_file.png)\n可以看到Git变更出现了一个R的操作，代表着rename。\n\n`git mv [old fileName] [new fileName]`可以分解成以下三个命令：\n\n```bash\nmv [old fileName] [new fileName]\ngit rm [old fileName]\ngit add [new fileName]\n```\n\n上面三行命令同样可以完成文件的重命名操作。\n\n**注意:在window系统中进行重命名要主要大小写问题，一般来说在window下git对文件大小写不敏感，需要在git全局设置`git config core.ignorecase false`才能检测得到。**\n\n> **Git 并不显式跟踪文件移动操作，因为Git是根据文件内容来推断文件是否有更改的，所以如果在 Git 中重命名了某个文件，仓库中存储的元数据 并不会体现出这是一次改名操作。** \n\n### 查看提交历史 \n\n使用`git log`命令查看项目仓库的提交历史，默认不用任何参数的话，git log会按提交时间列出所有的更新，最近的更新排在最上面 。\n\n```bash\ngit log\n```\n\n`git log`常用的参数有：\n\n- -p：显示每次提交的内容差异。\n\n- -<n>：仅显示最近n次提交 。\n\n- --stat：查每次提交的简略的统计信息 。\n\n-  --pretty：指定使用不同于默认格式的方式展示提交历史 。\n\n  - --pretty=oneline： 将每个提交放在一行显示 。\n\n  - --pretty=short ：显示提交的简要信息。\n\n  - --pretty=full：显示完全的信息。\n\n  - --pretty=fuller：显示全部的信息。\n\n  - --pretty=format ：可以定制要显示的记录格式（这样的输出对后期提取分析格外有用 ）。\n\n    对于`git log --pretty=format`常用的格式占位符以及其代表的含义如下表：\n    \n\n| 选项  | 说明                                   |\n| ---- | --------------------------------------|\n| %H   | 提交对象(commit)的完整哈希字串            |\n| %h   | 提交对象的简短哈希字串                    |\n| %T   | 树对象（tree）的完整哈希字串              |\n| %t   | 树对象的简短哈希字串                      |\n| %P   | 父对象（parent）的完整哈希字串            |\n| %p   | 父对象的简短哈希字串                      |\n| %an  | 作者（author）的名字                      |\n| %ae  | 作者的电子邮箱地址                        |\n| %ad  | 作者修订日期(可以用 --date= 选项定制格式) |\n| %ar  | 作者修订日期，按多久以前的方式显示        |\n| %cn  | 提交者(committer)的名字                   |\n| %ce  | 提交者的电子邮件地址                      |\n| %cd  | 提交日期                                  |\n| %cr  | 提交日期，按多久以前的方式显示            |\n| %s   | 提交说明                                  |\n\n\n    > *作者* 和 *提交者* 之间究竟有何差别？其实作者指的是实际作出修改的人，提交者指的是最后将此工作成果提交到仓库的人。所以，当你为某个项目发布补丁，然后某个核心成员将你的补丁并入项目时，你就是作者，而那个核心成员就是提交者。 \n\n- --graph： 添加一些ASCII字符串来形象地展示你的分支、合并历史。\n\n### 撤销操作\n\n如果在刚刚提交完后马上发现还有东西需要修改，或者漏掉文件需要提交，或者提交信息写错了，可以使用以下命令覆盖上一次的提交：\n\n```bash\ngit commit --amend\n// git commit -m 'do some thing'\n// git add README.md\n// git commit --amend\n```\n\n这个命令会将暂存区中的文件提交，并启动一个文本编辑器，在里面可以看到之前提交的信息，你可以在文本编辑器里修改。编辑后保存会覆盖原来的提交信息。\n\n#### 取消暂存的文件\n\n当你误将一个未完成的文件添加到缓存区是，可以使用下面命令来撤销暂存：\n\n```bash\ngit reset HEAD <file> ...\n// git reset HEAD READMD.md\n```\n\n使用该命令后，目标文件将会退回**修改未暂存**的状态。\n\n#### 撤销文件的修改（还原文件）\n\n如果你在编写代码的过程中，突然需要丢弃刚刚所做的更改（比如说产品说这个功能不用做了），那么可以使用下面命令来还原文件：\n\n```\ngit checkout -- <file>\n// git checkout -- README.md\n```\n\n> **上面的命令只能对还没放到暂存区里的文件进行还原，如果文件在暂存区，则需要先执行 取消暂存文件 的命令。**\n\n**撤销的修改不能恢复**，如需要恢复建议使用**分支**。\n\n## 远程仓库\n\n远程仓库位于服务器上，是保存我们代码和与其他协作组同步代码的地方。\n\n### 查看远程仓库\n\n```bash\ngit remote\n```\n\n它会列出你指定的每一个远程服务器 的简写。如果你已经克隆了自己的仓库，那么至少应该能看到 origin - 这是 Git 给你克隆的仓库服务器的默认名字。\n\n添加参数`-v`可以显示简写及对于的URL。\n\n> **Git不想传统的CSV，它是分布式的，这也说明了一个仓库可以对应多个远程仓库进行同步。这在某些项目环境下会有应用。**\n\n如果想查看某个远程仓库的详细信息，可以使用下面命令：\n\n```bash\ngit remote show [remote-name]\n// git remote show master\n```\n\n### 修改Git 仓库地址\n\n```bash\ngit remote set-url origin [NEW_URL]\n```\n\n### 重命名远程仓库\n\n如果想要重命名引用的名字可以运行git remote rename去修改一个远程仓库的简写名。例如，想要将pb重命名为paul，可以用git remote rename这样做:  \n\n```bash\ngit remote rename [old-branch-name] [new-branch-name]\n// git remote rename pb paul\n```\n\n### 移除远程仓库\n\n如果因为一些原因想要移除一个远程仓库 - 你已经从服务器上搬走了或不再想使用某一个特定的镜像了，又或者 某一个贡献者不再贡献了-可以使用git remote rm: \n\n```bash\ngit remote rm [branch-name]\n```\n\n\n\n### 添加远程仓库地址\n\n```bash\ngit remote add origin git@github.com:<username>/<projectName>.git\n// username是你在github里注册的用户名，projectName则是你远程仓库的项目名称\ngit push -u origin master\n```\n\n### 从远程仓库中抓取与拉取\n\n```bash\ngit fetch [remote-name]\n// git fetch origin\n```\n\n这个命令会访问远程仓库，从中拉取你还没有的数据（拉取本地还没有的所有分支代码），你也可以指定一个分支名来拉取指定分支代码。\n\n```bash\ngit fetch [remote-name] [branch-name]\n// git fetch origin master\n```\n\n但是不管怎么样，这个操作不会把拉取下来的代码自动合并到当前的工作区，而要你手动将其合并到你想要的分支。\n\n如果你使用 clone 命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 “origin” 为简写 。这是可以使用`git pull`命令来抓取远程分支的代码并自动合并到当前分支 。\n\n### 推送到远程仓库 \n\n想把本地的提交推送到远程仓库，可以使用下面命令：\n\n```bash\ngit push [remote-name] [branch-name]\n// git push origin master\n```\n\n## 标签\n\nGit 可以给历史中的某一个提交打上标签，以示重要。比较有代表性的是人 们会使用这个功能来标记发布结点(v1.0 等等) 。\n\n### 列出标签\n\n使用下面的命令列出所有标签：\n\n```bash\ngit tag\n```\n\n这个命令以字母顺序列出标签，但是它们出现的顺序并不重要。\n\n可以使用`-l`参数来查找特定的标签 ，例如像看1.8.5系列的标签，可以执行：\n\n```\ngit tag -l 'v1.8.5*'\n```\n\n### 创建标签\n\nGit有两种类型的标签：\n\n- 轻量标签（lightweight）\n- 附注标签（annotated）\n\n轻量标签就像一个不会改变的分支（它只是一个特定提交的引用）。\n\n附注标签则是存储在Git数据库的一个完整对象，他们是可以被校验的，其中包括打标签者的名字、电子邮件地址、日期时间。并且可以使用GNU Privacy Guard(GPG)签名与验证。\n\n通常建议创建附注标签，这样可以拥有以上所有信息。但如果只是一个临时的标签，或者因为某些原因不想保留那些信息，则可以使用轻量标签。\n\n#### 创建轻量标签\n\n使用git tag即可为commit创建一个标签：\n\n```bash\ngit tag [tag-name]\n```\n\n#### 创建附注标签\n\n在git tag后面添加-a 指定标签名称，-m 指定附加的信息：\n\n```bash\ngit tag -a [tag-name] -m [message]\n// git tag -a v1.4 -m 'annotated tag message'\n```\n\n#### 对提交打标签\n\n对于以往的一次提交打标签，可以在最末尾指定提交的commit id：\n\n```bash\n// 对以往的提交添加轻量标签\ngit tag [tag-name] [commit-id]\n// 对以往的提交添加附注标签\ngit tag -a [tag-name] -m [tag-message] [commit-id]\n// git tag v1.2 9fcea32\n// git tag -a v1.2 -m 'message' 9fcea32\n```\n\n#### 推送标签\n\n默认情况下，git push命令并不会传送标签到远程仓库服务器上。在创建完标签后你必须显式地推送标签到共享服务器上。\n\n```bash\ngit push origin [tagname]\n// git push origin v1.3\n```\n\n如果想要一次性推送很多标签，也可以使用带有--tags选项的git push命令。这将会把所有不在远程仓库服务器上的标签全部传送到那里。 \n\n```bash\ngit push origin --tags\n```\n\n#### 检出标签 \n\n在 Git 中你并不能真的检出一个标签，因为它们并不能像分支一样来回移动。如果你想要工作目录与仓库中特定的标签版本完全一样，可以使用`git checkout -b [branchname] [tagname]`在特定的标签上创建一个新分支: \n\n```bash\ngit checkout -b [branchname] [tagname]\n// git checkout -b devCopy v1.3\n```\n\n>  **如果在这之后又进行了一次提交，devCopy 分支会因为改动向前移动了，那么 devCopy 分支就会和 v1.3 标签稍微有些不同，这时就应该当心了。 **\n\n###  Git 别名 \n\nGit 并不会在你输入部分命令时自动推断出你想要的命令。如果不想每次都输入完整的 Git 命令，可以通过 git config 文件来轻松地为每一个命令设置一个别名。\n\n```bash\ngit config --global alias.[name] [command]\n// git config --global alias.co checkout\n// git config --global alias.br branch\n// git config --global alias.ci commit\n// git config --global alias.st status\n```\n\n这意味着，当要输入`git commit`时，只需要输入 `git ci`即可。\n\n添加一个取消暂存文件的快捷别名：\n\n```bash\ngit config --global alias.unstage 'reset HEAD --' \n// git unstage fileA 等于 git reset HEAD -- fileA\n```\n\n添加一个 last 别名 快速查看最后一次提交：\n\n```bash\ngit config --global alias.last 'log -1 HEAD'\n// git last 等于 git log -1 HEAD\n```","slug":"Frequently-Used-Git-Command","published":1,"updated":"2023-04-11T03:30:27.111Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgbppebb000sbvcheqx8b03q","content":"<div class=\"toc\">\n\n<!-- toc -->\n\n<ul>\n<li><a href=\"#git-chang-yong-ming-ling\">Git常用命令</a><ul>\n<li><a href=\"#ben-di-cang-ku\">本地仓库</a><ul>\n<li><a href=\"#chu-shi-hua-cang-ku-init-repository\">初始化仓库(Init Repository)</a></li>\n<li><a href=\"#ke-long-cang-ku-clone-repository\">克隆仓库(Clone Repository)</a></li>\n<li><a href=\"#zan-cun-xin-wen-jian-stage-new-file-zan-cun-wen-jian-xiu-gai-sage-modified-file\">暂存新文件(Stage New File) &amp; 暂存文件修改(Sage Modified File)</a></li>\n<li><a href=\"#qu-xiao-gang-gang-xin-zan-cun-de-wen-jian-unstage-new-file\">取消刚刚新暂存的文件(Unstage New File)</a></li>\n<li><a href=\"#qu-xiao-gang-gang-zan-cun-de-wen-jian-xiu-gai-unstage-modified-file\">取消刚刚暂存的文件修改(Unstage Modified File)</a></li>\n<li><a href=\"#cha-kan-cang-ku-zhuang-tai-check-repository-status\">查看仓库状态（Check Repository Status）</a></li>\n<li><a href=\"#cha-kan-wei-zan-cun-de-xiu-gai-check-unstaged-modified-file\">查看未暂存的修改(Check Unstaged Modified File)</a></li>\n<li><a href=\"#cha-kan-yi-zan-cun-de-xiu-gai-check-staged-modified-file\">查看已暂存的修改(Check Staged Modified File)</a></li>\n<li><a href=\"#ti-jiao-geng-xin-commit-file\">提交更新(Commit File)</a></li>\n<li><a href=\"#yi-chu-wen-jian\">移除文件</a></li>\n<li><a href=\"#yi-dong-wen-jian-shan-chu-wen-jian\">移动文件（删除文件）</a></li>\n<li><a href=\"#cha-kan-ti-jiao-li-shi\">查看提交历史</a></li>\n<li><a href=\"#che-xiao-cao-zuo\">撤销操作</a></li>\n</ul>\n</li>\n<li><a href=\"#yuan-cheng-cang-ku\">远程仓库</a><ul>\n<li><a href=\"#cha-kan-yuan-cheng-cang-ku\">查看远程仓库</a></li>\n<li><a href=\"#xiu-gai-git-cang-ku-di-zhi\">修改Git 仓库地址</a></li>\n<li><a href=\"#chong-ming-ming-yuan-cheng-cang-ku\">重命名远程仓库</a></li>\n<li><a href=\"#yi-chu-yuan-cheng-cang-ku\">移除远程仓库</a></li>\n<li><a href=\"#tian-jia-yuan-cheng-cang-ku-di-zhi\">添加远程仓库地址</a></li>\n<li><a href=\"#cong-yuan-cheng-cang-ku-zhong-zhua-qu-yu-la-qu\">从远程仓库中抓取与拉取</a></li>\n<li><a href=\"#tui-song-dao-yuan-cheng-cang-ku\">推送到远程仓库</a></li>\n</ul>\n</li>\n<li><a href=\"#biao-qian\">标签</a><ul>\n<li><a href=\"#lie-chu-biao-qian\">列出标签</a></li>\n<li><a href=\"#chuang-jian-biao-qian\">创建标签</a></li>\n<li><a href=\"#git-bie-ming\">Git 别名</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<!-- tocstop -->\n\n</div>\n\n<h1><a href=\"#git-chang-yong-ming-ling\" class=\"header-anchor\"></a><span id=\"git-chang-yong-ming-ling\">Git常用命令</span></h1><h2><a href=\"#ben-di-cang-ku\" class=\"header-anchor\"></a><span id=\"ben-di-cang-ku\">本地仓库</span></h2><p>本地仓库位于自己的电脑里，我们首先在本地编写好代码，然后提交到本地的仓库，但是这些代码仅仅只是在本地，还没推送到服务器上。一开始对于本地仓库的操作也仅仅只是影响本地，只有推送了才应用到服务器仓库。因此在推送到远端之前，可以很大胆地进行各种操作而不用担心会对远程仓库造成什么影响。</p>\n<h3><a href=\"#chu-shi-hua-cang-ku-init-repository\" class=\"header-anchor\"></a><span id=\"chu-shi-hua-cang-ku-init-repository\">初始化仓库(Init Repository)</span></h3><p>为一个项目初始化为git仓库。</p>\n<pre><code class=\"bash\">git init\n</code></pre>\n<h3><a href=\"#ke-long-cang-ku-clone-repository\" class=\"header-anchor\"></a><span id=\"ke-long-cang-ku-clone-repository\">克隆仓库(Clone Repository)</span></h3><p>把远端的一个仓库下载到本地。</p>\n<pre><code class=\"bash\">git clone [url]\n</code></pre>\n<h3><a href=\"#zan-cun-xin-wen-jian-stage-new-file-amp-zan-cun-wen-jian-xiu-gai-sage-modified-file\" class=\"header-anchor\"></a><span id=\"zan-cun-xin-wen-jian-stage-new-file-amp-zan-cun-wen-jian-xiu-gai-sage-modified-file\">暂存新文件(Stage New File) &amp; 暂存文件修改(Sage Modified File)</span></h3><p>把新建的文件或者文件的新修改放到暂存区。</p>\n<pre><code class=\"bash\">git add [file]\n</code></pre>\n<h3><a href=\"#qu-xiao-gang-gang-xin-zan-cun-de-wen-jian-unstage-new-file\" class=\"header-anchor\"></a><span id=\"qu-xiao-gang-gang-xin-zan-cun-de-wen-jian-unstage-new-file\">取消刚刚新暂存的文件(Unstage New File)</span></h3><p>对于未追踪的文件，可以使用一下命令来取消文件暂存：</p>\n<pre><code class=\"bash\">git rm --cached &lt;file&gt;\n</code></pre>\n<h3><a href=\"#qu-xiao-gang-gang-zan-cun-de-wen-jian-xiu-gai-unstage-modified-file\" class=\"header-anchor\"></a><span id=\"qu-xiao-gang-gang-zan-cun-de-wen-jian-xiu-gai-unstage-modified-file\">取消刚刚暂存的文件修改(Unstage Modified File)</span></h3><p>对于已经在追踪（之前通过<code>git add</code>添加过）的文件，要想取消刚刚暂存的文件修改，可以使用以下命令：</p>\n<pre><code class=\"bash\">git reset HEAD &lt;file&gt;\n</code></pre>\n<h3><a href=\"#cha-kan-cang-ku-zhuang-tai-check-repository-status\" class=\"header-anchor\"></a><span id=\"cha-kan-cang-ku-zhuang-tai-check-repository-status\">查看仓库状态（Check Repository Status）</span></h3><pre><code class=\"bash\">git status\n</code></pre>\n<p>查看状态简览</p>\n<p><code>git status -s</code> 或者 <code>git status --short</code></p>\n<h3><a href=\"#cha-kan-wei-zan-cun-de-xiu-gai-check-unstaged-modified-file\" class=\"header-anchor\"></a><span id=\"cha-kan-wei-zan-cun-de-xiu-gai-check-unstaged-modified-file\">查看未暂存的修改(Check Unstaged Modified File)</span></h3><pre><code class=\"bash\">git diff\n</code></pre>\n<p>此命令比较的是工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后还没有暂存起来的变化内容。</p>\n<h3><a href=\"#cha-kan-yi-zan-cun-de-xiu-gai-check-staged-modified-file\" class=\"header-anchor\"></a><span id=\"cha-kan-yi-zan-cun-de-xiu-gai-check-staged-modified-file\">查看已暂存的修改(Check Staged Modified File)</span></h3><pre><code class=\"bash\">git diff --cached\n</code></pre>\n<p>或者</p>\n<pre><code class=\"bash\">git diff --staged // Git 1.6.1 及更高版本\n</code></pre>\n<h3><a href=\"#ti-jiao-geng-xin-commit-file\" class=\"header-anchor\"></a><span id=\"ti-jiao-geng-xin-commit-file\">提交更新(Commit File)</span></h3><p>在提交之前先要执行<code>git add </code>操作把文件放到暂存区。</p>\n<pre><code class=\"bash\">git commit\n</code></pre>\n<p>这种方式会启动文本编辑器以便输入本次提交的说明。也可以在<code>git commit</code>后面带上<code>-m</code>参数使得提交信息与命令放在同一行</p>\n<pre><code class=\"bash\">git commit -m &quot;&quot;\n</code></pre>\n<p>如果想跳过暂存区直接提交更新：</p>\n<pre><code class=\"bash\">git commit -a -m &quot;&quot;\n</code></pre>\n<p><code>-a</code> 参数会自动执行<code>git add </code>步骤，把**所有已经跟踪过的文件暂存起来 **。</p>\n<h3><a href=\"#yi-chu-wen-jian\" class=\"header-anchor\"></a><span id=\"yi-chu-wen-jian\">移除文件</span></h3><p>要把文件不纳入仓库中的版本管理中，首先要从已追踪文件列表中移除，然后再提交。</p>\n<pre><code>git rm &lt;file&gt;\n</code></pre>\n<p>执行后会发现本地的文件被删除了，并且把修改放到了暂存区，因此只要把暂存区里的更改提交就完成移除文件的操作。</p>\n<p>当要移除被本地修改过的文件，应该使用：</p>\n<pre><code class=\"bash\">// 从暂存区里不追踪文件，但是本地保留文件\ngit rm --cache &lt;file&gt;\n</code></pre>\n<p>或者：</p>\n<pre><code class=\"bash\">// 从暂存区里不追踪文件并在本地删除文件\ngit rm -f &lt;file&gt;\n</code></pre>\n<h3><a href=\"#yi-dong-wen-jian-shan-chu-wen-jian\" class=\"header-anchor\"></a><span id=\"yi-dong-wen-jian-shan-chu-wen-jian\">移动文件（删除文件）</span></h3><p>要在 Git 中对文件改名，可以这么做: </p>\n<pre><code class=\"bash\">git mv [old fileName] [new fileName]\n</code></pre>\n<p>执行后如图所示：</p>\n<p>51AE82F6-D51D-43CC-9C1D-919CCEA100E7.png<br><img src=\"/images/git_move_file.png\" alt=\"upload successful\"><br>可以看到Git变更出现了一个R的操作，代表着rename。</p>\n<p><code>git mv [old fileName] [new fileName]</code>可以分解成以下三个命令：</p>\n<pre><code class=\"bash\">mv [old fileName] [new fileName]\ngit rm [old fileName]\ngit add [new fileName]\n</code></pre>\n<p>上面三行命令同样可以完成文件的重命名操作。</p>\n<p><strong>注意:在window系统中进行重命名要主要大小写问题，一般来说在window下git对文件大小写不敏感，需要在git全局设置<code>git config core.ignorecase false</code>才能检测得到。</strong></p>\n<blockquote>\n<p><strong>Git 并不显式跟踪文件移动操作，因为Git是根据文件内容来推断文件是否有更改的，所以如果在 Git 中重命名了某个文件，仓库中存储的元数据 并不会体现出这是一次改名操作。</strong> </p>\n</blockquote>\n<h3><a href=\"#cha-kan-ti-jiao-li-shi\" class=\"header-anchor\"></a><span id=\"cha-kan-ti-jiao-li-shi\">查看提交历史</span></h3><p>使用<code>git log</code>命令查看项目仓库的提交历史，默认不用任何参数的话，git log会按提交时间列出所有的更新，最近的更新排在最上面 。</p>\n<pre><code class=\"bash\">git log\n</code></pre>\n<p><code>git log</code>常用的参数有：</p>\n<ul>\n<li><p>-p：显示每次提交的内容差异。</p>\n</li>\n<li><p>-<n>：仅显示最近n次提交 。</n></p>\n</li>\n<li><p>–stat：查每次提交的简略的统计信息 。</p>\n</li>\n<li><p>–pretty：指定使用不同于默认格式的方式展示提交历史 。</p>\n</li>\n<li><p>–pretty&#x3D;oneline： 将每个提交放在一行显示 。</p>\n</li>\n<li><p>–pretty&#x3D;short ：显示提交的简要信息。</p>\n</li>\n<li><p>–pretty&#x3D;full：显示完全的信息。</p>\n</li>\n<li><p>–pretty&#x3D;fuller：显示全部的信息。</p>\n</li>\n<li><p>–pretty&#x3D;format ：可以定制要显示的记录格式（这样的输出对后期提取分析格外有用 ）。</p>\n<p>对于<code>git log --pretty=format</code>常用的格式占位符以及其代表的含义如下表：</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>%H</td>\n<td>提交对象(commit)的完整哈希字串</td>\n</tr>\n<tr>\n<td>%h</td>\n<td>提交对象的简短哈希字串</td>\n</tr>\n<tr>\n<td>%T</td>\n<td>树对象（tree）的完整哈希字串</td>\n</tr>\n<tr>\n<td>%t</td>\n<td>树对象的简短哈希字串</td>\n</tr>\n<tr>\n<td>%P</td>\n<td>父对象（parent）的完整哈希字串</td>\n</tr>\n<tr>\n<td>%p</td>\n<td>父对象的简短哈希字串</td>\n</tr>\n<tr>\n<td>%an</td>\n<td>作者（author）的名字</td>\n</tr>\n<tr>\n<td>%ae</td>\n<td>作者的电子邮箱地址</td>\n</tr>\n<tr>\n<td>%ad</td>\n<td>作者修订日期(可以用 –date&#x3D; 选项定制格式)</td>\n</tr>\n<tr>\n<td>%ar</td>\n<td>作者修订日期，按多久以前的方式显示</td>\n</tr>\n<tr>\n<td>%cn</td>\n<td>提交者(committer)的名字</td>\n</tr>\n<tr>\n<td>%ce</td>\n<td>提交者的电子邮件地址</td>\n</tr>\n<tr>\n<td>%cd</td>\n<td>提交日期</td>\n</tr>\n<tr>\n<td>%cr</td>\n<td>提交日期，按多久以前的方式显示</td>\n</tr>\n<tr>\n<td>%s</td>\n<td>提交说明</td>\n</tr>\n</tbody></table>\n<pre><code>&gt; *作者* 和 *提交者* 之间究竟有何差别？其实作者指的是实际作出修改的人，提交者指的是最后将此工作成果提交到仓库的人。所以，当你为某个项目发布补丁，然后某个核心成员将你的补丁并入项目时，你就是作者，而那个核心成员就是提交者。 \n</code></pre>\n<ul>\n<li>–graph： 添加一些ASCII字符串来形象地展示你的分支、合并历史。</li>\n</ul>\n<h3><a href=\"#che-xiao-cao-zuo\" class=\"header-anchor\"></a><span id=\"che-xiao-cao-zuo\">撤销操作</span></h3><p>如果在刚刚提交完后马上发现还有东西需要修改，或者漏掉文件需要提交，或者提交信息写错了，可以使用以下命令覆盖上一次的提交：</p>\n<pre><code class=\"bash\">git commit --amend\n// git commit -m &#39;do some thing&#39;\n// git add README.md\n// git commit --amend\n</code></pre>\n<p>这个命令会将暂存区中的文件提交，并启动一个文本编辑器，在里面可以看到之前提交的信息，你可以在文本编辑器里修改。编辑后保存会覆盖原来的提交信息。</p>\n<h4><a href=\"#qu-xiao-zan-cun-de-wen-jian\" class=\"header-anchor\"></a><span id=\"qu-xiao-zan-cun-de-wen-jian\">取消暂存的文件</span></h4><p>当你误将一个未完成的文件添加到缓存区是，可以使用下面命令来撤销暂存：</p>\n<pre><code class=\"bash\">git reset HEAD &lt;file&gt; ...\n// git reset HEAD READMD.md\n</code></pre>\n<p>使用该命令后，目标文件将会退回<strong>修改未暂存</strong>的状态。</p>\n<h4><a href=\"#che-xiao-wen-jian-de-xiu-gai-huan-yuan-wen-jian\" class=\"header-anchor\"></a><span id=\"che-xiao-wen-jian-de-xiu-gai-huan-yuan-wen-jian\">撤销文件的修改（还原文件）</span></h4><p>如果你在编写代码的过程中，突然需要丢弃刚刚所做的更改（比如说产品说这个功能不用做了），那么可以使用下面命令来还原文件：</p>\n<pre><code>git checkout -- &lt;file&gt;\n// git checkout -- README.md\n</code></pre>\n<blockquote>\n<p><strong>上面的命令只能对还没放到暂存区里的文件进行还原，如果文件在暂存区，则需要先执行 取消暂存文件 的命令。</strong></p>\n</blockquote>\n<p><strong>撤销的修改不能恢复</strong>，如需要恢复建议使用<strong>分支</strong>。</p>\n<h2><a href=\"#yuan-cheng-cang-ku\" class=\"header-anchor\"></a><span id=\"yuan-cheng-cang-ku\">远程仓库</span></h2><p>远程仓库位于服务器上，是保存我们代码和与其他协作组同步代码的地方。</p>\n<h3><a href=\"#cha-kan-yuan-cheng-cang-ku\" class=\"header-anchor\"></a><span id=\"cha-kan-yuan-cheng-cang-ku\">查看远程仓库</span></h3><pre><code class=\"bash\">git remote\n</code></pre>\n<p>它会列出你指定的每一个远程服务器 的简写。如果你已经克隆了自己的仓库，那么至少应该能看到 origin - 这是 Git 给你克隆的仓库服务器的默认名字。</p>\n<p>添加参数<code>-v</code>可以显示简写及对于的URL。</p>\n<blockquote>\n<p><strong>Git不想传统的CSV，它是分布式的，这也说明了一个仓库可以对应多个远程仓库进行同步。这在某些项目环境下会有应用。</strong></p>\n</blockquote>\n<p>如果想查看某个远程仓库的详细信息，可以使用下面命令：</p>\n<pre><code class=\"bash\">git remote show [remote-name]\n// git remote show master\n</code></pre>\n<h3><a href=\"#xiu-gai-git-cang-ku-di-zhi\" class=\"header-anchor\"></a><span id=\"xiu-gai-git-cang-ku-di-zhi\">修改Git 仓库地址</span></h3><pre><code class=\"bash\">git remote set-url origin [NEW_URL]\n</code></pre>\n<h3><a href=\"#chong-ming-ming-yuan-cheng-cang-ku\" class=\"header-anchor\"></a><span id=\"chong-ming-ming-yuan-cheng-cang-ku\">重命名远程仓库</span></h3><p>如果想要重命名引用的名字可以运行git remote rename去修改一个远程仓库的简写名。例如，想要将pb重命名为paul，可以用git remote rename这样做:  </p>\n<pre><code class=\"bash\">git remote rename [old-branch-name] [new-branch-name]\n// git remote rename pb paul\n</code></pre>\n<h3><a href=\"#yi-chu-yuan-cheng-cang-ku\" class=\"header-anchor\"></a><span id=\"yi-chu-yuan-cheng-cang-ku\">移除远程仓库</span></h3><p>如果因为一些原因想要移除一个远程仓库 - 你已经从服务器上搬走了或不再想使用某一个特定的镜像了，又或者 某一个贡献者不再贡献了-可以使用git remote rm: </p>\n<pre><code class=\"bash\">git remote rm [branch-name]\n</code></pre>\n<h3><a href=\"#tian-jia-yuan-cheng-cang-ku-di-zhi\" class=\"header-anchor\"></a><span id=\"tian-jia-yuan-cheng-cang-ku-di-zhi\">添加远程仓库地址</span></h3><pre><code class=\"bash\">git remote add origin git@github.com:&lt;username&gt;/&lt;projectName&gt;.git\n// username是你在github里注册的用户名，projectName则是你远程仓库的项目名称\ngit push -u origin master\n</code></pre>\n<h3><a href=\"#cong-yuan-cheng-cang-ku-zhong-zhua-qu-yu-la-qu\" class=\"header-anchor\"></a><span id=\"cong-yuan-cheng-cang-ku-zhong-zhua-qu-yu-la-qu\">从远程仓库中抓取与拉取</span></h3><pre><code class=\"bash\">git fetch [remote-name]\n// git fetch origin\n</code></pre>\n<p>这个命令会访问远程仓库，从中拉取你还没有的数据（拉取本地还没有的所有分支代码），你也可以指定一个分支名来拉取指定分支代码。</p>\n<pre><code class=\"bash\">git fetch [remote-name] [branch-name]\n// git fetch origin master\n</code></pre>\n<p>但是不管怎么样，这个操作不会把拉取下来的代码自动合并到当前的工作区，而要你手动将其合并到你想要的分支。</p>\n<p>如果你使用 clone 命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 “origin” 为简写 。这是可以使用<code>git pull</code>命令来抓取远程分支的代码并自动合并到当前分支 。</p>\n<h3><a href=\"#tui-song-dao-yuan-cheng-cang-ku\" class=\"header-anchor\"></a><span id=\"tui-song-dao-yuan-cheng-cang-ku\">推送到远程仓库</span></h3><p>想把本地的提交推送到远程仓库，可以使用下面命令：</p>\n<pre><code class=\"bash\">git push [remote-name] [branch-name]\n// git push origin master\n</code></pre>\n<h2><a href=\"#biao-qian\" class=\"header-anchor\"></a><span id=\"biao-qian\">标签</span></h2><p>Git 可以给历史中的某一个提交打上标签，以示重要。比较有代表性的是人 们会使用这个功能来标记发布结点(v1.0 等等) 。</p>\n<h3><a href=\"#lie-chu-biao-qian\" class=\"header-anchor\"></a><span id=\"lie-chu-biao-qian\">列出标签</span></h3><p>使用下面的命令列出所有标签：</p>\n<pre><code class=\"bash\">git tag\n</code></pre>\n<p>这个命令以字母顺序列出标签，但是它们出现的顺序并不重要。</p>\n<p>可以使用<code>-l</code>参数来查找特定的标签 ，例如像看1.8.5系列的标签，可以执行：</p>\n<pre><code>git tag -l &#39;v1.8.5*&#39;\n</code></pre>\n<h3><a href=\"#chuang-jian-biao-qian\" class=\"header-anchor\"></a><span id=\"chuang-jian-biao-qian\">创建标签</span></h3><p>Git有两种类型的标签：</p>\n<ul>\n<li>轻量标签（lightweight）</li>\n<li>附注标签（annotated）</li>\n</ul>\n<p>轻量标签就像一个不会改变的分支（它只是一个特定提交的引用）。</p>\n<p>附注标签则是存储在Git数据库的一个完整对象，他们是可以被校验的，其中包括打标签者的名字、电子邮件地址、日期时间。并且可以使用GNU Privacy Guard(GPG)签名与验证。</p>\n<p>通常建议创建附注标签，这样可以拥有以上所有信息。但如果只是一个临时的标签，或者因为某些原因不想保留那些信息，则可以使用轻量标签。</p>\n<h4><a href=\"#chuang-jian-qing-liang-biao-qian\" class=\"header-anchor\"></a><span id=\"chuang-jian-qing-liang-biao-qian\">创建轻量标签</span></h4><p>使用git tag即可为commit创建一个标签：</p>\n<pre><code class=\"bash\">git tag [tag-name]\n</code></pre>\n<h4><a href=\"#chuang-jian-fu-zhu-biao-qian\" class=\"header-anchor\"></a><span id=\"chuang-jian-fu-zhu-biao-qian\">创建附注标签</span></h4><p>在git tag后面添加-a 指定标签名称，-m 指定附加的信息：</p>\n<pre><code class=\"bash\">git tag -a [tag-name] -m [message]\n// git tag -a v1.4 -m &#39;annotated tag message&#39;\n</code></pre>\n<h4><a href=\"#dui-ti-jiao-da-biao-qian\" class=\"header-anchor\"></a><span id=\"dui-ti-jiao-da-biao-qian\">对提交打标签</span></h4><p>对于以往的一次提交打标签，可以在最末尾指定提交的commit id：</p>\n<pre><code class=\"bash\">// 对以往的提交添加轻量标签\ngit tag [tag-name] [commit-id]\n// 对以往的提交添加附注标签\ngit tag -a [tag-name] -m [tag-message] [commit-id]\n// git tag v1.2 9fcea32\n// git tag -a v1.2 -m &#39;message&#39; 9fcea32\n</code></pre>\n<h4><a href=\"#tui-song-biao-qian\" class=\"header-anchor\"></a><span id=\"tui-song-biao-qian\">推送标签</span></h4><p>默认情况下，git push命令并不会传送标签到远程仓库服务器上。在创建完标签后你必须显式地推送标签到共享服务器上。</p>\n<pre><code class=\"bash\">git push origin [tagname]\n// git push origin v1.3\n</code></pre>\n<p>如果想要一次性推送很多标签，也可以使用带有–tags选项的git push命令。这将会把所有不在远程仓库服务器上的标签全部传送到那里。 </p>\n<pre><code class=\"bash\">git push origin --tags\n</code></pre>\n<h4><a href=\"#jian-chu-biao-qian\" class=\"header-anchor\"></a><span id=\"jian-chu-biao-qian\">检出标签</span></h4><p>在 Git 中你并不能真的检出一个标签，因为它们并不能像分支一样来回移动。如果你想要工作目录与仓库中特定的标签版本完全一样，可以使用<code>git checkout -b [branchname] [tagname]</code>在特定的标签上创建一个新分支: </p>\n<pre><code class=\"bash\">git checkout -b [branchname] [tagname]\n// git checkout -b devCopy v1.3\n</code></pre>\n<blockquote>\n<p> **如果在这之后又进行了一次提交，devCopy 分支会因为改动向前移动了，那么 devCopy 分支就会和 v1.3 标签稍微有些不同，这时就应该当心了。 **</p>\n</blockquote>\n<h3><a href=\"#git-bie-ming\" class=\"header-anchor\"></a><span id=\"git-bie-ming\">Git 别名</span></h3><p>Git 并不会在你输入部分命令时自动推断出你想要的命令。如果不想每次都输入完整的 Git 命令，可以通过 git config 文件来轻松地为每一个命令设置一个别名。</p>\n<pre><code class=\"bash\">git config --global alias.[name] [command]\n// git config --global alias.co checkout\n// git config --global alias.br branch\n// git config --global alias.ci commit\n// git config --global alias.st status\n</code></pre>\n<p>这意味着，当要输入<code>git commit</code>时，只需要输入 <code>git ci</code>即可。</p>\n<p>添加一个取消暂存文件的快捷别名：</p>\n<pre><code class=\"bash\">git config --global alias.unstage &#39;reset HEAD --&#39; \n// git unstage fileA 等于 git reset HEAD -- fileA\n</code></pre>\n<p>添加一个 last 别名 快速查看最后一次提交：</p>\n<pre><code class=\"bash\">git config --global alias.last &#39;log -1 HEAD&#39;\n// git last 等于 git log -1 HEAD\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<div class=\"tocStart\"></div>\n\n<!-- toc -->\n\n<ul>\n<li><a href=\"#git-chang-yong-ming-ling\">Git常用命令</a><ul>\n<li><a href=\"#ben-di-cang-ku\">本地仓库</a><ul>\n<li><a href=\"#chu-shi-hua-cang-ku-init-repository\">初始化仓库(Init Repository)</a></li>\n<li><a href=\"#ke-long-cang-ku-clone-repository\">克隆仓库(Clone Repository)</a></li>\n<li><a href=\"#zan-cun-xin-wen-jian-stage-new-file-zan-cun-wen-jian-xiu-gai-sage-modified-file\">暂存新文件(Stage New File) &amp; 暂存文件修改(Sage Modified File)</a></li>\n<li><a href=\"#qu-xiao-gang-gang-xin-zan-cun-de-wen-jian-unstage-new-file\">取消刚刚新暂存的文件(Unstage New File)</a></li>\n<li><a href=\"#qu-xiao-gang-gang-zan-cun-de-wen-jian-xiu-gai-unstage-modified-file\">取消刚刚暂存的文件修改(Unstage Modified File)</a></li>\n<li><a href=\"#cha-kan-cang-ku-zhuang-tai-check-repository-status\">查看仓库状态（Check Repository Status）</a></li>\n<li><a href=\"#cha-kan-wei-zan-cun-de-xiu-gai-check-unstaged-modified-file\">查看未暂存的修改(Check Unstaged Modified File)</a></li>\n<li><a href=\"#cha-kan-yi-zan-cun-de-xiu-gai-check-staged-modified-file\">查看已暂存的修改(Check Staged Modified File)</a></li>\n<li><a href=\"#ti-jiao-geng-xin-commit-file\">提交更新(Commit File)</a></li>\n<li><a href=\"#yi-chu-wen-jian\">移除文件</a></li>\n<li><a href=\"#yi-dong-wen-jian-shan-chu-wen-jian\">移动文件（删除文件）</a></li>\n<li><a href=\"#cha-kan-ti-jiao-li-shi\">查看提交历史</a></li>\n<li><a href=\"#che-xiao-cao-zuo\">撤销操作</a></li>\n</ul>\n</li>\n<li><a href=\"#yuan-cheng-cang-ku\">远程仓库</a><ul>\n<li><a href=\"#cha-kan-yuan-cheng-cang-ku\">查看远程仓库</a></li>\n<li><a href=\"#xiu-gai-git-cang-ku-di-zhi\">修改Git 仓库地址</a></li>\n<li><a href=\"#chong-ming-ming-yuan-cheng-cang-ku\">重命名远程仓库</a></li>\n<li><a href=\"#yi-chu-yuan-cheng-cang-ku\">移除远程仓库</a></li>\n<li><a href=\"#tian-jia-yuan-cheng-cang-ku-di-zhi\">添加远程仓库地址</a></li>\n<li><a href=\"#cong-yuan-cheng-cang-ku-zhong-zhua-qu-yu-la-qu\">从远程仓库中抓取与拉取</a></li>\n<li><a href=\"#tui-song-dao-yuan-cheng-cang-ku\">推送到远程仓库</a></li>\n</ul>\n</li>\n<li><a href=\"#biao-qian\">标签</a><ul>\n<li><a href=\"#lie-chu-biao-qian\">列出标签</a></li>\n<li><a href=\"#chuang-jian-biao-qian\">创建标签</a></li>\n<li><a href=\"#git-bie-ming\">Git 别名</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<!-- tocstop -->\n\n<div class=\"tocEnd\"></div>\n\n<h1 id=\"Git常用命令\"><a href=\"#Git常用命令\" class=\"headerlink\" title=\"Git常用命令\"></a>Git常用命令</h1><h2 id=\"本地仓库\"><a href=\"#本地仓库\" class=\"headerlink\" title=\"本地仓库\"></a>本地仓库</h2><p>本地仓库位于自己的电脑里，我们首先在本地编写好代码，然后提交到本地的仓库，但是这些代码仅仅只是在本地，还没推送到服务器上。一开始对于本地仓库的操作也仅仅只是影响本地，只有推送了才应用到服务器仓库。因此在推送到远端之前，可以很大胆地进行各种操作而不用担心会对远程仓库造成什么影响。</p>\n<h3 id=\"初始化仓库-Init-Repository\"><a href=\"#初始化仓库-Init-Repository\" class=\"headerlink\" title=\"初始化仓库(Init Repository)\"></a>初始化仓库(Init Repository)</h3><p>为一个项目初始化为git仓库。</p>\n<pre><code class=\"bash\">git init\n</code></pre>\n<h3 id=\"克隆仓库-Clone-Repository\"><a href=\"#克隆仓库-Clone-Repository\" class=\"headerlink\" title=\"克隆仓库(Clone Repository)\"></a>克隆仓库(Clone Repository)</h3><p>把远端的一个仓库下载到本地。</p>\n<pre><code class=\"bash\">git clone [url]\n</code></pre>\n<h3 id=\"暂存新文件-Stage-New-File-amp-暂存文件修改-Sage-Modified-File\"><a href=\"#暂存新文件-Stage-New-File-amp-暂存文件修改-Sage-Modified-File\" class=\"headerlink\" title=\"暂存新文件(Stage New File) &amp; 暂存文件修改(Sage Modified File)\"></a>暂存新文件(Stage New File) &amp; 暂存文件修改(Sage Modified File)</h3><p>把新建的文件或者文件的新修改放到暂存区。</p>\n<pre><code class=\"bash\">git add [file]\n</code></pre>\n<h3 id=\"取消刚刚新暂存的文件-Unstage-New-File\"><a href=\"#取消刚刚新暂存的文件-Unstage-New-File\" class=\"headerlink\" title=\"取消刚刚新暂存的文件(Unstage New File)\"></a>取消刚刚新暂存的文件(Unstage New File)</h3><p>对于未追踪的文件，可以使用一下命令来取消文件暂存：</p>\n<pre><code class=\"bash\">git rm --cached &lt;file&gt;\n</code></pre>\n<h3 id=\"取消刚刚暂存的文件修改-Unstage-Modified-File\"><a href=\"#取消刚刚暂存的文件修改-Unstage-Modified-File\" class=\"headerlink\" title=\"取消刚刚暂存的文件修改(Unstage Modified File)\"></a>取消刚刚暂存的文件修改(Unstage Modified File)</h3><p>对于已经在追踪（之前通过<code>git add</code>添加过）的文件，要想取消刚刚暂存的文件修改，可以使用以下命令：</p>\n<pre><code class=\"bash\">git reset HEAD &lt;file&gt;\n</code></pre>\n<h3 id=\"查看仓库状态（Check-Repository-Status）\"><a href=\"#查看仓库状态（Check-Repository-Status）\" class=\"headerlink\" title=\"查看仓库状态（Check Repository Status）\"></a>查看仓库状态（Check Repository Status）</h3><pre><code class=\"bash\">git status\n</code></pre>\n<p>查看状态简览</p>\n<p><code>git status -s</code> 或者 <code>git status --short</code></p>\n<h3 id=\"查看未暂存的修改-Check-Unstaged-Modified-File\"><a href=\"#查看未暂存的修改-Check-Unstaged-Modified-File\" class=\"headerlink\" title=\"查看未暂存的修改(Check Unstaged Modified File)\"></a>查看未暂存的修改(Check Unstaged Modified File)</h3><pre><code class=\"bash\">git diff\n</code></pre>\n<p>此命令比较的是工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后还没有暂存起来的变化内容。</p>\n<h3 id=\"查看已暂存的修改-Check-Staged-Modified-File\"><a href=\"#查看已暂存的修改-Check-Staged-Modified-File\" class=\"headerlink\" title=\"查看已暂存的修改(Check Staged Modified File)\"></a>查看已暂存的修改(Check Staged Modified File)</h3><pre><code class=\"bash\">git diff --cached\n</code></pre>\n<p>或者</p>\n<pre><code class=\"bash\">git diff --staged // Git 1.6.1 及更高版本\n</code></pre>\n<h3 id=\"提交更新-Commit-File\"><a href=\"#提交更新-Commit-File\" class=\"headerlink\" title=\"提交更新(Commit File)\"></a>提交更新(Commit File)</h3><p>在提交之前先要执行<code>git add </code>操作把文件放到暂存区。</p>\n<pre><code class=\"bash\">git commit\n</code></pre>\n<p>这种方式会启动文本编辑器以便输入本次提交的说明。也可以在<code>git commit</code>后面带上<code>-m</code>参数使得提交信息与命令放在同一行</p>\n<pre><code class=\"bash\">git commit -m &quot;&quot;\n</code></pre>\n<p>如果想跳过暂存区直接提交更新：</p>\n<pre><code class=\"bash\">git commit -a -m &quot;&quot;\n</code></pre>\n<p><code>-a</code> 参数会自动执行<code>git add </code>步骤，把**所有已经跟踪过的文件暂存起来 **。</p>\n<h3 id=\"移除文件\"><a href=\"#移除文件\" class=\"headerlink\" title=\"移除文件\"></a>移除文件</h3><p>要把文件不纳入仓库中的版本管理中，首先要从已追踪文件列表中移除，然后再提交。</p>\n<pre><code>git rm &lt;file&gt;\n</code></pre>\n<p>执行后会发现本地的文件被删除了，并且把修改放到了暂存区，因此只要把暂存区里的更改提交就完成移除文件的操作。</p>\n<p>当要移除被本地修改过的文件，应该使用：</p>\n<pre><code class=\"bash\">// 从暂存区里不追踪文件，但是本地保留文件\ngit rm --cache &lt;file&gt;\n</code></pre>\n<p>或者：</p>\n<pre><code class=\"bash\">// 从暂存区里不追踪文件并在本地删除文件\ngit rm -f &lt;file&gt;\n</code></pre>\n<h3 id=\"移动文件（删除文件）\"><a href=\"#移动文件（删除文件）\" class=\"headerlink\" title=\"移动文件（删除文件）\"></a>移动文件（删除文件）</h3><p>要在 Git 中对文件改名，可以这么做: </p>\n<pre><code class=\"bash\">git mv [old fileName] [new fileName]\n</code></pre>\n<p>执行后如图所示：</p>\n<p>51AE82F6-D51D-43CC-9C1D-919CCEA100E7.png<br><img src=\"/images/git_move_file.png\" alt=\"upload successful\"><br>可以看到Git变更出现了一个R的操作，代表着rename。</p>\n<p><code>git mv [old fileName] [new fileName]</code>可以分解成以下三个命令：</p>\n<pre><code class=\"bash\">mv [old fileName] [new fileName]\ngit rm [old fileName]\ngit add [new fileName]\n</code></pre>\n<p>上面三行命令同样可以完成文件的重命名操作。</p>\n<p><strong>注意:在window系统中进行重命名要主要大小写问题，一般来说在window下git对文件大小写不敏感，需要在git全局设置<code>git config core.ignorecase false</code>才能检测得到。</strong></p>\n<blockquote>\n<p><strong>Git 并不显式跟踪文件移动操作，因为Git是根据文件内容来推断文件是否有更改的，所以如果在 Git 中重命名了某个文件，仓库中存储的元数据 并不会体现出这是一次改名操作。</strong> </p>\n</blockquote>\n<h3 id=\"查看提交历史\"><a href=\"#查看提交历史\" class=\"headerlink\" title=\"查看提交历史\"></a>查看提交历史</h3><p>使用<code>git log</code>命令查看项目仓库的提交历史，默认不用任何参数的话，git log会按提交时间列出所有的更新，最近的更新排在最上面 。</p>\n<pre><code class=\"bash\">git log\n</code></pre>\n<p><code>git log</code>常用的参数有：</p>\n<ul>\n<li><p>-p：显示每次提交的内容差异。</p>\n</li>\n<li><p>-<n>：仅显示最近n次提交 。</p>\n</li>\n<li><p>–stat：查每次提交的简略的统计信息 。</p>\n</li>\n<li><p>–pretty：指定使用不同于默认格式的方式展示提交历史 。</p>\n</li>\n<li><p>–pretty&#x3D;oneline： 将每个提交放在一行显示 。</p>\n</li>\n<li><p>–pretty&#x3D;short ：显示提交的简要信息。</p>\n</li>\n<li><p>–pretty&#x3D;full：显示完全的信息。</p>\n</li>\n<li><p>–pretty&#x3D;fuller：显示全部的信息。</p>\n</li>\n<li><p>–pretty&#x3D;format ：可以定制要显示的记录格式（这样的输出对后期提取分析格外有用 ）。</p>\n<p>对于<code>git log --pretty=format</code>常用的格式占位符以及其代表的含义如下表：</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>%H</td>\n<td>提交对象(commit)的完整哈希字串</td>\n</tr>\n<tr>\n<td>%h</td>\n<td>提交对象的简短哈希字串</td>\n</tr>\n<tr>\n<td>%T</td>\n<td>树对象（tree）的完整哈希字串</td>\n</tr>\n<tr>\n<td>%t</td>\n<td>树对象的简短哈希字串</td>\n</tr>\n<tr>\n<td>%P</td>\n<td>父对象（parent）的完整哈希字串</td>\n</tr>\n<tr>\n<td>%p</td>\n<td>父对象的简短哈希字串</td>\n</tr>\n<tr>\n<td>%an</td>\n<td>作者（author）的名字</td>\n</tr>\n<tr>\n<td>%ae</td>\n<td>作者的电子邮箱地址</td>\n</tr>\n<tr>\n<td>%ad</td>\n<td>作者修订日期(可以用 –date&#x3D; 选项定制格式)</td>\n</tr>\n<tr>\n<td>%ar</td>\n<td>作者修订日期，按多久以前的方式显示</td>\n</tr>\n<tr>\n<td>%cn</td>\n<td>提交者(committer)的名字</td>\n</tr>\n<tr>\n<td>%ce</td>\n<td>提交者的电子邮件地址</td>\n</tr>\n<tr>\n<td>%cd</td>\n<td>提交日期</td>\n</tr>\n<tr>\n<td>%cr</td>\n<td>提交日期，按多久以前的方式显示</td>\n</tr>\n<tr>\n<td>%s</td>\n<td>提交说明</td>\n</tr>\n</tbody></table>\n<pre><code>&gt; *作者* 和 *提交者* 之间究竟有何差别？其实作者指的是实际作出修改的人，提交者指的是最后将此工作成果提交到仓库的人。所以，当你为某个项目发布补丁，然后某个核心成员将你的补丁并入项目时，你就是作者，而那个核心成员就是提交者。 \n</code></pre>\n<ul>\n<li>–graph： 添加一些ASCII字符串来形象地展示你的分支、合并历史。</li>\n</ul>\n<h3 id=\"撤销操作\"><a href=\"#撤销操作\" class=\"headerlink\" title=\"撤销操作\"></a>撤销操作</h3><p>如果在刚刚提交完后马上发现还有东西需要修改，或者漏掉文件需要提交，或者提交信息写错了，可以使用以下命令覆盖上一次的提交：</p>\n<pre><code class=\"bash\">git commit --amend\n// git commit -m &#39;do some thing&#39;\n// git add README.md\n// git commit --amend\n</code></pre>\n<p>这个命令会将暂存区中的文件提交，并启动一个文本编辑器，在里面可以看到之前提交的信息，你可以在文本编辑器里修改。编辑后保存会覆盖原来的提交信息。</p>\n<h4 id=\"取消暂存的文件\"><a href=\"#取消暂存的文件\" class=\"headerlink\" title=\"取消暂存的文件\"></a>取消暂存的文件</h4><p>当你误将一个未完成的文件添加到缓存区是，可以使用下面命令来撤销暂存：</p>\n<pre><code class=\"bash\">git reset HEAD &lt;file&gt; ...\n// git reset HEAD READMD.md\n</code></pre>\n<p>使用该命令后，目标文件将会退回<strong>修改未暂存</strong>的状态。</p>\n<h4 id=\"撤销文件的修改（还原文件）\"><a href=\"#撤销文件的修改（还原文件）\" class=\"headerlink\" title=\"撤销文件的修改（还原文件）\"></a>撤销文件的修改（还原文件）</h4><p>如果你在编写代码的过程中，突然需要丢弃刚刚所做的更改（比如说产品说这个功能不用做了），那么可以使用下面命令来还原文件：</p>\n<pre><code>git checkout -- &lt;file&gt;\n// git checkout -- README.md\n</code></pre>\n<blockquote>\n<p><strong>上面的命令只能对还没放到暂存区里的文件进行还原，如果文件在暂存区，则需要先执行 取消暂存文件 的命令。</strong></p>\n</blockquote>\n<p><strong>撤销的修改不能恢复</strong>，如需要恢复建议使用<strong>分支</strong>。</p>\n<h2 id=\"远程仓库\"><a href=\"#远程仓库\" class=\"headerlink\" title=\"远程仓库\"></a>远程仓库</h2><p>远程仓库位于服务器上，是保存我们代码和与其他协作组同步代码的地方。</p>\n<h3 id=\"查看远程仓库\"><a href=\"#查看远程仓库\" class=\"headerlink\" title=\"查看远程仓库\"></a>查看远程仓库</h3><pre><code class=\"bash\">git remote\n</code></pre>\n<p>它会列出你指定的每一个远程服务器 的简写。如果你已经克隆了自己的仓库，那么至少应该能看到 origin - 这是 Git 给你克隆的仓库服务器的默认名字。</p>\n<p>添加参数<code>-v</code>可以显示简写及对于的URL。</p>\n<blockquote>\n<p><strong>Git不想传统的CSV，它是分布式的，这也说明了一个仓库可以对应多个远程仓库进行同步。这在某些项目环境下会有应用。</strong></p>\n</blockquote>\n<p>如果想查看某个远程仓库的详细信息，可以使用下面命令：</p>\n<pre><code class=\"bash\">git remote show [remote-name]\n// git remote show master\n</code></pre>\n<h3 id=\"修改Git-仓库地址\"><a href=\"#修改Git-仓库地址\" class=\"headerlink\" title=\"修改Git 仓库地址\"></a>修改Git 仓库地址</h3><pre><code class=\"bash\">git remote set-url origin [NEW_URL]\n</code></pre>\n<h3 id=\"重命名远程仓库\"><a href=\"#重命名远程仓库\" class=\"headerlink\" title=\"重命名远程仓库\"></a>重命名远程仓库</h3><p>如果想要重命名引用的名字可以运行git remote rename去修改一个远程仓库的简写名。例如，想要将pb重命名为paul，可以用git remote rename这样做:  </p>\n<pre><code class=\"bash\">git remote rename [old-branch-name] [new-branch-name]\n// git remote rename pb paul\n</code></pre>\n<h3 id=\"移除远程仓库\"><a href=\"#移除远程仓库\" class=\"headerlink\" title=\"移除远程仓库\"></a>移除远程仓库</h3><p>如果因为一些原因想要移除一个远程仓库 - 你已经从服务器上搬走了或不再想使用某一个特定的镜像了，又或者 某一个贡献者不再贡献了-可以使用git remote rm: </p>\n<pre><code class=\"bash\">git remote rm [branch-name]\n</code></pre>\n<h3 id=\"添加远程仓库地址\"><a href=\"#添加远程仓库地址\" class=\"headerlink\" title=\"添加远程仓库地址\"></a>添加远程仓库地址</h3><pre><code class=\"bash\">git remote add origin git@github.com:&lt;username&gt;/&lt;projectName&gt;.git\n// username是你在github里注册的用户名，projectName则是你远程仓库的项目名称\ngit push -u origin master\n</code></pre>\n<h3 id=\"从远程仓库中抓取与拉取\"><a href=\"#从远程仓库中抓取与拉取\" class=\"headerlink\" title=\"从远程仓库中抓取与拉取\"></a>从远程仓库中抓取与拉取</h3><pre><code class=\"bash\">git fetch [remote-name]\n// git fetch origin\n</code></pre>\n<p>这个命令会访问远程仓库，从中拉取你还没有的数据（拉取本地还没有的所有分支代码），你也可以指定一个分支名来拉取指定分支代码。</p>\n<pre><code class=\"bash\">git fetch [remote-name] [branch-name]\n// git fetch origin master\n</code></pre>\n<p>但是不管怎么样，这个操作不会把拉取下来的代码自动合并到当前的工作区，而要你手动将其合并到你想要的分支。</p>\n<p>如果你使用 clone 命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 “origin” 为简写 。这是可以使用<code>git pull</code>命令来抓取远程分支的代码并自动合并到当前分支 。</p>\n<h3 id=\"推送到远程仓库\"><a href=\"#推送到远程仓库\" class=\"headerlink\" title=\"推送到远程仓库\"></a>推送到远程仓库</h3><p>想把本地的提交推送到远程仓库，可以使用下面命令：</p>\n<pre><code class=\"bash\">git push [remote-name] [branch-name]\n// git push origin master\n</code></pre>\n<h2 id=\"标签\"><a href=\"#标签\" class=\"headerlink\" title=\"标签\"></a>标签</h2><p>Git 可以给历史中的某一个提交打上标签，以示重要。比较有代表性的是人 们会使用这个功能来标记发布结点(v1.0 等等) 。</p>\n<h3 id=\"列出标签\"><a href=\"#列出标签\" class=\"headerlink\" title=\"列出标签\"></a>列出标签</h3><p>使用下面的命令列出所有标签：</p>\n<pre><code class=\"bash\">git tag\n</code></pre>\n<p>这个命令以字母顺序列出标签，但是它们出现的顺序并不重要。</p>\n<p>可以使用<code>-l</code>参数来查找特定的标签 ，例如像看1.8.5系列的标签，可以执行：</p>\n<pre><code>git tag -l &#39;v1.8.5*&#39;\n</code></pre>\n<h3 id=\"创建标签\"><a href=\"#创建标签\" class=\"headerlink\" title=\"创建标签\"></a>创建标签</h3><p>Git有两种类型的标签：</p>\n<ul>\n<li>轻量标签（lightweight）</li>\n<li>附注标签（annotated）</li>\n</ul>\n<p>轻量标签就像一个不会改变的分支（它只是一个特定提交的引用）。</p>\n<p>附注标签则是存储在Git数据库的一个完整对象，他们是可以被校验的，其中包括打标签者的名字、电子邮件地址、日期时间。并且可以使用GNU Privacy Guard(GPG)签名与验证。</p>\n<p>通常建议创建附注标签，这样可以拥有以上所有信息。但如果只是一个临时的标签，或者因为某些原因不想保留那些信息，则可以使用轻量标签。</p>\n<h4 id=\"创建轻量标签\"><a href=\"#创建轻量标签\" class=\"headerlink\" title=\"创建轻量标签\"></a>创建轻量标签</h4><p>使用git tag即可为commit创建一个标签：</p>\n<pre><code class=\"bash\">git tag [tag-name]\n</code></pre>\n<h4 id=\"创建附注标签\"><a href=\"#创建附注标签\" class=\"headerlink\" title=\"创建附注标签\"></a>创建附注标签</h4><p>在git tag后面添加-a 指定标签名称，-m 指定附加的信息：</p>\n<pre><code class=\"bash\">git tag -a [tag-name] -m [message]\n// git tag -a v1.4 -m &#39;annotated tag message&#39;\n</code></pre>\n<h4 id=\"对提交打标签\"><a href=\"#对提交打标签\" class=\"headerlink\" title=\"对提交打标签\"></a>对提交打标签</h4><p>对于以往的一次提交打标签，可以在最末尾指定提交的commit id：</p>\n<pre><code class=\"bash\">// 对以往的提交添加轻量标签\ngit tag [tag-name] [commit-id]\n// 对以往的提交添加附注标签\ngit tag -a [tag-name] -m [tag-message] [commit-id]\n// git tag v1.2 9fcea32\n// git tag -a v1.2 -m &#39;message&#39; 9fcea32\n</code></pre>\n<h4 id=\"推送标签\"><a href=\"#推送标签\" class=\"headerlink\" title=\"推送标签\"></a>推送标签</h4><p>默认情况下，git push命令并不会传送标签到远程仓库服务器上。在创建完标签后你必须显式地推送标签到共享服务器上。</p>\n<pre><code class=\"bash\">git push origin [tagname]\n// git push origin v1.3\n</code></pre>\n<p>如果想要一次性推送很多标签，也可以使用带有–tags选项的git push命令。这将会把所有不在远程仓库服务器上的标签全部传送到那里。 </p>\n<pre><code class=\"bash\">git push origin --tags\n</code></pre>\n<h4 id=\"检出标签\"><a href=\"#检出标签\" class=\"headerlink\" title=\"检出标签\"></a>检出标签</h4><p>在 Git 中你并不能真的检出一个标签，因为它们并不能像分支一样来回移动。如果你想要工作目录与仓库中特定的标签版本完全一样，可以使用<code>git checkout -b [branchname] [tagname]</code>在特定的标签上创建一个新分支: </p>\n<pre><code class=\"bash\">git checkout -b [branchname] [tagname]\n// git checkout -b devCopy v1.3\n</code></pre>\n<blockquote>\n<p> **如果在这之后又进行了一次提交，devCopy 分支会因为改动向前移动了，那么 devCopy 分支就会和 v1.3 标签稍微有些不同，这时就应该当心了。 **</p>\n</blockquote>\n<h3 id=\"Git-别名\"><a href=\"#Git-别名\" class=\"headerlink\" title=\"Git 别名\"></a>Git 别名</h3><p>Git 并不会在你输入部分命令时自动推断出你想要的命令。如果不想每次都输入完整的 Git 命令，可以通过 git config 文件来轻松地为每一个命令设置一个别名。</p>\n<pre><code class=\"bash\">git config --global alias.[name] [command]\n// git config --global alias.co checkout\n// git config --global alias.br branch\n// git config --global alias.ci commit\n// git config --global alias.st status\n</code></pre>\n<p>这意味着，当要输入<code>git commit</code>时，只需要输入 <code>git ci</code>即可。</p>\n<p>添加一个取消暂存文件的快捷别名：</p>\n<pre><code class=\"bash\">git config --global alias.unstage &#39;reset HEAD --&#39; \n// git unstage fileA 等于 git reset HEAD -- fileA\n</code></pre>\n<p>添加一个 last 别名 快速查看最后一次提交：</p>\n<pre><code class=\"bash\">git config --global alias.last &#39;log -1 HEAD&#39;\n// git last 等于 git log -1 HEAD\n</code></pre>\n"},{"title":"Docker仓库常用命令","date":"2019-11-21T07:23:00.000Z","_content":"### 登录\n\n```\ndocker login\n```\n\n通过执行`docker login`命令来输入用户名、密码和邮箱来完成注册和登录。注册成功后，本地用户目录的`.dockercfg`中将保存着用户认证的信息。\n\n### 从仓库拉取镜像\n\n```\ndocker pull [镜像名]\n```\n\n### 搜索镜像\n\n```\ndocker search [想要搜索的镜像名]\n```\n\n例如：\n\n```\nC:\\Users\\kunta>docker search centos\nNAME                               DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED\ncentos                             The official build of CentOS.                   5605                [OK]             \nansible/centos7-ansible            Ansible on Centos7                              123                                     [OK]\njdeathe/centos-ssh                 OpenSSH / Supervisor / EPEL/IUS/SCL Repos - …   113                                     [OK]\nconsol/centos-xfce-vnc             Centos container with \"headless\" VNC session…   99                                      [OK]\ncentos/mysql-57-centos7            MySQL 5.7 SQL database server                   63                                   \nimagine10255/centos6-lnmp-php56    centos6-lnmp-php56                              57                                      [OK]\ntutum/centos                       Simple CentOS docker image with SSH access      45                                   \ncentos/postgresql-96-centos7       PostgreSQL is an advanced Object-Relational …   39                                  \nkinogmt/centos-ssh                 CentOS with SSH                                 29                                   \n```\n\n我们可以根据镜像是否为官方提供的依据，分为两类。一种是类似centos这样的基础镜像，称为基础或根镜像。这些镜像是由Docker公司创建、验证、支持、提供的。\n\n另外一种是类似`ansible/centos7-ansible`这样类型的镜像，它是由其它非官方的用户或组织提供的，一般是通过在基础镜像上添加了某些功能然后再提交发布上来供大家使用。像`ansible/centos7-ansible`这个镜像，它是由名为`ansible`这个用户或组织维护的，带有用户名为前缀，表明是某个用户的仓库。\n\n### 自动创建\n\n自动创建( Automated Builds)功能对于需要经常升级镜像内程序来说十分方便。有时候，用户创建了镜像，安装了某个软件，如果软件发布新版本则需要手动更新镜像。\n\n而自动创建功能使得用户通过DockerHub指定跟踪个目标网站(目前支持GitHub或BitBucket)上的项目，一旦项目发现新的提交，则自动执行创建。\n\n要配置自动创建，包括如下的步骤:\n1. 创建并登录Docker Hub, 以及目标网站; *在目标网站中连接帐户到Docker Hub。\n2. 在Docker Hub中配置一个 自动创建。\n3. 选取一个目标网站中的项目(需要含Dockerfile)和分支。\n4. 指定Dockerfile的位置，并提交创建。\n\n之后，可以在DockerHub的“自动创建\"页面中跟踪每次创建的状态。\n\n\n### 创建和使用私有仓库、\n\n安装Docker后，可以通过官方提供的registry镜像来简单搭建一-套本地私有仓库环境:\n\n```\ndocker run -d -p 5000:5000 registry\n```\n\n> docker run 命令执行时如果发现本地没有对应的镜像，则会先去拉取镜像再运行。\n\n默认情况下，会将仓库创建在容器的/tmp/registry目录下。可以通过-v参数来将镜像文件存放在本地的指定路径上。\n\n例如下面的例子将上传的镜像放到/opt/data/registry目录:\n\n```\ndocker run -d -p 5000:5000 -v /opt/data/registry:/tmp/registry registry \n```\n\n此时，在本地将启动- 个私有仓库服务，监听端口为5000。\n\n### 实战\n\n首先在一台服务器机子上搭建好私有仓库，其地址为10.0.2.2:5000。然后再试图从机子上上传和下载镜像。\n\n在本地上查看已有镜像：\n\n```\nC:\\Users\\kunta>docker images\nREPOSITORY                           TAG                 IMAGE ID            CREATED             SIZE\nhub.c.163.com/kuntang/lingermarket   latest              c7a70a3810cf        23 months ago       418MB\nubuntu2                              16.04               1196ea15dad6        2 years ago         336MB\nubuntu                               latest              1196ea15dad6        2 years ago         336MB\nhub.c.163.com/public/ubuntu          16.04-tools         1196ea15dad6        2 years ago         336MB\nhub.c.163.com/public/centos          6.7-tools           b2ab0ed558bb        2 years ago         602MB\n```\n\n使用`docker tag`命令把镜像的仓库标记为私有仓库机子地址（格式为：docker tag IMAGE[:TAG] [REGISTRYHOST/]NAME[:TAG]）：\n\n```\ndocker tag ubuntu2:16.04 10.0.2.2:5000/test\ndocker images\n\n```\n\n使用`docker push`命令上传镜像：\n\n```\ndocker push 10.0.2.2:5000/test\n```\n\n用`curl`查看私有仓库的镜像\n\n```\ncurl http://10.0.2.2:5000/v1/search\n```\n\n可以看出镜像已经上次成功。\n\n现在可以到任意一台能访问到10.0.2.2地址的机器去下载这个镜像了:\n\n```\ndocker pull 10.0.2.2:5000/test\n```\n\n---\n\n## 更多阅读\n\nDocker系列文章：\n\n1. [Docker中镜像、容器的常用命令](https://juejin.im/post/5d8820cae51d453b1e478b91)\n2. [Docker仓库常用命令](https://juejin.im/post/5d9f53d26fb9a04e3142120c)\n3. [Docker中容器的网络配置常用命令](https://juejin.im/post/5d9f4f86e51d4577f3534ead)","source":"_posts/Frequently-Used-Docker-Repository-Command.md","raw":"title: Docker仓库常用命令\ntags:\n  - 备忘翻阅\ncategories:\n  - Docker\ndate: 2019-11-21 15:23:00\n---\n### 登录\n\n```\ndocker login\n```\n\n通过执行`docker login`命令来输入用户名、密码和邮箱来完成注册和登录。注册成功后，本地用户目录的`.dockercfg`中将保存着用户认证的信息。\n\n### 从仓库拉取镜像\n\n```\ndocker pull [镜像名]\n```\n\n### 搜索镜像\n\n```\ndocker search [想要搜索的镜像名]\n```\n\n例如：\n\n```\nC:\\Users\\kunta>docker search centos\nNAME                               DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED\ncentos                             The official build of CentOS.                   5605                [OK]             \nansible/centos7-ansible            Ansible on Centos7                              123                                     [OK]\njdeathe/centos-ssh                 OpenSSH / Supervisor / EPEL/IUS/SCL Repos - …   113                                     [OK]\nconsol/centos-xfce-vnc             Centos container with \"headless\" VNC session…   99                                      [OK]\ncentos/mysql-57-centos7            MySQL 5.7 SQL database server                   63                                   \nimagine10255/centos6-lnmp-php56    centos6-lnmp-php56                              57                                      [OK]\ntutum/centos                       Simple CentOS docker image with SSH access      45                                   \ncentos/postgresql-96-centos7       PostgreSQL is an advanced Object-Relational …   39                                  \nkinogmt/centos-ssh                 CentOS with SSH                                 29                                   \n```\n\n我们可以根据镜像是否为官方提供的依据，分为两类。一种是类似centos这样的基础镜像，称为基础或根镜像。这些镜像是由Docker公司创建、验证、支持、提供的。\n\n另外一种是类似`ansible/centos7-ansible`这样类型的镜像，它是由其它非官方的用户或组织提供的，一般是通过在基础镜像上添加了某些功能然后再提交发布上来供大家使用。像`ansible/centos7-ansible`这个镜像，它是由名为`ansible`这个用户或组织维护的，带有用户名为前缀，表明是某个用户的仓库。\n\n### 自动创建\n\n自动创建( Automated Builds)功能对于需要经常升级镜像内程序来说十分方便。有时候，用户创建了镜像，安装了某个软件，如果软件发布新版本则需要手动更新镜像。\n\n而自动创建功能使得用户通过DockerHub指定跟踪个目标网站(目前支持GitHub或BitBucket)上的项目，一旦项目发现新的提交，则自动执行创建。\n\n要配置自动创建，包括如下的步骤:\n1. 创建并登录Docker Hub, 以及目标网站; *在目标网站中连接帐户到Docker Hub。\n2. 在Docker Hub中配置一个 自动创建。\n3. 选取一个目标网站中的项目(需要含Dockerfile)和分支。\n4. 指定Dockerfile的位置，并提交创建。\n\n之后，可以在DockerHub的“自动创建\"页面中跟踪每次创建的状态。\n\n\n### 创建和使用私有仓库、\n\n安装Docker后，可以通过官方提供的registry镜像来简单搭建一-套本地私有仓库环境:\n\n```\ndocker run -d -p 5000:5000 registry\n```\n\n> docker run 命令执行时如果发现本地没有对应的镜像，则会先去拉取镜像再运行。\n\n默认情况下，会将仓库创建在容器的/tmp/registry目录下。可以通过-v参数来将镜像文件存放在本地的指定路径上。\n\n例如下面的例子将上传的镜像放到/opt/data/registry目录:\n\n```\ndocker run -d -p 5000:5000 -v /opt/data/registry:/tmp/registry registry \n```\n\n此时，在本地将启动- 个私有仓库服务，监听端口为5000。\n\n### 实战\n\n首先在一台服务器机子上搭建好私有仓库，其地址为10.0.2.2:5000。然后再试图从机子上上传和下载镜像。\n\n在本地上查看已有镜像：\n\n```\nC:\\Users\\kunta>docker images\nREPOSITORY                           TAG                 IMAGE ID            CREATED             SIZE\nhub.c.163.com/kuntang/lingermarket   latest              c7a70a3810cf        23 months ago       418MB\nubuntu2                              16.04               1196ea15dad6        2 years ago         336MB\nubuntu                               latest              1196ea15dad6        2 years ago         336MB\nhub.c.163.com/public/ubuntu          16.04-tools         1196ea15dad6        2 years ago         336MB\nhub.c.163.com/public/centos          6.7-tools           b2ab0ed558bb        2 years ago         602MB\n```\n\n使用`docker tag`命令把镜像的仓库标记为私有仓库机子地址（格式为：docker tag IMAGE[:TAG] [REGISTRYHOST/]NAME[:TAG]）：\n\n```\ndocker tag ubuntu2:16.04 10.0.2.2:5000/test\ndocker images\n\n```\n\n使用`docker push`命令上传镜像：\n\n```\ndocker push 10.0.2.2:5000/test\n```\n\n用`curl`查看私有仓库的镜像\n\n```\ncurl http://10.0.2.2:5000/v1/search\n```\n\n可以看出镜像已经上次成功。\n\n现在可以到任意一台能访问到10.0.2.2地址的机器去下载这个镜像了:\n\n```\ndocker pull 10.0.2.2:5000/test\n```\n\n---\n\n## 更多阅读\n\nDocker系列文章：\n\n1. [Docker中镜像、容器的常用命令](https://juejin.im/post/5d8820cae51d453b1e478b91)\n2. [Docker仓库常用命令](https://juejin.im/post/5d9f53d26fb9a04e3142120c)\n3. [Docker中容器的网络配置常用命令](https://juejin.im/post/5d9f4f86e51d4577f3534ead)","slug":"Frequently-Used-Docker-Repository-Command","published":1,"updated":"2023-04-11T03:30:27.110Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgbppebb000ubvch42h8a5tp","content":"<h3><a href=\"#deng-lu\" class=\"header-anchor\"></a><span id=\"deng-lu\">登录</span></h3><pre><code>docker login\n</code></pre>\n<p>通过执行<code>docker login</code>命令来输入用户名、密码和邮箱来完成注册和登录。注册成功后，本地用户目录的<code>.dockercfg</code>中将保存着用户认证的信息。</p>\n<h3><a href=\"#cong-cang-ku-la-qu-jing-xiang\" class=\"header-anchor\"></a><span id=\"cong-cang-ku-la-qu-jing-xiang\">从仓库拉取镜像</span></h3><pre><code>docker pull [镜像名]\n</code></pre>\n<h3><a href=\"#sou-suo-jing-xiang\" class=\"header-anchor\"></a><span id=\"sou-suo-jing-xiang\">搜索镜像</span></h3><pre><code>docker search [想要搜索的镜像名]\n</code></pre>\n<p>例如：</p>\n<pre><code>C:\\Users\\kunta&gt;docker search centos\nNAME                               DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED\ncentos                             The official build of CentOS.                   5605                [OK]             \nansible/centos7-ansible            Ansible on Centos7                              123                                     [OK]\njdeathe/centos-ssh                 OpenSSH / Supervisor / EPEL/IUS/SCL Repos - …   113                                     [OK]\nconsol/centos-xfce-vnc             Centos container with &quot;headless&quot; VNC session…   99                                      [OK]\ncentos/mysql-57-centos7            MySQL 5.7 SQL database server                   63                                   \nimagine10255/centos6-lnmp-php56    centos6-lnmp-php56                              57                                      [OK]\ntutum/centos                       Simple CentOS docker image with SSH access      45                                   \ncentos/postgresql-96-centos7       PostgreSQL is an advanced Object-Relational …   39                                  \nkinogmt/centos-ssh                 CentOS with SSH                                 29                                   \n</code></pre>\n<p>我们可以根据镜像是否为官方提供的依据，分为两类。一种是类似centos这样的基础镜像，称为基础或根镜像。这些镜像是由Docker公司创建、验证、支持、提供的。</p>\n<p>另外一种是类似<code>ansible/centos7-ansible</code>这样类型的镜像，它是由其它非官方的用户或组织提供的，一般是通过在基础镜像上添加了某些功能然后再提交发布上来供大家使用。像<code>ansible/centos7-ansible</code>这个镜像，它是由名为<code>ansible</code>这个用户或组织维护的，带有用户名为前缀，表明是某个用户的仓库。</p>\n<h3><a href=\"#zi-dong-chuang-jian\" class=\"header-anchor\"></a><span id=\"zi-dong-chuang-jian\">自动创建</span></h3><p>自动创建( Automated Builds)功能对于需要经常升级镜像内程序来说十分方便。有时候，用户创建了镜像，安装了某个软件，如果软件发布新版本则需要手动更新镜像。</p>\n<p>而自动创建功能使得用户通过DockerHub指定跟踪个目标网站(目前支持GitHub或BitBucket)上的项目，一旦项目发现新的提交，则自动执行创建。</p>\n<p>要配置自动创建，包括如下的步骤:</p>\n<ol>\n<li>创建并登录Docker Hub, 以及目标网站; *在目标网站中连接帐户到Docker Hub。</li>\n<li>在Docker Hub中配置一个 自动创建。</li>\n<li>选取一个目标网站中的项目(需要含Dockerfile)和分支。</li>\n<li>指定Dockerfile的位置，并提交创建。</li>\n</ol>\n<p>之后，可以在DockerHub的“自动创建”页面中跟踪每次创建的状态。</p>\n<h3><a href=\"#chuang-jian-he-shi-yong-si-you-cang-ku\" class=\"header-anchor\"></a><span id=\"chuang-jian-he-shi-yong-si-you-cang-ku\">创建和使用私有仓库、</span></h3><p>安装Docker后，可以通过官方提供的registry镜像来简单搭建一-套本地私有仓库环境:</p>\n<pre><code>docker run -d -p 5000:5000 registry\n</code></pre>\n<blockquote>\n<p>docker run 命令执行时如果发现本地没有对应的镜像，则会先去拉取镜像再运行。</p>\n</blockquote>\n<p>默认情况下，会将仓库创建在容器的&#x2F;tmp&#x2F;registry目录下。可以通过-v参数来将镜像文件存放在本地的指定路径上。</p>\n<p>例如下面的例子将上传的镜像放到&#x2F;opt&#x2F;data&#x2F;registry目录:</p>\n<pre><code>docker run -d -p 5000:5000 -v /opt/data/registry:/tmp/registry registry \n</code></pre>\n<p>此时，在本地将启动- 个私有仓库服务，监听端口为5000。</p>\n<h3><a href=\"#shi-zhan\" class=\"header-anchor\"></a><span id=\"shi-zhan\">实战</span></h3><p>首先在一台服务器机子上搭建好私有仓库，其地址为10.0.2.2:5000。然后再试图从机子上上传和下载镜像。</p>\n<p>在本地上查看已有镜像：</p>\n<pre><code>C:\\Users\\kunta&gt;docker images\nREPOSITORY                           TAG                 IMAGE ID            CREATED             SIZE\nhub.c.163.com/kuntang/lingermarket   latest              c7a70a3810cf        23 months ago       418MB\nubuntu2                              16.04               1196ea15dad6        2 years ago         336MB\nubuntu                               latest              1196ea15dad6        2 years ago         336MB\nhub.c.163.com/public/ubuntu          16.04-tools         1196ea15dad6        2 years ago         336MB\nhub.c.163.com/public/centos          6.7-tools           b2ab0ed558bb        2 years ago         602MB\n</code></pre>\n<p>使用<code>docker tag</code>命令把镜像的仓库标记为私有仓库机子地址（格式为：docker tag IMAGE[:TAG] [REGISTRYHOST&#x2F;]NAME[:TAG]）：</p>\n<pre><code>docker tag ubuntu2:16.04 10.0.2.2:5000/test\ndocker images\n</code></pre>\n<p>使用<code>docker push</code>命令上传镜像：</p>\n<pre><code>docker push 10.0.2.2:5000/test\n</code></pre>\n<p>用<code>curl</code>查看私有仓库的镜像</p>\n<pre><code>curl http://10.0.2.2:5000/v1/search\n</code></pre>\n<p>可以看出镜像已经上次成功。</p>\n<p>现在可以到任意一台能访问到10.0.2.2地址的机器去下载这个镜像了:</p>\n<pre><code>docker pull 10.0.2.2:5000/test\n</code></pre>\n<hr>\n<h2><a href=\"#geng-duo-yue-du\" class=\"header-anchor\"></a><span id=\"geng-duo-yue-du\">更多阅读</span></h2><p>Docker系列文章：</p>\n<ol>\n<li><a href=\"https://juejin.im/post/5d8820cae51d453b1e478b91\">Docker中镜像、容器的常用命令</a></li>\n<li><a href=\"https://juejin.im/post/5d9f53d26fb9a04e3142120c\">Docker仓库常用命令</a></li>\n<li><a href=\"https://juejin.im/post/5d9f4f86e51d4577f3534ead\">Docker中容器的网络配置常用命令</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"登录\"><a href=\"#登录\" class=\"headerlink\" title=\"登录\"></a>登录</h3><pre><code>docker login\n</code></pre>\n<p>通过执行<code>docker login</code>命令来输入用户名、密码和邮箱来完成注册和登录。注册成功后，本地用户目录的<code>.dockercfg</code>中将保存着用户认证的信息。</p>\n<h3 id=\"从仓库拉取镜像\"><a href=\"#从仓库拉取镜像\" class=\"headerlink\" title=\"从仓库拉取镜像\"></a>从仓库拉取镜像</h3><pre><code>docker pull [镜像名]\n</code></pre>\n<h3 id=\"搜索镜像\"><a href=\"#搜索镜像\" class=\"headerlink\" title=\"搜索镜像\"></a>搜索镜像</h3><pre><code>docker search [想要搜索的镜像名]\n</code></pre>\n<p>例如：</p>\n<pre><code>C:\\Users\\kunta&gt;docker search centos\nNAME                               DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED\ncentos                             The official build of CentOS.                   5605                [OK]             \nansible/centos7-ansible            Ansible on Centos7                              123                                     [OK]\njdeathe/centos-ssh                 OpenSSH / Supervisor / EPEL/IUS/SCL Repos - …   113                                     [OK]\nconsol/centos-xfce-vnc             Centos container with &quot;headless&quot; VNC session…   99                                      [OK]\ncentos/mysql-57-centos7            MySQL 5.7 SQL database server                   63                                   \nimagine10255/centos6-lnmp-php56    centos6-lnmp-php56                              57                                      [OK]\ntutum/centos                       Simple CentOS docker image with SSH access      45                                   \ncentos/postgresql-96-centos7       PostgreSQL is an advanced Object-Relational …   39                                  \nkinogmt/centos-ssh                 CentOS with SSH                                 29                                   \n</code></pre>\n<p>我们可以根据镜像是否为官方提供的依据，分为两类。一种是类似centos这样的基础镜像，称为基础或根镜像。这些镜像是由Docker公司创建、验证、支持、提供的。</p>\n<p>另外一种是类似<code>ansible/centos7-ansible</code>这样类型的镜像，它是由其它非官方的用户或组织提供的，一般是通过在基础镜像上添加了某些功能然后再提交发布上来供大家使用。像<code>ansible/centos7-ansible</code>这个镜像，它是由名为<code>ansible</code>这个用户或组织维护的，带有用户名为前缀，表明是某个用户的仓库。</p>\n<h3 id=\"自动创建\"><a href=\"#自动创建\" class=\"headerlink\" title=\"自动创建\"></a>自动创建</h3><p>自动创建( Automated Builds)功能对于需要经常升级镜像内程序来说十分方便。有时候，用户创建了镜像，安装了某个软件，如果软件发布新版本则需要手动更新镜像。</p>\n<p>而自动创建功能使得用户通过DockerHub指定跟踪个目标网站(目前支持GitHub或BitBucket)上的项目，一旦项目发现新的提交，则自动执行创建。</p>\n<p>要配置自动创建，包括如下的步骤:</p>\n<ol>\n<li>创建并登录Docker Hub, 以及目标网站; *在目标网站中连接帐户到Docker Hub。</li>\n<li>在Docker Hub中配置一个 自动创建。</li>\n<li>选取一个目标网站中的项目(需要含Dockerfile)和分支。</li>\n<li>指定Dockerfile的位置，并提交创建。</li>\n</ol>\n<p>之后，可以在DockerHub的“自动创建”页面中跟踪每次创建的状态。</p>\n<h3 id=\"创建和使用私有仓库、\"><a href=\"#创建和使用私有仓库、\" class=\"headerlink\" title=\"创建和使用私有仓库、\"></a>创建和使用私有仓库、</h3><p>安装Docker后，可以通过官方提供的registry镜像来简单搭建一-套本地私有仓库环境:</p>\n<pre><code>docker run -d -p 5000:5000 registry\n</code></pre>\n<blockquote>\n<p>docker run 命令执行时如果发现本地没有对应的镜像，则会先去拉取镜像再运行。</p>\n</blockquote>\n<p>默认情况下，会将仓库创建在容器的&#x2F;tmp&#x2F;registry目录下。可以通过-v参数来将镜像文件存放在本地的指定路径上。</p>\n<p>例如下面的例子将上传的镜像放到&#x2F;opt&#x2F;data&#x2F;registry目录:</p>\n<pre><code>docker run -d -p 5000:5000 -v /opt/data/registry:/tmp/registry registry \n</code></pre>\n<p>此时，在本地将启动- 个私有仓库服务，监听端口为5000。</p>\n<h3 id=\"实战\"><a href=\"#实战\" class=\"headerlink\" title=\"实战\"></a>实战</h3><p>首先在一台服务器机子上搭建好私有仓库，其地址为10.0.2.2:5000。然后再试图从机子上上传和下载镜像。</p>\n<p>在本地上查看已有镜像：</p>\n<pre><code>C:\\Users\\kunta&gt;docker images\nREPOSITORY                           TAG                 IMAGE ID            CREATED             SIZE\nhub.c.163.com/kuntang/lingermarket   latest              c7a70a3810cf        23 months ago       418MB\nubuntu2                              16.04               1196ea15dad6        2 years ago         336MB\nubuntu                               latest              1196ea15dad6        2 years ago         336MB\nhub.c.163.com/public/ubuntu          16.04-tools         1196ea15dad6        2 years ago         336MB\nhub.c.163.com/public/centos          6.7-tools           b2ab0ed558bb        2 years ago         602MB\n</code></pre>\n<p>使用<code>docker tag</code>命令把镜像的仓库标记为私有仓库机子地址（格式为：docker tag IMAGE[:TAG] [REGISTRYHOST&#x2F;]NAME[:TAG]）：</p>\n<pre><code>docker tag ubuntu2:16.04 10.0.2.2:5000/test\ndocker images\n</code></pre>\n<p>使用<code>docker push</code>命令上传镜像：</p>\n<pre><code>docker push 10.0.2.2:5000/test\n</code></pre>\n<p>用<code>curl</code>查看私有仓库的镜像</p>\n<pre><code>curl http://10.0.2.2:5000/v1/search\n</code></pre>\n<p>可以看出镜像已经上次成功。</p>\n<p>现在可以到任意一台能访问到10.0.2.2地址的机器去下载这个镜像了:</p>\n<pre><code>docker pull 10.0.2.2:5000/test\n</code></pre>\n<hr>\n<h2 id=\"更多阅读\"><a href=\"#更多阅读\" class=\"headerlink\" title=\"更多阅读\"></a>更多阅读</h2><p>Docker系列文章：</p>\n<ol>\n<li><a href=\"https://juejin.im/post/5d8820cae51d453b1e478b91\">Docker中镜像、容器的常用命令</a></li>\n<li><a href=\"https://juejin.im/post/5d9f53d26fb9a04e3142120c\">Docker仓库常用命令</a></li>\n<li><a href=\"https://juejin.im/post/5d9f4f86e51d4577f3534ead\">Docker中容器的网络配置常用命令</a></li>\n</ol>\n"},{"title":"Javascript 数据类型","date":"2017-06-25T04:55:00.000Z","_content":"\n&emsp;&emsp;*本文摘录于Javascript高级程序设计（Professional JavaScript for Web Developers）并加上了自己的一些理解，如发现本文有什么错误之处，请麻烦通过以下方式联系我作修正，谢谢!*\n&emsp;&emsp;*微信号: kuntang9080*\n&emsp;&emsp;*邮箱：kuntang@163.com*\n___\n\nECMAScript中有5种简单数据类型（也称基本数据类型）：Undefined、Null、Boolean、Number、String。还有一种复杂数据类型：Object。\n\n---\n\n<!-- more -->\n\n##### typeof 操作符\n\n对一个值使用typeof操作符可能返回下列某个字符串\n\n| 返回值 | 说明 |\n|--------|--------|\n| undefined |  这个值没有定义    |\n| boolean   |  这个值是布尔值|\n|string|这个值是字符串|\n|number|这个值是数值|\n|object|这个值是对象或者null|\n|function|这个值是函数|\n\n**注意：当typeof返回是object的时候对应着两个值，因此不能用typeof来区分object类型和null类型，此时应该用instanceof()函数**\n\n---\n\n##### Undefined类型\n\nUndefined类型只有一个值，即undefined\n\n任何使用var声明但未对其加以初始化的变量都会赋以undefined值。\n\n```Javascript\nvar message = undefined;\nalert(message == undefined);\n// true\n```\n\n对未初始化的变量和未声明的变量使用typeof操作符都会返回undefined值。\n\n```Javascript\n// 只声明了message，没有声明age\nvar message;\n\nalert(typeof message);\n// undefined\nalert(typeof age);\n// undefined\n```\n\n**注意：因此我们应该保持对变量初始化时就赋值的好习惯，这样当我们做类型检测的时候就不会造成不必要的混乱**\n\n---\n\n##### Null 类型\n\nNull类型只有一个值，即null。从逻辑角度上看，null值表示一个空对象指针，而这也正是使用typeof操作符检测null会返回\"object\"的原因\n\n实际上undefined值是派生自null值的，因此\n\n```Javascript\nalert(null == undefined)\n// true\n```\n\n**如果一个声明了一个将来才会使用到的变量，那么我们应该显式地将它赋值null而不是其它值**\n\n---\n\n##### Number类型\n\n###### 1. 进制\n\n&emsp;&emsp;八进制字面值第一位必须为0，十六进制前两位必须为0x\n```Javascript\nvar octalNum = 070\n// 八进制的56\nvar hexNum = 0xA\n// 十六进制的10\n```\n\n###### 2. 其它进制转换为十进制\n\n&emsp;&emsp;其它进制转换为十进制我们可以用Number()或者parseInt()函数。因为Number()函数分的情况比较混乱，所以在很多情况下我们会用parseInt()来做进制转换。\n\nparseInt()函数提供第二个参数：转换时使用的基数（即多少进制）。例：\n```Javascript\nvar hexTo = parseInt(\"0xAF\", 16)\n// 175\nvar num1 = parseInt(\"10\", 2)\n// 2\nvar num2 = parseInt(\"10\", 8)\n// 8\nvar num3 = parseInt(\"10\", 16)\n// 16\n```\n\n###### 3. 浮点数值\n\n对于那些极大或者极小的数值，可以用e表示法（科学计数法）来表示。\n```Javascript\nvar floatNum = 3.125e7\n// 31250000\n```\n\n**注意：浮点数值的最高精度是17位小数，但在进行算术时其精度远远不如整数。比如0.1加0.2不等于0.3：**\n```Javascript\nalert(0.1 + 0.2)\n// 0.30000000000000004\nif (a + b == 0.3) {\t// 不要做这样的判断\n\talert(\"you got the 0.3\")\n}\n```\n\n如果要一定要做这样的判断，在此提供了一个解决方法\n```Javascript\nvar temp = (a * 10 + b * 10) / 10 \t//先将浮点数转化为整数作加法，然后再转为浮点数\nif (temp == 0.3) {\n\talert(\"you got the 0.3\")\n}\n```\n\n###### 4. NaN (Not a Number)\n\n- 任何涉及NaN的操作或运算都会返回NaN\n- NaN与任何值都不相等\n\n```Javascript\nalert(NaN / 10)\n// NaN\n\nalert(NaN == NaN)\n// false\n```\n\nisNaN()函数用来判断这个参数是否为NaN，当isNaN()接收到一个参数之后，会尝试将这个值转换为数值，任何不能被转换为数值的值都会导致这个函数返回true。\n```Javascript\nalert(isNaN(NaN))\n// true\nalert(isNaN(10))\n// false\nalert(isNaN(\"10\"))\n// false（转为数字10）\nalert(isNaN(\"blue\"))\n// true（不能转为数值）\nalert(isNaN(true))\n// false(true转为1)\n```\n在基于对象调用isNaN()函数时，会先调用对象的valueOf()方法，然后确定该方法返回的值是否可以转换为数值。如果不能，则基于这个**返回值**再调用toString()方法，再测试返回值。\n\n###### 5. 数值转换\n\n- Number()函数\n\n- parseInt()函数\n\n&emsp;&emsp;parseInt()函数在转换字符串时，会忽略字符串前面的空格，直至找到第一个非空格的字符。如果第一个字符就不是数字字符或者负号，就直接返回NaN。也就是说parseInt(\"a123\")返回NaN，第一个字符\"a\"不是数字字符或者负号；parseInt(\"12.3\")返回12，\".\"不是数字字符或者负号。\n\n- parseFloat()函数\n\n&emsp;&emsp;parseFloat()函数始终都会忽略前导的零。对十六进制格式的字符串始终返回0。\n\n---\n\n##### 6. String类型\n\n数值、布尔值、对象和字符串都有toString()方法，但是null和undefined值没有这个方法。\n在调用数值的toString()方法时，可以传递一个参数：输出的基数。通过这个基数可以使toString()方法输出以二进制、八进制、十六进制，乃至其他做生意有效进制格式表示的字符串值。\n\n```Javascript\nvar num = 10;\nalert(num.toString())\t// 10\nalert(num.toString(2))\t// 1010\nalert(num.toString(8))\t// 12\nalert(num.toString(10))\t// 10\nalert(num.toString(16))\t// a\n```\n\n在不知道要转换的值是不是null或undefined的情况下，可以使用转型函数String()，这个函数能够将任何类型的值转换的为字符串。String()函数遵循下列规则：\n\n- 如果有toString()方法，则调用该方法（没有参数）并返回相应的结果\n\n- 如果是null，则返回\"null\"\n\n- 如果是undefined，则返回\"undefined\"\n\n---\n\n##### 7. Object类型\n\nObject的每个实例都具有下列属性和方法。\n\n- constructor： 保存着用于创建当前对象的函数\n\n- hasOwnProperty(propertyName): 用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。其中，作为参数的属性名(propertyName)必须以字符串形式指定（例：o.hasOwnproperty(\"name\")）\n\n- isPrototypeOf(object)：用于检查传入的对象是否是当前对象的原型\n\n- propertyIsEnumerable(propertyName)：用于检查给定的属性是否能够使用for-in语句来枚举\n\n- toLocaleString()：返回对象的字符串表示，该字符串与执行环境的地区对应\n\n- toString()：返回对象的字符串表示\n\n- valueOf()：返回对象的字符串、数值或者布尔值表示。通常与toString()方法的返回值相同","source":"_posts/Javascript-data-structure.md","raw":"title: Javascript 数据类型\ntags:\n  - 读书笔记\ncategories:\n  - JavaScript\n  - ''\ndate: 2017-06-25 12:55:00\n---\n\n&emsp;&emsp;*本文摘录于Javascript高级程序设计（Professional JavaScript for Web Developers）并加上了自己的一些理解，如发现本文有什么错误之处，请麻烦通过以下方式联系我作修正，谢谢!*\n&emsp;&emsp;*微信号: kuntang9080*\n&emsp;&emsp;*邮箱：kuntang@163.com*\n___\n\nECMAScript中有5种简单数据类型（也称基本数据类型）：Undefined、Null、Boolean、Number、String。还有一种复杂数据类型：Object。\n\n---\n\n<!-- more -->\n\n##### typeof 操作符\n\n对一个值使用typeof操作符可能返回下列某个字符串\n\n| 返回值 | 说明 |\n|--------|--------|\n| undefined |  这个值没有定义    |\n| boolean   |  这个值是布尔值|\n|string|这个值是字符串|\n|number|这个值是数值|\n|object|这个值是对象或者null|\n|function|这个值是函数|\n\n**注意：当typeof返回是object的时候对应着两个值，因此不能用typeof来区分object类型和null类型，此时应该用instanceof()函数**\n\n---\n\n##### Undefined类型\n\nUndefined类型只有一个值，即undefined\n\n任何使用var声明但未对其加以初始化的变量都会赋以undefined值。\n\n```Javascript\nvar message = undefined;\nalert(message == undefined);\n// true\n```\n\n对未初始化的变量和未声明的变量使用typeof操作符都会返回undefined值。\n\n```Javascript\n// 只声明了message，没有声明age\nvar message;\n\nalert(typeof message);\n// undefined\nalert(typeof age);\n// undefined\n```\n\n**注意：因此我们应该保持对变量初始化时就赋值的好习惯，这样当我们做类型检测的时候就不会造成不必要的混乱**\n\n---\n\n##### Null 类型\n\nNull类型只有一个值，即null。从逻辑角度上看，null值表示一个空对象指针，而这也正是使用typeof操作符检测null会返回\"object\"的原因\n\n实际上undefined值是派生自null值的，因此\n\n```Javascript\nalert(null == undefined)\n// true\n```\n\n**如果一个声明了一个将来才会使用到的变量，那么我们应该显式地将它赋值null而不是其它值**\n\n---\n\n##### Number类型\n\n###### 1. 进制\n\n&emsp;&emsp;八进制字面值第一位必须为0，十六进制前两位必须为0x\n```Javascript\nvar octalNum = 070\n// 八进制的56\nvar hexNum = 0xA\n// 十六进制的10\n```\n\n###### 2. 其它进制转换为十进制\n\n&emsp;&emsp;其它进制转换为十进制我们可以用Number()或者parseInt()函数。因为Number()函数分的情况比较混乱，所以在很多情况下我们会用parseInt()来做进制转换。\n\nparseInt()函数提供第二个参数：转换时使用的基数（即多少进制）。例：\n```Javascript\nvar hexTo = parseInt(\"0xAF\", 16)\n// 175\nvar num1 = parseInt(\"10\", 2)\n// 2\nvar num2 = parseInt(\"10\", 8)\n// 8\nvar num3 = parseInt(\"10\", 16)\n// 16\n```\n\n###### 3. 浮点数值\n\n对于那些极大或者极小的数值，可以用e表示法（科学计数法）来表示。\n```Javascript\nvar floatNum = 3.125e7\n// 31250000\n```\n\n**注意：浮点数值的最高精度是17位小数，但在进行算术时其精度远远不如整数。比如0.1加0.2不等于0.3：**\n```Javascript\nalert(0.1 + 0.2)\n// 0.30000000000000004\nif (a + b == 0.3) {\t// 不要做这样的判断\n\talert(\"you got the 0.3\")\n}\n```\n\n如果要一定要做这样的判断，在此提供了一个解决方法\n```Javascript\nvar temp = (a * 10 + b * 10) / 10 \t//先将浮点数转化为整数作加法，然后再转为浮点数\nif (temp == 0.3) {\n\talert(\"you got the 0.3\")\n}\n```\n\n###### 4. NaN (Not a Number)\n\n- 任何涉及NaN的操作或运算都会返回NaN\n- NaN与任何值都不相等\n\n```Javascript\nalert(NaN / 10)\n// NaN\n\nalert(NaN == NaN)\n// false\n```\n\nisNaN()函数用来判断这个参数是否为NaN，当isNaN()接收到一个参数之后，会尝试将这个值转换为数值，任何不能被转换为数值的值都会导致这个函数返回true。\n```Javascript\nalert(isNaN(NaN))\n// true\nalert(isNaN(10))\n// false\nalert(isNaN(\"10\"))\n// false（转为数字10）\nalert(isNaN(\"blue\"))\n// true（不能转为数值）\nalert(isNaN(true))\n// false(true转为1)\n```\n在基于对象调用isNaN()函数时，会先调用对象的valueOf()方法，然后确定该方法返回的值是否可以转换为数值。如果不能，则基于这个**返回值**再调用toString()方法，再测试返回值。\n\n###### 5. 数值转换\n\n- Number()函数\n\n- parseInt()函数\n\n&emsp;&emsp;parseInt()函数在转换字符串时，会忽略字符串前面的空格，直至找到第一个非空格的字符。如果第一个字符就不是数字字符或者负号，就直接返回NaN。也就是说parseInt(\"a123\")返回NaN，第一个字符\"a\"不是数字字符或者负号；parseInt(\"12.3\")返回12，\".\"不是数字字符或者负号。\n\n- parseFloat()函数\n\n&emsp;&emsp;parseFloat()函数始终都会忽略前导的零。对十六进制格式的字符串始终返回0。\n\n---\n\n##### 6. String类型\n\n数值、布尔值、对象和字符串都有toString()方法，但是null和undefined值没有这个方法。\n在调用数值的toString()方法时，可以传递一个参数：输出的基数。通过这个基数可以使toString()方法输出以二进制、八进制、十六进制，乃至其他做生意有效进制格式表示的字符串值。\n\n```Javascript\nvar num = 10;\nalert(num.toString())\t// 10\nalert(num.toString(2))\t// 1010\nalert(num.toString(8))\t// 12\nalert(num.toString(10))\t// 10\nalert(num.toString(16))\t// a\n```\n\n在不知道要转换的值是不是null或undefined的情况下，可以使用转型函数String()，这个函数能够将任何类型的值转换的为字符串。String()函数遵循下列规则：\n\n- 如果有toString()方法，则调用该方法（没有参数）并返回相应的结果\n\n- 如果是null，则返回\"null\"\n\n- 如果是undefined，则返回\"undefined\"\n\n---\n\n##### 7. Object类型\n\nObject的每个实例都具有下列属性和方法。\n\n- constructor： 保存着用于创建当前对象的函数\n\n- hasOwnProperty(propertyName): 用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。其中，作为参数的属性名(propertyName)必须以字符串形式指定（例：o.hasOwnproperty(\"name\")）\n\n- isPrototypeOf(object)：用于检查传入的对象是否是当前对象的原型\n\n- propertyIsEnumerable(propertyName)：用于检查给定的属性是否能够使用for-in语句来枚举\n\n- toLocaleString()：返回对象的字符串表示，该字符串与执行环境的地区对应\n\n- toString()：返回对象的字符串表示\n\n- valueOf()：返回对象的字符串、数值或者布尔值表示。通常与toString()方法的返回值相同","slug":"Javascript-data-structure","published":1,"updated":"2023-04-11T03:30:27.111Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgbppebc000zbvchfvi99rqy","content":"<p>&amp;emsp;&amp;emsp;<em>本文摘录于Javascript高级程序设计（Professional JavaScript for Web Developers）并加上了自己的一些理解，如发现本文有什么错误之处，请麻烦通过以下方式联系我作修正，谢谢!</em><br>&amp;emsp;&amp;emsp;<em>微信号: kuntang9080</em><br>&amp;emsp;&amp;emsp;<em>邮箱：<a href=\"mailto:&#107;&#x75;&#x6e;&#116;&#97;&#x6e;&#103;&#64;&#x31;&#54;&#x33;&#x2e;&#99;&#x6f;&#x6d;\">&#107;&#x75;&#x6e;&#116;&#97;&#x6e;&#103;&#64;&#x31;&#54;&#x33;&#x2e;&#99;&#x6f;&#x6d;</a></em></p>\n<hr>\n<p>ECMAScript中有5种简单数据类型（也称基本数据类型）：Undefined、Null、Boolean、Number、String。还有一种复杂数据类型：Object。</p>\n<hr>\n<span id=\"more\"></span>\n\n<h5><a href=\"#typeof-cao-zuo-fu\" class=\"header-anchor\"></a><span id=\"typeof-cao-zuo-fu\">typeof 操作符</span></h5><p>对一个值使用typeof操作符可能返回下列某个字符串</p>\n<table>\n<thead>\n<tr>\n<th>返回值</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>undefined</td>\n<td>这个值没有定义</td>\n</tr>\n<tr>\n<td>boolean</td>\n<td>这个值是布尔值</td>\n</tr>\n<tr>\n<td>string</td>\n<td>这个值是字符串</td>\n</tr>\n<tr>\n<td>number</td>\n<td>这个值是数值</td>\n</tr>\n<tr>\n<td>object</td>\n<td>这个值是对象或者null</td>\n</tr>\n<tr>\n<td>function</td>\n<td>这个值是函数</td>\n</tr>\n</tbody></table>\n<p><strong>注意：当typeof返回是object的时候对应着两个值，因此不能用typeof来区分object类型和null类型，此时应该用instanceof()函数</strong></p>\n<hr>\n<h5><a href=\"#undefined-lei-xing\" class=\"header-anchor\"></a><span id=\"undefined-lei-xing\">Undefined类型</span></h5><p>Undefined类型只有一个值，即undefined</p>\n<p>任何使用var声明但未对其加以初始化的变量都会赋以undefined值。</p>\n<pre><code class=\"Javascript\">var message = undefined;\nalert(message == undefined);\n// true\n</code></pre>\n<p>对未初始化的变量和未声明的变量使用typeof操作符都会返回undefined值。</p>\n<pre><code class=\"Javascript\">// 只声明了message，没有声明age\nvar message;\n\nalert(typeof message);\n// undefined\nalert(typeof age);\n// undefined\n</code></pre>\n<p><strong>注意：因此我们应该保持对变量初始化时就赋值的好习惯，这样当我们做类型检测的时候就不会造成不必要的混乱</strong></p>\n<hr>\n<h5><a href=\"#null-lei-xing\" class=\"header-anchor\"></a><span id=\"null-lei-xing\">Null 类型</span></h5><p>Null类型只有一个值，即null。从逻辑角度上看，null值表示一个空对象指针，而这也正是使用typeof操作符检测null会返回”object”的原因</p>\n<p>实际上undefined值是派生自null值的，因此</p>\n<pre><code class=\"Javascript\">alert(null == undefined)\n// true\n</code></pre>\n<p><strong>如果一个声明了一个将来才会使用到的变量，那么我们应该显式地将它赋值null而不是其它值</strong></p>\n<hr>\n<h5><a href=\"#number-lei-xing\" class=\"header-anchor\"></a><span id=\"number-lei-xing\">Number类型</span></h5><h6><a href=\"#1-jin-zhi\" class=\"header-anchor\"></a><span id=\"1-jin-zhi\">1. 进制</span></h6><p>&amp;emsp;&amp;emsp;八进制字面值第一位必须为0，十六进制前两位必须为0x</p>\n<pre><code class=\"Javascript\">var octalNum = 070\n// 八进制的56\nvar hexNum = 0xA\n// 十六进制的10\n</code></pre>\n<h6><a href=\"#2-qi-ta-jin-zhi-zhuan-huan-wei-shi-jin-zhi\" class=\"header-anchor\"></a><span id=\"2-qi-ta-jin-zhi-zhuan-huan-wei-shi-jin-zhi\">2. 其它进制转换为十进制</span></h6><p>&amp;emsp;&amp;emsp;其它进制转换为十进制我们可以用Number()或者parseInt()函数。因为Number()函数分的情况比较混乱，所以在很多情况下我们会用parseInt()来做进制转换。</p>\n<p>parseInt()函数提供第二个参数：转换时使用的基数（即多少进制）。例：</p>\n<pre><code class=\"Javascript\">var hexTo = parseInt(&quot;0xAF&quot;, 16)\n// 175\nvar num1 = parseInt(&quot;10&quot;, 2)\n// 2\nvar num2 = parseInt(&quot;10&quot;, 8)\n// 8\nvar num3 = parseInt(&quot;10&quot;, 16)\n// 16\n</code></pre>\n<h6><a href=\"#3-fu-dian-shu-zhi\" class=\"header-anchor\"></a><span id=\"3-fu-dian-shu-zhi\">3. 浮点数值</span></h6><p>对于那些极大或者极小的数值，可以用e表示法（科学计数法）来表示。</p>\n<pre><code class=\"Javascript\">var floatNum = 3.125e7\n// 31250000\n</code></pre>\n<p><strong>注意：浮点数值的最高精度是17位小数，但在进行算术时其精度远远不如整数。比如0.1加0.2不等于0.3：</strong></p>\n<pre><code class=\"Javascript\">alert(0.1 + 0.2)\n// 0.30000000000000004\nif (a + b == 0.3) &#123;\t// 不要做这样的判断\n    alert(&quot;you got the 0.3&quot;)\n&#125;\n</code></pre>\n<p>如果要一定要做这样的判断，在此提供了一个解决方法</p>\n<pre><code class=\"Javascript\">var temp = (a * 10 + b * 10) / 10 \t//先将浮点数转化为整数作加法，然后再转为浮点数\nif (temp == 0.3) &#123;\n    alert(&quot;you got the 0.3&quot;)\n&#125;\n</code></pre>\n<h6><a href=\"#4-nan-not-a-number\" class=\"header-anchor\"></a><span id=\"4-nan-not-a-number\">4. NaN (Not a Number)</span></h6><ul>\n<li>任何涉及NaN的操作或运算都会返回NaN</li>\n<li>NaN与任何值都不相等</li>\n</ul>\n<pre><code class=\"Javascript\">alert(NaN / 10)\n// NaN\n\nalert(NaN == NaN)\n// false\n</code></pre>\n<p>isNaN()函数用来判断这个参数是否为NaN，当isNaN()接收到一个参数之后，会尝试将这个值转换为数值，任何不能被转换为数值的值都会导致这个函数返回true。</p>\n<pre><code class=\"Javascript\">alert(isNaN(NaN))\n// true\nalert(isNaN(10))\n// false\nalert(isNaN(&quot;10&quot;))\n// false（转为数字10）\nalert(isNaN(&quot;blue&quot;))\n// true（不能转为数值）\nalert(isNaN(true))\n// false(true转为1)\n</code></pre>\n<p>在基于对象调用isNaN()函数时，会先调用对象的valueOf()方法，然后确定该方法返回的值是否可以转换为数值。如果不能，则基于这个<strong>返回值</strong>再调用toString()方法，再测试返回值。</p>\n<h6><a href=\"#5-shu-zhi-zhuan-huan\" class=\"header-anchor\"></a><span id=\"5-shu-zhi-zhuan-huan\">5. 数值转换</span></h6><ul>\n<li><p>Number()函数</p>\n</li>\n<li><p>parseInt()函数</p>\n</li>\n</ul>\n<p>&amp;emsp;&amp;emsp;parseInt()函数在转换字符串时，会忽略字符串前面的空格，直至找到第一个非空格的字符。如果第一个字符就不是数字字符或者负号，就直接返回NaN。也就是说parseInt(“a123”)返回NaN，第一个字符”a”不是数字字符或者负号；parseInt(“12.3”)返回12，”.”不是数字字符或者负号。</p>\n<ul>\n<li>parseFloat()函数</li>\n</ul>\n<p>&amp;emsp;&amp;emsp;parseFloat()函数始终都会忽略前导的零。对十六进制格式的字符串始终返回0。</p>\n<hr>\n<h5><a href=\"#6-string-lei-xing\" class=\"header-anchor\"></a><span id=\"6-string-lei-xing\">6. String类型</span></h5><p>数值、布尔值、对象和字符串都有toString()方法，但是null和undefined值没有这个方法。<br>在调用数值的toString()方法时，可以传递一个参数：输出的基数。通过这个基数可以使toString()方法输出以二进制、八进制、十六进制，乃至其他做生意有效进制格式表示的字符串值。</p>\n<pre><code class=\"Javascript\">var num = 10;\nalert(num.toString())\t// 10\nalert(num.toString(2))\t// 1010\nalert(num.toString(8))\t// 12\nalert(num.toString(10))\t// 10\nalert(num.toString(16))\t// a\n</code></pre>\n<p>在不知道要转换的值是不是null或undefined的情况下，可以使用转型函数String()，这个函数能够将任何类型的值转换的为字符串。String()函数遵循下列规则：</p>\n<ul>\n<li><p>如果有toString()方法，则调用该方法（没有参数）并返回相应的结果</p>\n</li>\n<li><p>如果是null，则返回”null”</p>\n</li>\n<li><p>如果是undefined，则返回”undefined”</p>\n</li>\n</ul>\n<hr>\n<h5><a href=\"#7-object-lei-xing\" class=\"header-anchor\"></a><span id=\"7-object-lei-xing\">7. Object类型</span></h5><p>Object的每个实例都具有下列属性和方法。</p>\n<ul>\n<li><p>constructor： 保存着用于创建当前对象的函数</p>\n</li>\n<li><p>hasOwnProperty(propertyName): 用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。其中，作为参数的属性名(propertyName)必须以字符串形式指定（例：o.hasOwnproperty(“name”)）</p>\n</li>\n<li><p>isPrototypeOf(object)：用于检查传入的对象是否是当前对象的原型</p>\n</li>\n<li><p>propertyIsEnumerable(propertyName)：用于检查给定的属性是否能够使用for-in语句来枚举</p>\n</li>\n<li><p>toLocaleString()：返回对象的字符串表示，该字符串与执行环境的地区对应</p>\n</li>\n<li><p>toString()：返回对象的字符串表示</p>\n</li>\n<li><p>valueOf()：返回对象的字符串、数值或者布尔值表示。通常与toString()方法的返回值相同</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>&amp;emsp;&amp;emsp;<em>本文摘录于Javascript高级程序设计（Professional JavaScript for Web Developers）并加上了自己的一些理解，如发现本文有什么错误之处，请麻烦通过以下方式联系我作修正，谢谢!</em><br>&amp;emsp;&amp;emsp;<em>微信号: kuntang9080</em><br>&amp;emsp;&amp;emsp;<em>邮箱：<a href=\"mailto:&#107;&#x75;&#x6e;&#116;&#97;&#x6e;&#103;&#64;&#x31;&#54;&#x33;&#x2e;&#99;&#x6f;&#x6d;\">&#107;&#x75;&#x6e;&#116;&#97;&#x6e;&#103;&#64;&#x31;&#54;&#x33;&#x2e;&#99;&#x6f;&#x6d;</a></em></p>\n<hr>\n<p>ECMAScript中有5种简单数据类型（也称基本数据类型）：Undefined、Null、Boolean、Number、String。还有一种复杂数据类型：Object。</p>\n<hr>","more":"<h5 id=\"typeof-操作符\"><a href=\"#typeof-操作符\" class=\"headerlink\" title=\"typeof 操作符\"></a>typeof 操作符</h5><p>对一个值使用typeof操作符可能返回下列某个字符串</p>\n<table>\n<thead>\n<tr>\n<th>返回值</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>undefined</td>\n<td>这个值没有定义</td>\n</tr>\n<tr>\n<td>boolean</td>\n<td>这个值是布尔值</td>\n</tr>\n<tr>\n<td>string</td>\n<td>这个值是字符串</td>\n</tr>\n<tr>\n<td>number</td>\n<td>这个值是数值</td>\n</tr>\n<tr>\n<td>object</td>\n<td>这个值是对象或者null</td>\n</tr>\n<tr>\n<td>function</td>\n<td>这个值是函数</td>\n</tr>\n</tbody></table>\n<p><strong>注意：当typeof返回是object的时候对应着两个值，因此不能用typeof来区分object类型和null类型，此时应该用instanceof()函数</strong></p>\n<hr>\n<h5 id=\"Undefined类型\"><a href=\"#Undefined类型\" class=\"headerlink\" title=\"Undefined类型\"></a>Undefined类型</h5><p>Undefined类型只有一个值，即undefined</p>\n<p>任何使用var声明但未对其加以初始化的变量都会赋以undefined值。</p>\n<pre><code class=\"Javascript\">var message = undefined;\nalert(message == undefined);\n// true\n</code></pre>\n<p>对未初始化的变量和未声明的变量使用typeof操作符都会返回undefined值。</p>\n<pre><code class=\"Javascript\">// 只声明了message，没有声明age\nvar message;\n\nalert(typeof message);\n// undefined\nalert(typeof age);\n// undefined\n</code></pre>\n<p><strong>注意：因此我们应该保持对变量初始化时就赋值的好习惯，这样当我们做类型检测的时候就不会造成不必要的混乱</strong></p>\n<hr>\n<h5 id=\"Null-类型\"><a href=\"#Null-类型\" class=\"headerlink\" title=\"Null 类型\"></a>Null 类型</h5><p>Null类型只有一个值，即null。从逻辑角度上看，null值表示一个空对象指针，而这也正是使用typeof操作符检测null会返回”object”的原因</p>\n<p>实际上undefined值是派生自null值的，因此</p>\n<pre><code class=\"Javascript\">alert(null == undefined)\n// true\n</code></pre>\n<p><strong>如果一个声明了一个将来才会使用到的变量，那么我们应该显式地将它赋值null而不是其它值</strong></p>\n<hr>\n<h5 id=\"Number类型\"><a href=\"#Number类型\" class=\"headerlink\" title=\"Number类型\"></a>Number类型</h5><h6 id=\"1-进制\"><a href=\"#1-进制\" class=\"headerlink\" title=\"1. 进制\"></a>1. 进制</h6><p>&amp;emsp;&amp;emsp;八进制字面值第一位必须为0，十六进制前两位必须为0x</p>\n<pre><code class=\"Javascript\">var octalNum = 070\n// 八进制的56\nvar hexNum = 0xA\n// 十六进制的10\n</code></pre>\n<h6 id=\"2-其它进制转换为十进制\"><a href=\"#2-其它进制转换为十进制\" class=\"headerlink\" title=\"2. 其它进制转换为十进制\"></a>2. 其它进制转换为十进制</h6><p>&amp;emsp;&amp;emsp;其它进制转换为十进制我们可以用Number()或者parseInt()函数。因为Number()函数分的情况比较混乱，所以在很多情况下我们会用parseInt()来做进制转换。</p>\n<p>parseInt()函数提供第二个参数：转换时使用的基数（即多少进制）。例：</p>\n<pre><code class=\"Javascript\">var hexTo = parseInt(&quot;0xAF&quot;, 16)\n// 175\nvar num1 = parseInt(&quot;10&quot;, 2)\n// 2\nvar num2 = parseInt(&quot;10&quot;, 8)\n// 8\nvar num3 = parseInt(&quot;10&quot;, 16)\n// 16\n</code></pre>\n<h6 id=\"3-浮点数值\"><a href=\"#3-浮点数值\" class=\"headerlink\" title=\"3. 浮点数值\"></a>3. 浮点数值</h6><p>对于那些极大或者极小的数值，可以用e表示法（科学计数法）来表示。</p>\n<pre><code class=\"Javascript\">var floatNum = 3.125e7\n// 31250000\n</code></pre>\n<p><strong>注意：浮点数值的最高精度是17位小数，但在进行算术时其精度远远不如整数。比如0.1加0.2不等于0.3：</strong></p>\n<pre><code class=\"Javascript\">alert(0.1 + 0.2)\n// 0.30000000000000004\nif (a + b == 0.3) &#123;\t// 不要做这样的判断\n    alert(&quot;you got the 0.3&quot;)\n&#125;\n</code></pre>\n<p>如果要一定要做这样的判断，在此提供了一个解决方法</p>\n<pre><code class=\"Javascript\">var temp = (a * 10 + b * 10) / 10 \t//先将浮点数转化为整数作加法，然后再转为浮点数\nif (temp == 0.3) &#123;\n    alert(&quot;you got the 0.3&quot;)\n&#125;\n</code></pre>\n<h6 id=\"4-NaN-Not-a-Number\"><a href=\"#4-NaN-Not-a-Number\" class=\"headerlink\" title=\"4. NaN (Not a Number)\"></a>4. NaN (Not a Number)</h6><ul>\n<li>任何涉及NaN的操作或运算都会返回NaN</li>\n<li>NaN与任何值都不相等</li>\n</ul>\n<pre><code class=\"Javascript\">alert(NaN / 10)\n// NaN\n\nalert(NaN == NaN)\n// false\n</code></pre>\n<p>isNaN()函数用来判断这个参数是否为NaN，当isNaN()接收到一个参数之后，会尝试将这个值转换为数值，任何不能被转换为数值的值都会导致这个函数返回true。</p>\n<pre><code class=\"Javascript\">alert(isNaN(NaN))\n// true\nalert(isNaN(10))\n// false\nalert(isNaN(&quot;10&quot;))\n// false（转为数字10）\nalert(isNaN(&quot;blue&quot;))\n// true（不能转为数值）\nalert(isNaN(true))\n// false(true转为1)\n</code></pre>\n<p>在基于对象调用isNaN()函数时，会先调用对象的valueOf()方法，然后确定该方法返回的值是否可以转换为数值。如果不能，则基于这个<strong>返回值</strong>再调用toString()方法，再测试返回值。</p>\n<h6 id=\"5-数值转换\"><a href=\"#5-数值转换\" class=\"headerlink\" title=\"5. 数值转换\"></a>5. 数值转换</h6><ul>\n<li><p>Number()函数</p>\n</li>\n<li><p>parseInt()函数</p>\n</li>\n</ul>\n<p>&amp;emsp;&amp;emsp;parseInt()函数在转换字符串时，会忽略字符串前面的空格，直至找到第一个非空格的字符。如果第一个字符就不是数字字符或者负号，就直接返回NaN。也就是说parseInt(“a123”)返回NaN，第一个字符”a”不是数字字符或者负号；parseInt(“12.3”)返回12，”.”不是数字字符或者负号。</p>\n<ul>\n<li>parseFloat()函数</li>\n</ul>\n<p>&amp;emsp;&amp;emsp;parseFloat()函数始终都会忽略前导的零。对十六进制格式的字符串始终返回0。</p>\n<hr>\n<h5 id=\"6-String类型\"><a href=\"#6-String类型\" class=\"headerlink\" title=\"6. String类型\"></a>6. String类型</h5><p>数值、布尔值、对象和字符串都有toString()方法，但是null和undefined值没有这个方法。<br>在调用数值的toString()方法时，可以传递一个参数：输出的基数。通过这个基数可以使toString()方法输出以二进制、八进制、十六进制，乃至其他做生意有效进制格式表示的字符串值。</p>\n<pre><code class=\"Javascript\">var num = 10;\nalert(num.toString())\t// 10\nalert(num.toString(2))\t// 1010\nalert(num.toString(8))\t// 12\nalert(num.toString(10))\t// 10\nalert(num.toString(16))\t// a\n</code></pre>\n<p>在不知道要转换的值是不是null或undefined的情况下，可以使用转型函数String()，这个函数能够将任何类型的值转换的为字符串。String()函数遵循下列规则：</p>\n<ul>\n<li><p>如果有toString()方法，则调用该方法（没有参数）并返回相应的结果</p>\n</li>\n<li><p>如果是null，则返回”null”</p>\n</li>\n<li><p>如果是undefined，则返回”undefined”</p>\n</li>\n</ul>\n<hr>\n<h5 id=\"7-Object类型\"><a href=\"#7-Object类型\" class=\"headerlink\" title=\"7. Object类型\"></a>7. Object类型</h5><p>Object的每个实例都具有下列属性和方法。</p>\n<ul>\n<li><p>constructor： 保存着用于创建当前对象的函数</p>\n</li>\n<li><p>hasOwnProperty(propertyName): 用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。其中，作为参数的属性名(propertyName)必须以字符串形式指定（例：o.hasOwnproperty(“name”)）</p>\n</li>\n<li><p>isPrototypeOf(object)：用于检查传入的对象是否是当前对象的原型</p>\n</li>\n<li><p>propertyIsEnumerable(propertyName)：用于检查给定的属性是否能够使用for-in语句来枚举</p>\n</li>\n<li><p>toLocaleString()：返回对象的字符串表示，该字符串与执行环境的地区对应</p>\n</li>\n<li><p>toString()：返回对象的字符串表示</p>\n</li>\n<li><p>valueOf()：返回对象的字符串、数值或者布尔值表示。通常与toString()方法的返回值相同</p>\n</li>\n</ul>"},{"title":"JavaScript 设计模式与开发实践","date":"2017-08-09T11:51:00.000Z","_content":"\n## 基础知识\n\n### 一、this、call 和 apply\n\n#### this的指向\n\n除去不常用的with和eval的情况，具体到实际应用中，this的指向大致可以分为以下4种：\n\n- 作为对象的方法调用。\n- 作为普通函数调用。\n- 构造器调用。\n- Function.prototype.call或Function.prototype.apply调用。\n\n<!-- more -->\n\n1. 作为对象的方法调用\n\n当函数作为对象的方法被调用时，this指向该对象：\n\n```\nvar obj = {\n\ta: 1，\n    getA: function() {\n    \talert( this === obj );\n        alert( this.a );\n    }\n}\n\nobj.getA();\n// output: true\n// output: 1\n```\n2. 作为普通函数调用\n\n当函数不作为对象的属性被调用时，也就是我们常说的普通函数方式，无论它在哪里调用，此时的this总是指向全局对象。在浏览器的JavaScript里，p个全局对象 是window对象。\n\n```\nwindow.name = 'golbalName';\n\nvar getName = function() {\n\treturn this.name;\n};\n\nvar anotherGetName = function() {\n\tconsole.log(getName())\n}\n\nconsole.log( getName()) ;\n// output: globalName\n\nanotherGetName();\n// output: globalName\n```\n\n或者\n\n```\nwindow.name = 'globalName';\n\nvar myObject = {\n\tname: 'sven',\n    getName: function(){\n    \treturn this.name;\n    };\n};\n\nvar getName = myObject.getName;\ncosnole.log( getName() );\n// output: globalName\n\n```\n\n3. 有时候我们会遇到一些困扰，比如在div节点的事件函数内部，有一个局部的callback方法，callback被作为普通函数调用时，callback内部的this指向了window,但我们往往是想让它指向该div节点，见如下代码：\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>Document</title>\n</head>\n<body>\n    <div id=\"div1\">I am a div</div>\n\n    <script>\n        window.id = 'window'\n        document.getElementById('div1').onclick =function() {\n            alert( this.id ); // output: div1\n            var callback =function() {\n                alert( this.id ); // output: window\n            }\n            callback()\n        }\n    </script>\n</body>\n</html>\n```\n\n此时有一种简单的解决方案，可以用一个变量保存div节点的引用：\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>Document</title>\n</head>\n<body>\n    <div id=\"div1\">I am a div</div>\n\n    <script>\n        window.id = 'window'\n        document.getElementById('div1').onclick =function() {\n            var that = this\n            var callback =function() {\n                alert( that.id ); // output: div1\n            }\n            callback()\n        }\n    </script>\n</body>\n</html>\n```\n\n在ECMAScript5的strict模式下，这种情况下的this已经被规定为不会指向全局对象，而是undefined:\n\n\n```\nfunction func() {\n\t“use strict\"\n    alert( this ) // output: undefined\n}\n```\n\n### 二、闭包和高阶函数\n\n#### 闭包\n\n## 设计模式\n\n### 订阅模式\n\n订阅模式的设计主要有两个结构，一个是存放订阅事件的数组，还有添加订阅事件的方法，广播执行订阅事件的方法。\n\n例： \n\n```\nvar event = {\n    // 存放订阅事件的数组队列\n    clientList: [],\n    // 添加订阅事件的方法\n    listen: function( key, fn ) {\n        // key 是订阅事件的代号标志，比如login表示登录订阅事件，\n        // loadFail表示读取失败订阅事件\n        // fn 是要订阅事件触发时执行的函数\n        if (!this.clientList[ key ]) {\n            this.clientList[ key ] = []\n        }\n        // 把订阅消息添加到缓存列表\n        this.clientList[ key ].push( fn );\n    },\n    trigger: function() {\n        var key = Array.prototype.shift.call( arguments )\n            fns = this.clientList[ key ]\n        \n            if ( !fns || fns.length === 0 ) { // 如果没有绑定对应的消息\n                return false\n            }\n        \n            for ( var i = 0, fn; fn = fns[ i++ ];) {\n                fn.apply( this, arguments )  // arguments 是 trigger 是带上的参数\n            }\n    }\n}\n```\n\n我们来测试一下上面的代码：\n首先定义一个installEvent函数让我们可以给所有对象都动态添加发布-订阅功能（但是这个并不是必须的，不过一般都会声明一个方便调用）\n\n```\nvar installEvent = function( obj ) {\n    for ( var i in event ) {\n        obj[ i ] = event[ i ];\n    }\n}\n```\n\n假设一个场景，在课堂上老师个学生布置作业，然后等我学生到做作业的时间的时候，就开始做老师发布的作业。在这里老师是订阅者，学生是发布者。\n\n```\n// 先给老师添加发布订阅功能\nvar teacher = {}\ninstallEvent( teacher )\n\n// 老师备课时先定义好将要布置的作业\nfunction doMath() {\n\tconsole.log( 'do Math homework' )\n}\n\nfunction doMathTest() {\n\tconsole.log( 'do Math test homework' )\n}\n\nfunction doEnglish() {\n\tconsole.log( 'do Englisth homework' )\n}\n\n// 在课堂上老师发布作业\nteacher.listen( 'Math', function() {\n    doMath();\n})\n\nteacher.listen( 'Math', function() {\n\tdoMathTest()\n})\n\nteacher.listen( 'English', function() {\n    do English()\n})\n\n// 做作业的时间到了，学生做老师发布的作业\n// 用if来假设条件成立，可以去掉\nif ( new Date().now === 8888 ) {\n\tteacher.trigger( 'Math' )\n\tteacher.trigger( 'English' )\n}\n\n```\n\n发布订阅模式还很适合协作开发，比如上面的例子，老师只需要负责这天需要做哪科作业（Math, English)，做哪一题(doMath, doMathTest, doEnglish)。而学生只需要负责到点就去完成作业。\n\n### 中介者模式\n\n中介者就是把许多相关联的对象进行解耦。有时候对象与对象之间的操作会互相影响，有些对象要在其他对象改变的时候做出相应的响应，这个时候就要用到中介者模式。\n\n中介者模式一般有两种实现方式：\n\n- 利用发布-订阅模式。\n- 中介者开放一些接口给其它对象调用，而具体实现的逻辑在中介者中实现，然后中介者把执行后的结果发送给其它对象。\n\n考虑一个现实的一个例子：\n这手机购买的过程中，可以选择手机的颜色和数量，同时在页面会有相应手机库存的显示，然后页面底下的购习按钮会根据库存等情况作出不同的展示。\n\n假设有这几种规格的手机：\n\n```\nvar goods = {\n\t\"red\": 3,\n\t\"blue: 6\n}\n```\n\n粗略地把上面分成以下几种情况：\n\n1. 选择红色手机，买4个，显示库存不足，购买按钮不可点\n2. 选择蓝色手机，买5个，显示库存充足，购买按钮可点\n3. 不有选择颜色或者数量的时候，购买按钮不可点\n\n以下进行编码：\n\n页面HTML代码：\n\n```\n选择颜色： \n<select name=\"\" id=\"colorSelect\">\n    <option value=\"\">请选择</option>\n    <option value=\"red\">红色</option>\n    <option value=\"blue\">蓝色</option>\n</select>\n输入购买数量：\n<input type=\"text\" id=\"numberInput\">\n您选择了颜色：\n<div id=\"colorInfo\"></div><br/>\n您输入了数量：\n<div id=\"nubmerInfo\"></div>\n您输入了容量：\n<div id=\"momeryInfo\"></div>\n```\n\n先定义商品规格：\n\n```\nvar goods = {\n    \"red|32G\": 3,\n    \"red|64G\": 0,\n    \"blue|32G\": 1,\n    \"blue|16G\": 6\n}\n```\n\n定义中介者来作处理其中判断的逻辑，返回一个事件让其它关联对象调用。\n\n```\nvar mediator = (function(){\n    var colorSelect = document.getElementById('colorSelect')\n    var memorySelect = document.getElementById('memorySelect')\n    var numberInput = document.getElementById('numberInput')\n    var colorInfo = document.getElementById('colorInfo')\n    var memoryInfo = document.getElementById('memoryInfo')\n    var numberInfo = document.getElementById('numberInfo')\n    var nextBtn = document.getElementById('nextBtn')\n\n    return {\n        changed: function(obj){\n            var color = colorSelect.value,  // 颜色\n                memory = memorySelect.value, // 内存\n                number = numberSelect.value, // 数量\n                stock = goods[ color + '|' + memory ];  // 颜色和内存对应的手机库存数量\n            \n            if ( obj === colorSelect ) {\n                colorInfo.innerHTML = color\n            } else if ( obj === memorySelect ) {\n                memoryInfo.innerHTML = memory\n            } else if ( obj === numberInput ) {\n                numberInfo.innerHTML = number\n            }\n\n            if ( !memory ) {\n                nextBtn.disabled = true\n                nextBtn.innerHTML = '请选择手机颜色'\n                return\n            }\n\n            if ( !memory ) {\n                nextBtn.disabled = true\n                nextBtn.innerHTML = '请选择内存大小'\n                return\n            }\n\n            if ( Number.isInteger ( number - 0 ) && number > 0 ) {\n                nextBtn.disabled = true\n                nextBtn.innerHTML = '请输入正确的购买数量'\n                return\n            }\n\n            nextBtn.disabled = false\n            nextBtn.innerHTML = '放入购物车'\n        }\n    }\n})()\n```\n\n当相对应的对象改变的时候，中介者就能通过响应作出正确的处理，而不用把所有的判断逻辑放在各个事件监听所触发的函数里。\n\n```\ncolorSelect.onchange = function() {\n    mediator.changed( this )\n}\n\nmemorySelect.onchange = function() {\n    mediator.changed( this )\n}\n\nnumberInput.onchange = function() {\n    mediator.changed( this )\n}\n```\n\n","source":"_posts/JavaScript-Design-Patterns-and-Development-Practice.md","raw":"title: JavaScript 设计模式与开发实践\ntags:\n  - 读书笔记\ncategories:\n  - JavaScript\n  - ''\ndate: 2017-08-09 19:51:00\n---\n\n## 基础知识\n\n### 一、this、call 和 apply\n\n#### this的指向\n\n除去不常用的with和eval的情况，具体到实际应用中，this的指向大致可以分为以下4种：\n\n- 作为对象的方法调用。\n- 作为普通函数调用。\n- 构造器调用。\n- Function.prototype.call或Function.prototype.apply调用。\n\n<!-- more -->\n\n1. 作为对象的方法调用\n\n当函数作为对象的方法被调用时，this指向该对象：\n\n```\nvar obj = {\n\ta: 1，\n    getA: function() {\n    \talert( this === obj );\n        alert( this.a );\n    }\n}\n\nobj.getA();\n// output: true\n// output: 1\n```\n2. 作为普通函数调用\n\n当函数不作为对象的属性被调用时，也就是我们常说的普通函数方式，无论它在哪里调用，此时的this总是指向全局对象。在浏览器的JavaScript里，p个全局对象 是window对象。\n\n```\nwindow.name = 'golbalName';\n\nvar getName = function() {\n\treturn this.name;\n};\n\nvar anotherGetName = function() {\n\tconsole.log(getName())\n}\n\nconsole.log( getName()) ;\n// output: globalName\n\nanotherGetName();\n// output: globalName\n```\n\n或者\n\n```\nwindow.name = 'globalName';\n\nvar myObject = {\n\tname: 'sven',\n    getName: function(){\n    \treturn this.name;\n    };\n};\n\nvar getName = myObject.getName;\ncosnole.log( getName() );\n// output: globalName\n\n```\n\n3. 有时候我们会遇到一些困扰，比如在div节点的事件函数内部，有一个局部的callback方法，callback被作为普通函数调用时，callback内部的this指向了window,但我们往往是想让它指向该div节点，见如下代码：\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>Document</title>\n</head>\n<body>\n    <div id=\"div1\">I am a div</div>\n\n    <script>\n        window.id = 'window'\n        document.getElementById('div1').onclick =function() {\n            alert( this.id ); // output: div1\n            var callback =function() {\n                alert( this.id ); // output: window\n            }\n            callback()\n        }\n    </script>\n</body>\n</html>\n```\n\n此时有一种简单的解决方案，可以用一个变量保存div节点的引用：\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>Document</title>\n</head>\n<body>\n    <div id=\"div1\">I am a div</div>\n\n    <script>\n        window.id = 'window'\n        document.getElementById('div1').onclick =function() {\n            var that = this\n            var callback =function() {\n                alert( that.id ); // output: div1\n            }\n            callback()\n        }\n    </script>\n</body>\n</html>\n```\n\n在ECMAScript5的strict模式下，这种情况下的this已经被规定为不会指向全局对象，而是undefined:\n\n\n```\nfunction func() {\n\t“use strict\"\n    alert( this ) // output: undefined\n}\n```\n\n### 二、闭包和高阶函数\n\n#### 闭包\n\n## 设计模式\n\n### 订阅模式\n\n订阅模式的设计主要有两个结构，一个是存放订阅事件的数组，还有添加订阅事件的方法，广播执行订阅事件的方法。\n\n例： \n\n```\nvar event = {\n    // 存放订阅事件的数组队列\n    clientList: [],\n    // 添加订阅事件的方法\n    listen: function( key, fn ) {\n        // key 是订阅事件的代号标志，比如login表示登录订阅事件，\n        // loadFail表示读取失败订阅事件\n        // fn 是要订阅事件触发时执行的函数\n        if (!this.clientList[ key ]) {\n            this.clientList[ key ] = []\n        }\n        // 把订阅消息添加到缓存列表\n        this.clientList[ key ].push( fn );\n    },\n    trigger: function() {\n        var key = Array.prototype.shift.call( arguments )\n            fns = this.clientList[ key ]\n        \n            if ( !fns || fns.length === 0 ) { // 如果没有绑定对应的消息\n                return false\n            }\n        \n            for ( var i = 0, fn; fn = fns[ i++ ];) {\n                fn.apply( this, arguments )  // arguments 是 trigger 是带上的参数\n            }\n    }\n}\n```\n\n我们来测试一下上面的代码：\n首先定义一个installEvent函数让我们可以给所有对象都动态添加发布-订阅功能（但是这个并不是必须的，不过一般都会声明一个方便调用）\n\n```\nvar installEvent = function( obj ) {\n    for ( var i in event ) {\n        obj[ i ] = event[ i ];\n    }\n}\n```\n\n假设一个场景，在课堂上老师个学生布置作业，然后等我学生到做作业的时间的时候，就开始做老师发布的作业。在这里老师是订阅者，学生是发布者。\n\n```\n// 先给老师添加发布订阅功能\nvar teacher = {}\ninstallEvent( teacher )\n\n// 老师备课时先定义好将要布置的作业\nfunction doMath() {\n\tconsole.log( 'do Math homework' )\n}\n\nfunction doMathTest() {\n\tconsole.log( 'do Math test homework' )\n}\n\nfunction doEnglish() {\n\tconsole.log( 'do Englisth homework' )\n}\n\n// 在课堂上老师发布作业\nteacher.listen( 'Math', function() {\n    doMath();\n})\n\nteacher.listen( 'Math', function() {\n\tdoMathTest()\n})\n\nteacher.listen( 'English', function() {\n    do English()\n})\n\n// 做作业的时间到了，学生做老师发布的作业\n// 用if来假设条件成立，可以去掉\nif ( new Date().now === 8888 ) {\n\tteacher.trigger( 'Math' )\n\tteacher.trigger( 'English' )\n}\n\n```\n\n发布订阅模式还很适合协作开发，比如上面的例子，老师只需要负责这天需要做哪科作业（Math, English)，做哪一题(doMath, doMathTest, doEnglish)。而学生只需要负责到点就去完成作业。\n\n### 中介者模式\n\n中介者就是把许多相关联的对象进行解耦。有时候对象与对象之间的操作会互相影响，有些对象要在其他对象改变的时候做出相应的响应，这个时候就要用到中介者模式。\n\n中介者模式一般有两种实现方式：\n\n- 利用发布-订阅模式。\n- 中介者开放一些接口给其它对象调用，而具体实现的逻辑在中介者中实现，然后中介者把执行后的结果发送给其它对象。\n\n考虑一个现实的一个例子：\n这手机购买的过程中，可以选择手机的颜色和数量，同时在页面会有相应手机库存的显示，然后页面底下的购习按钮会根据库存等情况作出不同的展示。\n\n假设有这几种规格的手机：\n\n```\nvar goods = {\n\t\"red\": 3,\n\t\"blue: 6\n}\n```\n\n粗略地把上面分成以下几种情况：\n\n1. 选择红色手机，买4个，显示库存不足，购买按钮不可点\n2. 选择蓝色手机，买5个，显示库存充足，购买按钮可点\n3. 不有选择颜色或者数量的时候，购买按钮不可点\n\n以下进行编码：\n\n页面HTML代码：\n\n```\n选择颜色： \n<select name=\"\" id=\"colorSelect\">\n    <option value=\"\">请选择</option>\n    <option value=\"red\">红色</option>\n    <option value=\"blue\">蓝色</option>\n</select>\n输入购买数量：\n<input type=\"text\" id=\"numberInput\">\n您选择了颜色：\n<div id=\"colorInfo\"></div><br/>\n您输入了数量：\n<div id=\"nubmerInfo\"></div>\n您输入了容量：\n<div id=\"momeryInfo\"></div>\n```\n\n先定义商品规格：\n\n```\nvar goods = {\n    \"red|32G\": 3,\n    \"red|64G\": 0,\n    \"blue|32G\": 1,\n    \"blue|16G\": 6\n}\n```\n\n定义中介者来作处理其中判断的逻辑，返回一个事件让其它关联对象调用。\n\n```\nvar mediator = (function(){\n    var colorSelect = document.getElementById('colorSelect')\n    var memorySelect = document.getElementById('memorySelect')\n    var numberInput = document.getElementById('numberInput')\n    var colorInfo = document.getElementById('colorInfo')\n    var memoryInfo = document.getElementById('memoryInfo')\n    var numberInfo = document.getElementById('numberInfo')\n    var nextBtn = document.getElementById('nextBtn')\n\n    return {\n        changed: function(obj){\n            var color = colorSelect.value,  // 颜色\n                memory = memorySelect.value, // 内存\n                number = numberSelect.value, // 数量\n                stock = goods[ color + '|' + memory ];  // 颜色和内存对应的手机库存数量\n            \n            if ( obj === colorSelect ) {\n                colorInfo.innerHTML = color\n            } else if ( obj === memorySelect ) {\n                memoryInfo.innerHTML = memory\n            } else if ( obj === numberInput ) {\n                numberInfo.innerHTML = number\n            }\n\n            if ( !memory ) {\n                nextBtn.disabled = true\n                nextBtn.innerHTML = '请选择手机颜色'\n                return\n            }\n\n            if ( !memory ) {\n                nextBtn.disabled = true\n                nextBtn.innerHTML = '请选择内存大小'\n                return\n            }\n\n            if ( Number.isInteger ( number - 0 ) && number > 0 ) {\n                nextBtn.disabled = true\n                nextBtn.innerHTML = '请输入正确的购买数量'\n                return\n            }\n\n            nextBtn.disabled = false\n            nextBtn.innerHTML = '放入购物车'\n        }\n    }\n})()\n```\n\n当相对应的对象改变的时候，中介者就能通过响应作出正确的处理，而不用把所有的判断逻辑放在各个事件监听所触发的函数里。\n\n```\ncolorSelect.onchange = function() {\n    mediator.changed( this )\n}\n\nmemorySelect.onchange = function() {\n    mediator.changed( this )\n}\n\nnumberInput.onchange = function() {\n    mediator.changed( this )\n}\n```\n\n","slug":"JavaScript-Design-Patterns-and-Development-Practice","published":1,"updated":"2023-04-11T03:30:27.111Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgbppebc0011bvchhe6jgcso","content":"<h2><a href=\"#ji-chu-zhi-shi\" class=\"header-anchor\"></a><span id=\"ji-chu-zhi-shi\">基础知识</span></h2><h3><a href=\"#yi-this-call-he-apply\" class=\"header-anchor\"></a><span id=\"yi-this-call-he-apply\">一、this、call 和 apply</span></h3><h4><a href=\"#this-de-zhi-xiang\" class=\"header-anchor\"></a><span id=\"this-de-zhi-xiang\">this的指向</span></h4><p>除去不常用的with和eval的情况，具体到实际应用中，this的指向大致可以分为以下4种：</p>\n<ul>\n<li>作为对象的方法调用。</li>\n<li>作为普通函数调用。</li>\n<li>构造器调用。</li>\n<li>Function.prototype.call或Function.prototype.apply调用。</li>\n</ul>\n<span id=\"more\"></span>\n\n<ol>\n<li>作为对象的方法调用</li>\n</ol>\n<p>当函数作为对象的方法被调用时，this指向该对象：</p>\n<pre><code>var obj = &#123;\n    a: 1，\n    getA: function() &#123;\n        alert( this === obj );\n        alert( this.a );\n    &#125;\n&#125;\n\nobj.getA();\n// output: true\n// output: 1\n</code></pre>\n<ol start=\"2\">\n<li>作为普通函数调用</li>\n</ol>\n<p>当函数不作为对象的属性被调用时，也就是我们常说的普通函数方式，无论它在哪里调用，此时的this总是指向全局对象。在浏览器的JavaScript里，p个全局对象 是window对象。</p>\n<pre><code>window.name = &#39;golbalName&#39;;\n\nvar getName = function() &#123;\n    return this.name;\n&#125;;\n\nvar anotherGetName = function() &#123;\n    console.log(getName())\n&#125;\n\nconsole.log( getName()) ;\n// output: globalName\n\nanotherGetName();\n// output: globalName\n</code></pre>\n<p>或者</p>\n<pre><code>window.name = &#39;globalName&#39;;\n\nvar myObject = &#123;\n    name: &#39;sven&#39;,\n    getName: function()&#123;\n        return this.name;\n    &#125;;\n&#125;;\n\nvar getName = myObject.getName;\ncosnole.log( getName() );\n// output: globalName\n</code></pre>\n<ol start=\"3\">\n<li>有时候我们会遇到一些困扰，比如在div节点的事件函数内部，有一个局部的callback方法，callback被作为普通函数调用时，callback内部的this指向了window,但我们往往是想让它指向该div节点，见如下代码：</li>\n</ol>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div id=&quot;div1&quot;&gt;I am a div&lt;/div&gt;\n\n    &lt;script&gt;\n        window.id = &#39;window&#39;\n        document.getElementById(&#39;div1&#39;).onclick =function() &#123;\n            alert( this.id ); // output: div1\n            var callback =function() &#123;\n                alert( this.id ); // output: window\n            &#125;\n            callback()\n        &#125;\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p>此时有一种简单的解决方案，可以用一个变量保存div节点的引用：</p>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div id=&quot;div1&quot;&gt;I am a div&lt;/div&gt;\n\n    &lt;script&gt;\n        window.id = &#39;window&#39;\n        document.getElementById(&#39;div1&#39;).onclick =function() &#123;\n            var that = this\n            var callback =function() &#123;\n                alert( that.id ); // output: div1\n            &#125;\n            callback()\n        &#125;\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p>在ECMAScript5的strict模式下，这种情况下的this已经被规定为不会指向全局对象，而是undefined:</p>\n<pre><code>function func() &#123;\n    “use strict&quot;\n    alert( this ) // output: undefined\n&#125;\n</code></pre>\n<h3><a href=\"#er-bi-bao-he-gao-jie-han-shu\" class=\"header-anchor\"></a><span id=\"er-bi-bao-he-gao-jie-han-shu\">二、闭包和高阶函数</span></h3><h4><a href=\"#bi-bao\" class=\"header-anchor\"></a><span id=\"bi-bao\">闭包</span></h4><h2><a href=\"#she-ji-mo-shi\" class=\"header-anchor\"></a><span id=\"she-ji-mo-shi\">设计模式</span></h2><h3><a href=\"#ding-yue-mo-shi\" class=\"header-anchor\"></a><span id=\"ding-yue-mo-shi\">订阅模式</span></h3><p>订阅模式的设计主要有两个结构，一个是存放订阅事件的数组，还有添加订阅事件的方法，广播执行订阅事件的方法。</p>\n<p>例： </p>\n<pre><code>var event = &#123;\n    // 存放订阅事件的数组队列\n    clientList: [],\n    // 添加订阅事件的方法\n    listen: function( key, fn ) &#123;\n        // key 是订阅事件的代号标志，比如login表示登录订阅事件，\n        // loadFail表示读取失败订阅事件\n        // fn 是要订阅事件触发时执行的函数\n        if (!this.clientList[ key ]) &#123;\n            this.clientList[ key ] = []\n        &#125;\n        // 把订阅消息添加到缓存列表\n        this.clientList[ key ].push( fn );\n    &#125;,\n    trigger: function() &#123;\n        var key = Array.prototype.shift.call( arguments )\n            fns = this.clientList[ key ]\n        \n            if ( !fns || fns.length === 0 ) &#123; // 如果没有绑定对应的消息\n                return false\n            &#125;\n        \n            for ( var i = 0, fn; fn = fns[ i++ ];) &#123;\n                fn.apply( this, arguments )  // arguments 是 trigger 是带上的参数\n            &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>我们来测试一下上面的代码：<br>首先定义一个installEvent函数让我们可以给所有对象都动态添加发布-订阅功能（但是这个并不是必须的，不过一般都会声明一个方便调用）</p>\n<pre><code>var installEvent = function( obj ) &#123;\n    for ( var i in event ) &#123;\n        obj[ i ] = event[ i ];\n    &#125;\n&#125;\n</code></pre>\n<p>假设一个场景，在课堂上老师个学生布置作业，然后等我学生到做作业的时间的时候，就开始做老师发布的作业。在这里老师是订阅者，学生是发布者。</p>\n<pre><code>// 先给老师添加发布订阅功能\nvar teacher = &#123;&#125;\ninstallEvent( teacher )\n\n// 老师备课时先定义好将要布置的作业\nfunction doMath() &#123;\n    console.log( &#39;do Math homework&#39; )\n&#125;\n\nfunction doMathTest() &#123;\n    console.log( &#39;do Math test homework&#39; )\n&#125;\n\nfunction doEnglish() &#123;\n    console.log( &#39;do Englisth homework&#39; )\n&#125;\n\n// 在课堂上老师发布作业\nteacher.listen( &#39;Math&#39;, function() &#123;\n    doMath();\n&#125;)\n\nteacher.listen( &#39;Math&#39;, function() &#123;\n    doMathTest()\n&#125;)\n\nteacher.listen( &#39;English&#39;, function() &#123;\n    do English()\n&#125;)\n\n// 做作业的时间到了，学生做老师发布的作业\n// 用if来假设条件成立，可以去掉\nif ( new Date().now === 8888 ) &#123;\n    teacher.trigger( &#39;Math&#39; )\n    teacher.trigger( &#39;English&#39; )\n&#125;\n</code></pre>\n<p>发布订阅模式还很适合协作开发，比如上面的例子，老师只需要负责这天需要做哪科作业（Math, English)，做哪一题(doMath, doMathTest, doEnglish)。而学生只需要负责到点就去完成作业。</p>\n<h3><a href=\"#zhong-jie-zhe-mo-shi\" class=\"header-anchor\"></a><span id=\"zhong-jie-zhe-mo-shi\">中介者模式</span></h3><p>中介者就是把许多相关联的对象进行解耦。有时候对象与对象之间的操作会互相影响，有些对象要在其他对象改变的时候做出相应的响应，这个时候就要用到中介者模式。</p>\n<p>中介者模式一般有两种实现方式：</p>\n<ul>\n<li>利用发布-订阅模式。</li>\n<li>中介者开放一些接口给其它对象调用，而具体实现的逻辑在中介者中实现，然后中介者把执行后的结果发送给其它对象。</li>\n</ul>\n<p>考虑一个现实的一个例子：<br>这手机购买的过程中，可以选择手机的颜色和数量，同时在页面会有相应手机库存的显示，然后页面底下的购习按钮会根据库存等情况作出不同的展示。</p>\n<p>假设有这几种规格的手机：</p>\n<pre><code>var goods = &#123;\n    &quot;red&quot;: 3,\n    &quot;blue: 6\n&#125;\n</code></pre>\n<p>粗略地把上面分成以下几种情况：</p>\n<ol>\n<li>选择红色手机，买4个，显示库存不足，购买按钮不可点</li>\n<li>选择蓝色手机，买5个，显示库存充足，购买按钮可点</li>\n<li>不有选择颜色或者数量的时候，购买按钮不可点</li>\n</ol>\n<p>以下进行编码：</p>\n<p>页面HTML代码：</p>\n<pre><code>选择颜色： \n&lt;select name=&quot;&quot; id=&quot;colorSelect&quot;&gt;\n    &lt;option value=&quot;&quot;&gt;请选择&lt;/option&gt;\n    &lt;option value=&quot;red&quot;&gt;红色&lt;/option&gt;\n    &lt;option value=&quot;blue&quot;&gt;蓝色&lt;/option&gt;\n&lt;/select&gt;\n输入购买数量：\n&lt;input type=&quot;text&quot; id=&quot;numberInput&quot;&gt;\n您选择了颜色：\n&lt;div id=&quot;colorInfo&quot;&gt;&lt;/div&gt;&lt;br/&gt;\n您输入了数量：\n&lt;div id=&quot;nubmerInfo&quot;&gt;&lt;/div&gt;\n您输入了容量：\n&lt;div id=&quot;momeryInfo&quot;&gt;&lt;/div&gt;\n</code></pre>\n<p>先定义商品规格：</p>\n<pre><code>var goods = &#123;\n    &quot;red|32G&quot;: 3,\n    &quot;red|64G&quot;: 0,\n    &quot;blue|32G&quot;: 1,\n    &quot;blue|16G&quot;: 6\n&#125;\n</code></pre>\n<p>定义中介者来作处理其中判断的逻辑，返回一个事件让其它关联对象调用。</p>\n<pre><code>var mediator = (function()&#123;\n    var colorSelect = document.getElementById(&#39;colorSelect&#39;)\n    var memorySelect = document.getElementById(&#39;memorySelect&#39;)\n    var numberInput = document.getElementById(&#39;numberInput&#39;)\n    var colorInfo = document.getElementById(&#39;colorInfo&#39;)\n    var memoryInfo = document.getElementById(&#39;memoryInfo&#39;)\n    var numberInfo = document.getElementById(&#39;numberInfo&#39;)\n    var nextBtn = document.getElementById(&#39;nextBtn&#39;)\n\n    return &#123;\n        changed: function(obj)&#123;\n            var color = colorSelect.value,  // 颜色\n                memory = memorySelect.value, // 内存\n                number = numberSelect.value, // 数量\n                stock = goods[ color + &#39;|&#39; + memory ];  // 颜色和内存对应的手机库存数量\n            \n            if ( obj === colorSelect ) &#123;\n                colorInfo.innerHTML = color\n            &#125; else if ( obj === memorySelect ) &#123;\n                memoryInfo.innerHTML = memory\n            &#125; else if ( obj === numberInput ) &#123;\n                numberInfo.innerHTML = number\n            &#125;\n\n            if ( !memory ) &#123;\n                nextBtn.disabled = true\n                nextBtn.innerHTML = &#39;请选择手机颜色&#39;\n                return\n            &#125;\n\n            if ( !memory ) &#123;\n                nextBtn.disabled = true\n                nextBtn.innerHTML = &#39;请选择内存大小&#39;\n                return\n            &#125;\n\n            if ( Number.isInteger ( number - 0 ) &amp;&amp; number &gt; 0 ) &#123;\n                nextBtn.disabled = true\n                nextBtn.innerHTML = &#39;请输入正确的购买数量&#39;\n                return\n            &#125;\n\n            nextBtn.disabled = false\n            nextBtn.innerHTML = &#39;放入购物车&#39;\n        &#125;\n    &#125;\n&#125;)()\n</code></pre>\n<p>当相对应的对象改变的时候，中介者就能通过响应作出正确的处理，而不用把所有的判断逻辑放在各个事件监听所触发的函数里。</p>\n<pre><code>colorSelect.onchange = function() &#123;\n    mediator.changed( this )\n&#125;\n\nmemorySelect.onchange = function() &#123;\n    mediator.changed( this )\n&#125;\n\nnumberInput.onchange = function() &#123;\n    mediator.changed( this )\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"<h2 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h2><h3 id=\"一、this、call-和-apply\"><a href=\"#一、this、call-和-apply\" class=\"headerlink\" title=\"一、this、call 和 apply\"></a>一、this、call 和 apply</h3><h4 id=\"this的指向\"><a href=\"#this的指向\" class=\"headerlink\" title=\"this的指向\"></a>this的指向</h4><p>除去不常用的with和eval的情况，具体到实际应用中，this的指向大致可以分为以下4种：</p>\n<ul>\n<li>作为对象的方法调用。</li>\n<li>作为普通函数调用。</li>\n<li>构造器调用。</li>\n<li>Function.prototype.call或Function.prototype.apply调用。</li>\n</ul>","more":"<ol>\n<li>作为对象的方法调用</li>\n</ol>\n<p>当函数作为对象的方法被调用时，this指向该对象：</p>\n<pre><code>var obj = &#123;\n    a: 1，\n    getA: function() &#123;\n        alert( this === obj );\n        alert( this.a );\n    &#125;\n&#125;\n\nobj.getA();\n// output: true\n// output: 1\n</code></pre>\n<ol start=\"2\">\n<li>作为普通函数调用</li>\n</ol>\n<p>当函数不作为对象的属性被调用时，也就是我们常说的普通函数方式，无论它在哪里调用，此时的this总是指向全局对象。在浏览器的JavaScript里，p个全局对象 是window对象。</p>\n<pre><code>window.name = &#39;golbalName&#39;;\n\nvar getName = function() &#123;\n    return this.name;\n&#125;;\n\nvar anotherGetName = function() &#123;\n    console.log(getName())\n&#125;\n\nconsole.log( getName()) ;\n// output: globalName\n\nanotherGetName();\n// output: globalName\n</code></pre>\n<p>或者</p>\n<pre><code>window.name = &#39;globalName&#39;;\n\nvar myObject = &#123;\n    name: &#39;sven&#39;,\n    getName: function()&#123;\n        return this.name;\n    &#125;;\n&#125;;\n\nvar getName = myObject.getName;\ncosnole.log( getName() );\n// output: globalName\n</code></pre>\n<ol start=\"3\">\n<li>有时候我们会遇到一些困扰，比如在div节点的事件函数内部，有一个局部的callback方法，callback被作为普通函数调用时，callback内部的this指向了window,但我们往往是想让它指向该div节点，见如下代码：</li>\n</ol>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div id=&quot;div1&quot;&gt;I am a div&lt;/div&gt;\n\n    &lt;script&gt;\n        window.id = &#39;window&#39;\n        document.getElementById(&#39;div1&#39;).onclick =function() &#123;\n            alert( this.id ); // output: div1\n            var callback =function() &#123;\n                alert( this.id ); // output: window\n            &#125;\n            callback()\n        &#125;\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p>此时有一种简单的解决方案，可以用一个变量保存div节点的引用：</p>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div id=&quot;div1&quot;&gt;I am a div&lt;/div&gt;\n\n    &lt;script&gt;\n        window.id = &#39;window&#39;\n        document.getElementById(&#39;div1&#39;).onclick =function() &#123;\n            var that = this\n            var callback =function() &#123;\n                alert( that.id ); // output: div1\n            &#125;\n            callback()\n        &#125;\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p>在ECMAScript5的strict模式下，这种情况下的this已经被规定为不会指向全局对象，而是undefined:</p>\n<pre><code>function func() &#123;\n    “use strict&quot;\n    alert( this ) // output: undefined\n&#125;\n</code></pre>\n<h3 id=\"二、闭包和高阶函数\"><a href=\"#二、闭包和高阶函数\" class=\"headerlink\" title=\"二、闭包和高阶函数\"></a>二、闭包和高阶函数</h3><h4 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h4><h2 id=\"设计模式\"><a href=\"#设计模式\" class=\"headerlink\" title=\"设计模式\"></a>设计模式</h2><h3 id=\"订阅模式\"><a href=\"#订阅模式\" class=\"headerlink\" title=\"订阅模式\"></a>订阅模式</h3><p>订阅模式的设计主要有两个结构，一个是存放订阅事件的数组，还有添加订阅事件的方法，广播执行订阅事件的方法。</p>\n<p>例： </p>\n<pre><code>var event = &#123;\n    // 存放订阅事件的数组队列\n    clientList: [],\n    // 添加订阅事件的方法\n    listen: function( key, fn ) &#123;\n        // key 是订阅事件的代号标志，比如login表示登录订阅事件，\n        // loadFail表示读取失败订阅事件\n        // fn 是要订阅事件触发时执行的函数\n        if (!this.clientList[ key ]) &#123;\n            this.clientList[ key ] = []\n        &#125;\n        // 把订阅消息添加到缓存列表\n        this.clientList[ key ].push( fn );\n    &#125;,\n    trigger: function() &#123;\n        var key = Array.prototype.shift.call( arguments )\n            fns = this.clientList[ key ]\n        \n            if ( !fns || fns.length === 0 ) &#123; // 如果没有绑定对应的消息\n                return false\n            &#125;\n        \n            for ( var i = 0, fn; fn = fns[ i++ ];) &#123;\n                fn.apply( this, arguments )  // arguments 是 trigger 是带上的参数\n            &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>我们来测试一下上面的代码：<br>首先定义一个installEvent函数让我们可以给所有对象都动态添加发布-订阅功能（但是这个并不是必须的，不过一般都会声明一个方便调用）</p>\n<pre><code>var installEvent = function( obj ) &#123;\n    for ( var i in event ) &#123;\n        obj[ i ] = event[ i ];\n    &#125;\n&#125;\n</code></pre>\n<p>假设一个场景，在课堂上老师个学生布置作业，然后等我学生到做作业的时间的时候，就开始做老师发布的作业。在这里老师是订阅者，学生是发布者。</p>\n<pre><code>// 先给老师添加发布订阅功能\nvar teacher = &#123;&#125;\ninstallEvent( teacher )\n\n// 老师备课时先定义好将要布置的作业\nfunction doMath() &#123;\n    console.log( &#39;do Math homework&#39; )\n&#125;\n\nfunction doMathTest() &#123;\n    console.log( &#39;do Math test homework&#39; )\n&#125;\n\nfunction doEnglish() &#123;\n    console.log( &#39;do Englisth homework&#39; )\n&#125;\n\n// 在课堂上老师发布作业\nteacher.listen( &#39;Math&#39;, function() &#123;\n    doMath();\n&#125;)\n\nteacher.listen( &#39;Math&#39;, function() &#123;\n    doMathTest()\n&#125;)\n\nteacher.listen( &#39;English&#39;, function() &#123;\n    do English()\n&#125;)\n\n// 做作业的时间到了，学生做老师发布的作业\n// 用if来假设条件成立，可以去掉\nif ( new Date().now === 8888 ) &#123;\n    teacher.trigger( &#39;Math&#39; )\n    teacher.trigger( &#39;English&#39; )\n&#125;\n</code></pre>\n<p>发布订阅模式还很适合协作开发，比如上面的例子，老师只需要负责这天需要做哪科作业（Math, English)，做哪一题(doMath, doMathTest, doEnglish)。而学生只需要负责到点就去完成作业。</p>\n<h3 id=\"中介者模式\"><a href=\"#中介者模式\" class=\"headerlink\" title=\"中介者模式\"></a>中介者模式</h3><p>中介者就是把许多相关联的对象进行解耦。有时候对象与对象之间的操作会互相影响，有些对象要在其他对象改变的时候做出相应的响应，这个时候就要用到中介者模式。</p>\n<p>中介者模式一般有两种实现方式：</p>\n<ul>\n<li>利用发布-订阅模式。</li>\n<li>中介者开放一些接口给其它对象调用，而具体实现的逻辑在中介者中实现，然后中介者把执行后的结果发送给其它对象。</li>\n</ul>\n<p>考虑一个现实的一个例子：<br>这手机购买的过程中，可以选择手机的颜色和数量，同时在页面会有相应手机库存的显示，然后页面底下的购习按钮会根据库存等情况作出不同的展示。</p>\n<p>假设有这几种规格的手机：</p>\n<pre><code>var goods = &#123;\n    &quot;red&quot;: 3,\n    &quot;blue: 6\n&#125;\n</code></pre>\n<p>粗略地把上面分成以下几种情况：</p>\n<ol>\n<li>选择红色手机，买4个，显示库存不足，购买按钮不可点</li>\n<li>选择蓝色手机，买5个，显示库存充足，购买按钮可点</li>\n<li>不有选择颜色或者数量的时候，购买按钮不可点</li>\n</ol>\n<p>以下进行编码：</p>\n<p>页面HTML代码：</p>\n<pre><code>选择颜色： \n&lt;select name=&quot;&quot; id=&quot;colorSelect&quot;&gt;\n    &lt;option value=&quot;&quot;&gt;请选择&lt;/option&gt;\n    &lt;option value=&quot;red&quot;&gt;红色&lt;/option&gt;\n    &lt;option value=&quot;blue&quot;&gt;蓝色&lt;/option&gt;\n&lt;/select&gt;\n输入购买数量：\n&lt;input type=&quot;text&quot; id=&quot;numberInput&quot;&gt;\n您选择了颜色：\n&lt;div id=&quot;colorInfo&quot;&gt;&lt;/div&gt;&lt;br/&gt;\n您输入了数量：\n&lt;div id=&quot;nubmerInfo&quot;&gt;&lt;/div&gt;\n您输入了容量：\n&lt;div id=&quot;momeryInfo&quot;&gt;&lt;/div&gt;\n</code></pre>\n<p>先定义商品规格：</p>\n<pre><code>var goods = &#123;\n    &quot;red|32G&quot;: 3,\n    &quot;red|64G&quot;: 0,\n    &quot;blue|32G&quot;: 1,\n    &quot;blue|16G&quot;: 6\n&#125;\n</code></pre>\n<p>定义中介者来作处理其中判断的逻辑，返回一个事件让其它关联对象调用。</p>\n<pre><code>var mediator = (function()&#123;\n    var colorSelect = document.getElementById(&#39;colorSelect&#39;)\n    var memorySelect = document.getElementById(&#39;memorySelect&#39;)\n    var numberInput = document.getElementById(&#39;numberInput&#39;)\n    var colorInfo = document.getElementById(&#39;colorInfo&#39;)\n    var memoryInfo = document.getElementById(&#39;memoryInfo&#39;)\n    var numberInfo = document.getElementById(&#39;numberInfo&#39;)\n    var nextBtn = document.getElementById(&#39;nextBtn&#39;)\n\n    return &#123;\n        changed: function(obj)&#123;\n            var color = colorSelect.value,  // 颜色\n                memory = memorySelect.value, // 内存\n                number = numberSelect.value, // 数量\n                stock = goods[ color + &#39;|&#39; + memory ];  // 颜色和内存对应的手机库存数量\n            \n            if ( obj === colorSelect ) &#123;\n                colorInfo.innerHTML = color\n            &#125; else if ( obj === memorySelect ) &#123;\n                memoryInfo.innerHTML = memory\n            &#125; else if ( obj === numberInput ) &#123;\n                numberInfo.innerHTML = number\n            &#125;\n\n            if ( !memory ) &#123;\n                nextBtn.disabled = true\n                nextBtn.innerHTML = &#39;请选择手机颜色&#39;\n                return\n            &#125;\n\n            if ( !memory ) &#123;\n                nextBtn.disabled = true\n                nextBtn.innerHTML = &#39;请选择内存大小&#39;\n                return\n            &#125;\n\n            if ( Number.isInteger ( number - 0 ) &amp;&amp; number &gt; 0 ) &#123;\n                nextBtn.disabled = true\n                nextBtn.innerHTML = &#39;请输入正确的购买数量&#39;\n                return\n            &#125;\n\n            nextBtn.disabled = false\n            nextBtn.innerHTML = &#39;放入购物车&#39;\n        &#125;\n    &#125;\n&#125;)()\n</code></pre>\n<p>当相对应的对象改变的时候，中介者就能通过响应作出正确的处理，而不用把所有的判断逻辑放在各个事件监听所触发的函数里。</p>\n<pre><code>colorSelect.onchange = function() &#123;\n    mediator.changed( this )\n&#125;\n\nmemorySelect.onchange = function() &#123;\n    mediator.changed( this )\n&#125;\n\nnumberInput.onchange = function() &#123;\n    mediator.changed( this )\n&#125;\n</code></pre>"},{"title":"Javascript 数据类型","date":"2017-08-06T15:14:00.000Z","_content":"\n&emsp;&emsp;*本文摘录于Javascript高级程序设计（Professional JavaScript for Web Developers）并加上了自己的一些理解，如发现本文有什么错误之处，请麻烦通过以下方式联系我作修正，谢谢!*\n&emsp;&emsp;*微信号: kuntang9080*\n&emsp;&emsp;*邮箱：kuntang@163.com*\n___\n\nECMAScript中有5种简单数据类型（也称基本数据类型）：Undefined、Null、Boolean、Number、String。还有一种复杂数据类型：Object。\n\n<!-- more  -->\n\n---\n\n#### typeof 操作符\n\n对一个值使用typeof操作符可能返回下列某个字符串\n\n| 返回值 | 说明 |\n|--------|--------|\n| undefined |  这个值没有定义    |\n| boolean   |  这个值是布尔值|\n|string|这个值是字符串|\n|number|这个值是数值|\n|object|这个值是对象或者null|\n|function|这个值是函数|\n\n==注意：当typeof返回是object的时候对应着两个值，因此不能用typeof来区分object类型和null类型，此时应该用instanceof()函数==\n\n---\n\n#### Undefined类型\n\nUndefined类型只有一个值，即undefined\n\n任何使用var声明但未对其加以初始化的变量都会赋以undefined值。\n\n```Javascript\nvar message = undefined;\nalert(message == undefined);\n// true\n```\n\n对未初始化的变量和未声明的变量使用typeof操作符都会返回undefined值。\n\n```Javascript\n// 只声明了message，没有声明age\nvar message;\n\nalert(typeof message);\n// undefined\nalert(typeof age);\n// undefined\n```\n\n==注意：因此我们应该保持对变量初始化时就赋值的好习惯，这样当我们做类型检测的时候就不会造成不必要的混乱==\n\n---\n\n#### Null 类型\n\nNull类型只有一个值，即null。从逻辑角度上看，null值表示一个空对象指针，而这也正是使用typeof操作符检测null会返回\"object\"的原因\n\n实际上undefined值是派生自null值的，因此\n\n```Javascript\nalert(null == undefined)\n// true\n```\n\n==如果一个声明了一个将来才会使用到的变量，那么我们应该显式地将它赋值null而不是其它值 ==\n\n---\n\n#####Number类型\n\n###### 1. 进制\n\n&emsp;&emsp;八进制字面值第一位必须为0，十六进制前两位必须为0x\n```Javascript\nvar octalNum = 070\n// 八进制的56\nvar hexNum = 0xA\n// 十六进制的10\n```\n\n######2. 其它进制转换为十进制\n\n&emsp;&emsp;其它进制转换为十进制我们可以用Number()或者parseInt()函数。因为Number()函数分的情况比较混乱，所以在很多情况下我们会用parseInt()来做进制转换。\n\nparseInt()函数提供第二个参数：转换时使用的基数（即多少进制）。例：\n```Javascript\nvar hexTo = parseInt(\"0xAF\", 16)\n// 175\nvar num1 = parseInt(\"10\", 2)\n// 2\nvar num2 = parseInt(\"10\", 8)\n// 8\nvar num3 = parseInt(\"10\", 16)\n// 16\n```\n\n######3. 浮点数值\n\n对于那些极大或者极小的数值，可以用e表示法（科学计数法）来表示。\n```Javascript\nvar floatNum = 3.125e7\n// 31250000\n```\n\n==注意：浮点数值的最高精度是17位小数，但在进行算术时其精度远远不如整数。比如0.1加0.2不等于0.3：==\n```Javascript\nalert(0.1 + 0.2)\n// 0.30000000000000004\nif (a + b == 0.3) {\t// 不要做这样的判断\n\talert(\"you got the 0.3\")\n}\n```\n\n如果要一定要做这样的判断，在此提供了一个解决方法\n```Javascript\nvar temp = (a * 10 + b * 10) / 10 \t//先将浮点数转化为整数作加法，然后再转为浮点数\nif (temp == 0.3) {\n\talert(\"you got the 0.3\")\n}\n```\n\n######4. NaN (Not a Number)\n\n- 任何涉及NaN的操作或运算都会返回NaN\n- NaN与任何值都不相等\n\n```Javascript\nalert(NaN / 10)\n// NaN\n\nalert(NaN == NaN)\n// false\n```\n\nisNaN()函数用来判断这个参数是否为NaN，当isNaN()接收到一个参数之后，会尝试将这个值转换为数值，任何不能被转换为数值的值都会导致这个函数返回true。\n```Javascript\nalert(isNaN(NaN))\n// true\nalert(isNaN(10))\n// false\nalert(isNaN(\"10\"))\n// false（转为数字10）\nalert(isNaN(\"blue\"))\n// true（不能转为数值）\nalert(isNaN(true))\n// false(true转为1)\n```\n在基于对象调用isNaN()函数时，会先调用对象的valueOf()方法，然后确定该方法返回的值是否可以转换为数值。如果不能，则基于这个**返回值**再调用toString()方法，再测试返回值。\n\n######5. 数值转换\n\n- Number()函数\n\n- parseInt()函数\n\n&emsp;&emsp;parseInt()函数在转换字符串时，会忽略字符串前面的空格，直至找到第一个非空格的字符。如果第一个字符就不是数字字符或者负号，就直接返回NaN。也就是说parseInt(\"a123\")返回NaN，第一个字符\"a\"不是数字字符或者负号；parseInt(\"12.3\")返回12，\".\"不是数字字符或者负号。\n\n- parseFloat()函数\n\n&emsp;&emsp;parseFloat()函数始终都会忽略前导的零。对十六进制格式的字符串始终返回0。\n\n---\n\n##### 6. String类型\n\n数值、布尔值、对象和字符串都有toString()方法，但是null和undefined值没有这个方法。\n在调用数值的toString()方法时，可以传递一个参数：输出的基数。通过这个基数可以使toString()方法输出以二进制、八进制、十六进制，乃至其他做生意有效进制格式表示的字符串值。\n\n```Javascript\nvar num = 10;\nalert(num.toString())\t// 10\nalert(num.toString(2))\t// 1010\nalert(num.toString(8))\t// 12\nalert(num.toString(10))\t// 10\nalert(num.toString(16))\t// a\n```\n\n在不知道要转换的值是不是null或undefined的情况下，可以使用转型函数String()，这个函数能够将任何类型的值转换的为字符串。String()函数遵循下列规则：\n\n- 如果有toString()方法，则调用该方法（没有参数）并返回相应的结果\n\n- 如果是null，则返回\"null\"\n\n- 如果是undefined，则返回\"undefined\"\n\n---\n\n##### 7. Object类型\n\nObject的每个实例都具有下列属性和方法。\n\n- constructor： 保存着用于创建当前对象的函数\n\n- hasOwnProperty(propertyName): 用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。其中，作为参数的属性名(propertyName)必须以字符串形式指定（例：o.hasOwnproperty(\"name\")）\n\n- isPrototypeOf(object)：用于检查传入的对象是否是当前对象的原型\n\n- propertyIsEnumerable(propertyName)：用于检查给定的属性是否能够使用for-in语句来枚举\n\n- toLocaleString()：返回对象的字符串表示，该字符串与执行环境的地区对应\n\n- toString()：返回对象的字符串表示\n\n- valueOf()：返回对象的字符串、数值或者布尔值表示。通常与toString()方法的返回值相同\n","source":"_posts/JavascriptDataType.md","raw":"title: Javascript 数据类型\ntags:\n  - 读书笔记\ncategories:\n  - JavaScript\n  - ''\ndate: 2017-08-06 23:14:00\n---\n\n&emsp;&emsp;*本文摘录于Javascript高级程序设计（Professional JavaScript for Web Developers）并加上了自己的一些理解，如发现本文有什么错误之处，请麻烦通过以下方式联系我作修正，谢谢!*\n&emsp;&emsp;*微信号: kuntang9080*\n&emsp;&emsp;*邮箱：kuntang@163.com*\n___\n\nECMAScript中有5种简单数据类型（也称基本数据类型）：Undefined、Null、Boolean、Number、String。还有一种复杂数据类型：Object。\n\n<!-- more  -->\n\n---\n\n#### typeof 操作符\n\n对一个值使用typeof操作符可能返回下列某个字符串\n\n| 返回值 | 说明 |\n|--------|--------|\n| undefined |  这个值没有定义    |\n| boolean   |  这个值是布尔值|\n|string|这个值是字符串|\n|number|这个值是数值|\n|object|这个值是对象或者null|\n|function|这个值是函数|\n\n==注意：当typeof返回是object的时候对应着两个值，因此不能用typeof来区分object类型和null类型，此时应该用instanceof()函数==\n\n---\n\n#### Undefined类型\n\nUndefined类型只有一个值，即undefined\n\n任何使用var声明但未对其加以初始化的变量都会赋以undefined值。\n\n```Javascript\nvar message = undefined;\nalert(message == undefined);\n// true\n```\n\n对未初始化的变量和未声明的变量使用typeof操作符都会返回undefined值。\n\n```Javascript\n// 只声明了message，没有声明age\nvar message;\n\nalert(typeof message);\n// undefined\nalert(typeof age);\n// undefined\n```\n\n==注意：因此我们应该保持对变量初始化时就赋值的好习惯，这样当我们做类型检测的时候就不会造成不必要的混乱==\n\n---\n\n#### Null 类型\n\nNull类型只有一个值，即null。从逻辑角度上看，null值表示一个空对象指针，而这也正是使用typeof操作符检测null会返回\"object\"的原因\n\n实际上undefined值是派生自null值的，因此\n\n```Javascript\nalert(null == undefined)\n// true\n```\n\n==如果一个声明了一个将来才会使用到的变量，那么我们应该显式地将它赋值null而不是其它值 ==\n\n---\n\n#####Number类型\n\n###### 1. 进制\n\n&emsp;&emsp;八进制字面值第一位必须为0，十六进制前两位必须为0x\n```Javascript\nvar octalNum = 070\n// 八进制的56\nvar hexNum = 0xA\n// 十六进制的10\n```\n\n######2. 其它进制转换为十进制\n\n&emsp;&emsp;其它进制转换为十进制我们可以用Number()或者parseInt()函数。因为Number()函数分的情况比较混乱，所以在很多情况下我们会用parseInt()来做进制转换。\n\nparseInt()函数提供第二个参数：转换时使用的基数（即多少进制）。例：\n```Javascript\nvar hexTo = parseInt(\"0xAF\", 16)\n// 175\nvar num1 = parseInt(\"10\", 2)\n// 2\nvar num2 = parseInt(\"10\", 8)\n// 8\nvar num3 = parseInt(\"10\", 16)\n// 16\n```\n\n######3. 浮点数值\n\n对于那些极大或者极小的数值，可以用e表示法（科学计数法）来表示。\n```Javascript\nvar floatNum = 3.125e7\n// 31250000\n```\n\n==注意：浮点数值的最高精度是17位小数，但在进行算术时其精度远远不如整数。比如0.1加0.2不等于0.3：==\n```Javascript\nalert(0.1 + 0.2)\n// 0.30000000000000004\nif (a + b == 0.3) {\t// 不要做这样的判断\n\talert(\"you got the 0.3\")\n}\n```\n\n如果要一定要做这样的判断，在此提供了一个解决方法\n```Javascript\nvar temp = (a * 10 + b * 10) / 10 \t//先将浮点数转化为整数作加法，然后再转为浮点数\nif (temp == 0.3) {\n\talert(\"you got the 0.3\")\n}\n```\n\n######4. NaN (Not a Number)\n\n- 任何涉及NaN的操作或运算都会返回NaN\n- NaN与任何值都不相等\n\n```Javascript\nalert(NaN / 10)\n// NaN\n\nalert(NaN == NaN)\n// false\n```\n\nisNaN()函数用来判断这个参数是否为NaN，当isNaN()接收到一个参数之后，会尝试将这个值转换为数值，任何不能被转换为数值的值都会导致这个函数返回true。\n```Javascript\nalert(isNaN(NaN))\n// true\nalert(isNaN(10))\n// false\nalert(isNaN(\"10\"))\n// false（转为数字10）\nalert(isNaN(\"blue\"))\n// true（不能转为数值）\nalert(isNaN(true))\n// false(true转为1)\n```\n在基于对象调用isNaN()函数时，会先调用对象的valueOf()方法，然后确定该方法返回的值是否可以转换为数值。如果不能，则基于这个**返回值**再调用toString()方法，再测试返回值。\n\n######5. 数值转换\n\n- Number()函数\n\n- parseInt()函数\n\n&emsp;&emsp;parseInt()函数在转换字符串时，会忽略字符串前面的空格，直至找到第一个非空格的字符。如果第一个字符就不是数字字符或者负号，就直接返回NaN。也就是说parseInt(\"a123\")返回NaN，第一个字符\"a\"不是数字字符或者负号；parseInt(\"12.3\")返回12，\".\"不是数字字符或者负号。\n\n- parseFloat()函数\n\n&emsp;&emsp;parseFloat()函数始终都会忽略前导的零。对十六进制格式的字符串始终返回0。\n\n---\n\n##### 6. String类型\n\n数值、布尔值、对象和字符串都有toString()方法，但是null和undefined值没有这个方法。\n在调用数值的toString()方法时，可以传递一个参数：输出的基数。通过这个基数可以使toString()方法输出以二进制、八进制、十六进制，乃至其他做生意有效进制格式表示的字符串值。\n\n```Javascript\nvar num = 10;\nalert(num.toString())\t// 10\nalert(num.toString(2))\t// 1010\nalert(num.toString(8))\t// 12\nalert(num.toString(10))\t// 10\nalert(num.toString(16))\t// a\n```\n\n在不知道要转换的值是不是null或undefined的情况下，可以使用转型函数String()，这个函数能够将任何类型的值转换的为字符串。String()函数遵循下列规则：\n\n- 如果有toString()方法，则调用该方法（没有参数）并返回相应的结果\n\n- 如果是null，则返回\"null\"\n\n- 如果是undefined，则返回\"undefined\"\n\n---\n\n##### 7. Object类型\n\nObject的每个实例都具有下列属性和方法。\n\n- constructor： 保存着用于创建当前对象的函数\n\n- hasOwnProperty(propertyName): 用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。其中，作为参数的属性名(propertyName)必须以字符串形式指定（例：o.hasOwnproperty(\"name\")）\n\n- isPrototypeOf(object)：用于检查传入的对象是否是当前对象的原型\n\n- propertyIsEnumerable(propertyName)：用于检查给定的属性是否能够使用for-in语句来枚举\n\n- toLocaleString()：返回对象的字符串表示，该字符串与执行环境的地区对应\n\n- toString()：返回对象的字符串表示\n\n- valueOf()：返回对象的字符串、数值或者布尔值表示。通常与toString()方法的返回值相同\n","slug":"JavascriptDataType","published":1,"updated":"2023-04-11T03:30:27.111Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgbppebd0016bvchgw0fcoyz","content":"<p>&amp;emsp;&amp;emsp;<em>本文摘录于Javascript高级程序设计（Professional JavaScript for Web Developers）并加上了自己的一些理解，如发现本文有什么错误之处，请麻烦通过以下方式联系我作修正，谢谢!</em><br>&amp;emsp;&amp;emsp;<em>微信号: kuntang9080</em><br>&amp;emsp;&amp;emsp;<em>邮箱：<a href=\"mailto:&#x6b;&#117;&#x6e;&#116;&#x61;&#110;&#x67;&#x40;&#x31;&#54;&#51;&#46;&#x63;&#111;&#109;\">&#x6b;&#117;&#x6e;&#116;&#x61;&#110;&#x67;&#x40;&#x31;&#54;&#51;&#46;&#x63;&#111;&#109;</a></em></p>\n<hr>\n<p>ECMAScript中有5种简单数据类型（也称基本数据类型）：Undefined、Null、Boolean、Number、String。还有一种复杂数据类型：Object。</p>\n<!-- more  -->\n\n<hr>\n<h4><a href=\"#typeof-cao-zuo-fu\" class=\"header-anchor\"></a><span id=\"typeof-cao-zuo-fu\">typeof 操作符</span></h4><p>对一个值使用typeof操作符可能返回下列某个字符串</p>\n<table>\n<thead>\n<tr>\n<th>返回值</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>undefined</td>\n<td>这个值没有定义</td>\n</tr>\n<tr>\n<td>boolean</td>\n<td>这个值是布尔值</td>\n</tr>\n<tr>\n<td>string</td>\n<td>这个值是字符串</td>\n</tr>\n<tr>\n<td>number</td>\n<td>这个值是数值</td>\n</tr>\n<tr>\n<td>object</td>\n<td>这个值是对象或者null</td>\n</tr>\n<tr>\n<td>function</td>\n<td>这个值是函数</td>\n</tr>\n</tbody></table>\n<p>&#x3D;&#x3D;注意：当typeof返回是object的时候对应着两个值，因此不能用typeof来区分object类型和null类型，此时应该用instanceof()函数&#x3D;&#x3D;</p>\n<hr>\n<h4><a href=\"#undefined-lei-xing\" class=\"header-anchor\"></a><span id=\"undefined-lei-xing\">Undefined类型</span></h4><p>Undefined类型只有一个值，即undefined</p>\n<p>任何使用var声明但未对其加以初始化的变量都会赋以undefined值。</p>\n<pre><code class=\"Javascript\">var message = undefined;\nalert(message == undefined);\n// true\n</code></pre>\n<p>对未初始化的变量和未声明的变量使用typeof操作符都会返回undefined值。</p>\n<pre><code class=\"Javascript\">// 只声明了message，没有声明age\nvar message;\n\nalert(typeof message);\n// undefined\nalert(typeof age);\n// undefined\n</code></pre>\n<p>&#x3D;&#x3D;注意：因此我们应该保持对变量初始化时就赋值的好习惯，这样当我们做类型检测的时候就不会造成不必要的混乱&#x3D;&#x3D;</p>\n<hr>\n<h4><a href=\"#null-lei-xing\" class=\"header-anchor\"></a><span id=\"null-lei-xing\">Null 类型</span></h4><p>Null类型只有一个值，即null。从逻辑角度上看，null值表示一个空对象指针，而这也正是使用typeof操作符检测null会返回”object”的原因</p>\n<p>实际上undefined值是派生自null值的，因此</p>\n<pre><code class=\"Javascript\">alert(null == undefined)\n// true\n</code></pre>\n<p>&#x3D;&#x3D;如果一个声明了一个将来才会使用到的变量，那么我们应该显式地将它赋值null而不是其它值 &#x3D;&#x3D;</p>\n<hr>\n<p>#####Number类型</p>\n<h6><a href=\"#1-jin-zhi\" class=\"header-anchor\"></a><span id=\"1-jin-zhi\">1. 进制</span></h6><p>&amp;emsp;&amp;emsp;八进制字面值第一位必须为0，十六进制前两位必须为0x</p>\n<pre><code class=\"Javascript\">var octalNum = 070\n// 八进制的56\nvar hexNum = 0xA\n// 十六进制的10\n</code></pre>\n<p>######2. 其它进制转换为十进制</p>\n<p>&amp;emsp;&amp;emsp;其它进制转换为十进制我们可以用Number()或者parseInt()函数。因为Number()函数分的情况比较混乱，所以在很多情况下我们会用parseInt()来做进制转换。</p>\n<p>parseInt()函数提供第二个参数：转换时使用的基数（即多少进制）。例：</p>\n<pre><code class=\"Javascript\">var hexTo = parseInt(&quot;0xAF&quot;, 16)\n// 175\nvar num1 = parseInt(&quot;10&quot;, 2)\n// 2\nvar num2 = parseInt(&quot;10&quot;, 8)\n// 8\nvar num3 = parseInt(&quot;10&quot;, 16)\n// 16\n</code></pre>\n<p>######3. 浮点数值</p>\n<p>对于那些极大或者极小的数值，可以用e表示法（科学计数法）来表示。</p>\n<pre><code class=\"Javascript\">var floatNum = 3.125e7\n// 31250000\n</code></pre>\n<p>&#x3D;&#x3D;注意：浮点数值的最高精度是17位小数，但在进行算术时其精度远远不如整数。比如0.1加0.2不等于0.3：&#x3D;&#x3D;</p>\n<pre><code class=\"Javascript\">alert(0.1 + 0.2)\n// 0.30000000000000004\nif (a + b == 0.3) &#123;\t// 不要做这样的判断\n    alert(&quot;you got the 0.3&quot;)\n&#125;\n</code></pre>\n<p>如果要一定要做这样的判断，在此提供了一个解决方法</p>\n<pre><code class=\"Javascript\">var temp = (a * 10 + b * 10) / 10 \t//先将浮点数转化为整数作加法，然后再转为浮点数\nif (temp == 0.3) &#123;\n    alert(&quot;you got the 0.3&quot;)\n&#125;\n</code></pre>\n<p>######4. NaN (Not a Number)</p>\n<ul>\n<li>任何涉及NaN的操作或运算都会返回NaN</li>\n<li>NaN与任何值都不相等</li>\n</ul>\n<pre><code class=\"Javascript\">alert(NaN / 10)\n// NaN\n\nalert(NaN == NaN)\n// false\n</code></pre>\n<p>isNaN()函数用来判断这个参数是否为NaN，当isNaN()接收到一个参数之后，会尝试将这个值转换为数值，任何不能被转换为数值的值都会导致这个函数返回true。</p>\n<pre><code class=\"Javascript\">alert(isNaN(NaN))\n// true\nalert(isNaN(10))\n// false\nalert(isNaN(&quot;10&quot;))\n// false（转为数字10）\nalert(isNaN(&quot;blue&quot;))\n// true（不能转为数值）\nalert(isNaN(true))\n// false(true转为1)\n</code></pre>\n<p>在基于对象调用isNaN()函数时，会先调用对象的valueOf()方法，然后确定该方法返回的值是否可以转换为数值。如果不能，则基于这个<strong>返回值</strong>再调用toString()方法，再测试返回值。</p>\n<p>######5. 数值转换</p>\n<ul>\n<li><p>Number()函数</p>\n</li>\n<li><p>parseInt()函数</p>\n</li>\n</ul>\n<p>&amp;emsp;&amp;emsp;parseInt()函数在转换字符串时，会忽略字符串前面的空格，直至找到第一个非空格的字符。如果第一个字符就不是数字字符或者负号，就直接返回NaN。也就是说parseInt(“a123”)返回NaN，第一个字符”a”不是数字字符或者负号；parseInt(“12.3”)返回12，”.”不是数字字符或者负号。</p>\n<ul>\n<li>parseFloat()函数</li>\n</ul>\n<p>&amp;emsp;&amp;emsp;parseFloat()函数始终都会忽略前导的零。对十六进制格式的字符串始终返回0。</p>\n<hr>\n<h5><a href=\"#6-string-lei-xing\" class=\"header-anchor\"></a><span id=\"6-string-lei-xing\">6. String类型</span></h5><p>数值、布尔值、对象和字符串都有toString()方法，但是null和undefined值没有这个方法。<br>在调用数值的toString()方法时，可以传递一个参数：输出的基数。通过这个基数可以使toString()方法输出以二进制、八进制、十六进制，乃至其他做生意有效进制格式表示的字符串值。</p>\n<pre><code class=\"Javascript\">var num = 10;\nalert(num.toString())\t// 10\nalert(num.toString(2))\t// 1010\nalert(num.toString(8))\t// 12\nalert(num.toString(10))\t// 10\nalert(num.toString(16))\t// a\n</code></pre>\n<p>在不知道要转换的值是不是null或undefined的情况下，可以使用转型函数String()，这个函数能够将任何类型的值转换的为字符串。String()函数遵循下列规则：</p>\n<ul>\n<li><p>如果有toString()方法，则调用该方法（没有参数）并返回相应的结果</p>\n</li>\n<li><p>如果是null，则返回”null”</p>\n</li>\n<li><p>如果是undefined，则返回”undefined”</p>\n</li>\n</ul>\n<hr>\n<h5><a href=\"#7-object-lei-xing\" class=\"header-anchor\"></a><span id=\"7-object-lei-xing\">7. Object类型</span></h5><p>Object的每个实例都具有下列属性和方法。</p>\n<ul>\n<li><p>constructor： 保存着用于创建当前对象的函数</p>\n</li>\n<li><p>hasOwnProperty(propertyName): 用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。其中，作为参数的属性名(propertyName)必须以字符串形式指定（例：o.hasOwnproperty(“name”)）</p>\n</li>\n<li><p>isPrototypeOf(object)：用于检查传入的对象是否是当前对象的原型</p>\n</li>\n<li><p>propertyIsEnumerable(propertyName)：用于检查给定的属性是否能够使用for-in语句来枚举</p>\n</li>\n<li><p>toLocaleString()：返回对象的字符串表示，该字符串与执行环境的地区对应</p>\n</li>\n<li><p>toString()：返回对象的字符串表示</p>\n</li>\n<li><p>valueOf()：返回对象的字符串、数值或者布尔值表示。通常与toString()方法的返回值相同</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>&amp;emsp;&amp;emsp;<em>本文摘录于Javascript高级程序设计（Professional JavaScript for Web Developers）并加上了自己的一些理解，如发现本文有什么错误之处，请麻烦通过以下方式联系我作修正，谢谢!</em><br>&amp;emsp;&amp;emsp;<em>微信号: kuntang9080</em><br>&amp;emsp;&amp;emsp;<em>邮箱：<a href=\"mailto:&#x6b;&#117;&#x6e;&#116;&#x61;&#110;&#x67;&#x40;&#x31;&#54;&#51;&#46;&#x63;&#111;&#109;\">&#x6b;&#117;&#x6e;&#116;&#x61;&#110;&#x67;&#x40;&#x31;&#54;&#51;&#46;&#x63;&#111;&#109;</a></em></p>\n<hr>\n<p>ECMAScript中有5种简单数据类型（也称基本数据类型）：Undefined、Null、Boolean、Number、String。还有一种复杂数据类型：Object。</p>\n<!-- more  -->\n\n<hr>\n<h4 id=\"typeof-操作符\"><a href=\"#typeof-操作符\" class=\"headerlink\" title=\"typeof 操作符\"></a>typeof 操作符</h4><p>对一个值使用typeof操作符可能返回下列某个字符串</p>\n<table>\n<thead>\n<tr>\n<th>返回值</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>undefined</td>\n<td>这个值没有定义</td>\n</tr>\n<tr>\n<td>boolean</td>\n<td>这个值是布尔值</td>\n</tr>\n<tr>\n<td>string</td>\n<td>这个值是字符串</td>\n</tr>\n<tr>\n<td>number</td>\n<td>这个值是数值</td>\n</tr>\n<tr>\n<td>object</td>\n<td>这个值是对象或者null</td>\n</tr>\n<tr>\n<td>function</td>\n<td>这个值是函数</td>\n</tr>\n</tbody></table>\n<p>&#x3D;&#x3D;注意：当typeof返回是object的时候对应着两个值，因此不能用typeof来区分object类型和null类型，此时应该用instanceof()函数&#x3D;&#x3D;</p>\n<hr>\n<h4 id=\"Undefined类型\"><a href=\"#Undefined类型\" class=\"headerlink\" title=\"Undefined类型\"></a>Undefined类型</h4><p>Undefined类型只有一个值，即undefined</p>\n<p>任何使用var声明但未对其加以初始化的变量都会赋以undefined值。</p>\n<pre><code class=\"Javascript\">var message = undefined;\nalert(message == undefined);\n// true\n</code></pre>\n<p>对未初始化的变量和未声明的变量使用typeof操作符都会返回undefined值。</p>\n<pre><code class=\"Javascript\">// 只声明了message，没有声明age\nvar message;\n\nalert(typeof message);\n// undefined\nalert(typeof age);\n// undefined\n</code></pre>\n<p>&#x3D;&#x3D;注意：因此我们应该保持对变量初始化时就赋值的好习惯，这样当我们做类型检测的时候就不会造成不必要的混乱&#x3D;&#x3D;</p>\n<hr>\n<h4 id=\"Null-类型\"><a href=\"#Null-类型\" class=\"headerlink\" title=\"Null 类型\"></a>Null 类型</h4><p>Null类型只有一个值，即null。从逻辑角度上看，null值表示一个空对象指针，而这也正是使用typeof操作符检测null会返回”object”的原因</p>\n<p>实际上undefined值是派生自null值的，因此</p>\n<pre><code class=\"Javascript\">alert(null == undefined)\n// true\n</code></pre>\n<p>&#x3D;&#x3D;如果一个声明了一个将来才会使用到的变量，那么我们应该显式地将它赋值null而不是其它值 &#x3D;&#x3D;</p>\n<hr>\n<p>#####Number类型</p>\n<h6 id=\"1-进制\"><a href=\"#1-进制\" class=\"headerlink\" title=\"1. 进制\"></a>1. 进制</h6><p>&amp;emsp;&amp;emsp;八进制字面值第一位必须为0，十六进制前两位必须为0x</p>\n<pre><code class=\"Javascript\">var octalNum = 070\n// 八进制的56\nvar hexNum = 0xA\n// 十六进制的10\n</code></pre>\n<p>######2. 其它进制转换为十进制</p>\n<p>&amp;emsp;&amp;emsp;其它进制转换为十进制我们可以用Number()或者parseInt()函数。因为Number()函数分的情况比较混乱，所以在很多情况下我们会用parseInt()来做进制转换。</p>\n<p>parseInt()函数提供第二个参数：转换时使用的基数（即多少进制）。例：</p>\n<pre><code class=\"Javascript\">var hexTo = parseInt(&quot;0xAF&quot;, 16)\n// 175\nvar num1 = parseInt(&quot;10&quot;, 2)\n// 2\nvar num2 = parseInt(&quot;10&quot;, 8)\n// 8\nvar num3 = parseInt(&quot;10&quot;, 16)\n// 16\n</code></pre>\n<p>######3. 浮点数值</p>\n<p>对于那些极大或者极小的数值，可以用e表示法（科学计数法）来表示。</p>\n<pre><code class=\"Javascript\">var floatNum = 3.125e7\n// 31250000\n</code></pre>\n<p>&#x3D;&#x3D;注意：浮点数值的最高精度是17位小数，但在进行算术时其精度远远不如整数。比如0.1加0.2不等于0.3：&#x3D;&#x3D;</p>\n<pre><code class=\"Javascript\">alert(0.1 + 0.2)\n// 0.30000000000000004\nif (a + b == 0.3) &#123;\t// 不要做这样的判断\n    alert(&quot;you got the 0.3&quot;)\n&#125;\n</code></pre>\n<p>如果要一定要做这样的判断，在此提供了一个解决方法</p>\n<pre><code class=\"Javascript\">var temp = (a * 10 + b * 10) / 10 \t//先将浮点数转化为整数作加法，然后再转为浮点数\nif (temp == 0.3) &#123;\n    alert(&quot;you got the 0.3&quot;)\n&#125;\n</code></pre>\n<p>######4. NaN (Not a Number)</p>\n<ul>\n<li>任何涉及NaN的操作或运算都会返回NaN</li>\n<li>NaN与任何值都不相等</li>\n</ul>\n<pre><code class=\"Javascript\">alert(NaN / 10)\n// NaN\n\nalert(NaN == NaN)\n// false\n</code></pre>\n<p>isNaN()函数用来判断这个参数是否为NaN，当isNaN()接收到一个参数之后，会尝试将这个值转换为数值，任何不能被转换为数值的值都会导致这个函数返回true。</p>\n<pre><code class=\"Javascript\">alert(isNaN(NaN))\n// true\nalert(isNaN(10))\n// false\nalert(isNaN(&quot;10&quot;))\n// false（转为数字10）\nalert(isNaN(&quot;blue&quot;))\n// true（不能转为数值）\nalert(isNaN(true))\n// false(true转为1)\n</code></pre>\n<p>在基于对象调用isNaN()函数时，会先调用对象的valueOf()方法，然后确定该方法返回的值是否可以转换为数值。如果不能，则基于这个<strong>返回值</strong>再调用toString()方法，再测试返回值。</p>\n<p>######5. 数值转换</p>\n<ul>\n<li><p>Number()函数</p>\n</li>\n<li><p>parseInt()函数</p>\n</li>\n</ul>\n<p>&amp;emsp;&amp;emsp;parseInt()函数在转换字符串时，会忽略字符串前面的空格，直至找到第一个非空格的字符。如果第一个字符就不是数字字符或者负号，就直接返回NaN。也就是说parseInt(“a123”)返回NaN，第一个字符”a”不是数字字符或者负号；parseInt(“12.3”)返回12，”.”不是数字字符或者负号。</p>\n<ul>\n<li>parseFloat()函数</li>\n</ul>\n<p>&amp;emsp;&amp;emsp;parseFloat()函数始终都会忽略前导的零。对十六进制格式的字符串始终返回0。</p>\n<hr>\n<h5 id=\"6-String类型\"><a href=\"#6-String类型\" class=\"headerlink\" title=\"6. String类型\"></a>6. String类型</h5><p>数值、布尔值、对象和字符串都有toString()方法，但是null和undefined值没有这个方法。<br>在调用数值的toString()方法时，可以传递一个参数：输出的基数。通过这个基数可以使toString()方法输出以二进制、八进制、十六进制，乃至其他做生意有效进制格式表示的字符串值。</p>\n<pre><code class=\"Javascript\">var num = 10;\nalert(num.toString())\t// 10\nalert(num.toString(2))\t// 1010\nalert(num.toString(8))\t// 12\nalert(num.toString(10))\t// 10\nalert(num.toString(16))\t// a\n</code></pre>\n<p>在不知道要转换的值是不是null或undefined的情况下，可以使用转型函数String()，这个函数能够将任何类型的值转换的为字符串。String()函数遵循下列规则：</p>\n<ul>\n<li><p>如果有toString()方法，则调用该方法（没有参数）并返回相应的结果</p>\n</li>\n<li><p>如果是null，则返回”null”</p>\n</li>\n<li><p>如果是undefined，则返回”undefined”</p>\n</li>\n</ul>\n<hr>\n<h5 id=\"7-Object类型\"><a href=\"#7-Object类型\" class=\"headerlink\" title=\"7. Object类型\"></a>7. Object类型</h5><p>Object的每个实例都具有下列属性和方法。</p>\n<ul>\n<li><p>constructor： 保存着用于创建当前对象的函数</p>\n</li>\n<li><p>hasOwnProperty(propertyName): 用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。其中，作为参数的属性名(propertyName)必须以字符串形式指定（例：o.hasOwnproperty(“name”)）</p>\n</li>\n<li><p>isPrototypeOf(object)：用于检查传入的对象是否是当前对象的原型</p>\n</li>\n<li><p>propertyIsEnumerable(propertyName)：用于检查给定的属性是否能够使用for-in语句来枚举</p>\n</li>\n<li><p>toLocaleString()：返回对象的字符串表示，该字符串与执行环境的地区对应</p>\n</li>\n<li><p>toString()：返回对象的字符串表示</p>\n</li>\n<li><p>valueOf()：返回对象的字符串、数值或者布尔值表示。通常与toString()方法的返回值相同</p>\n</li>\n</ul>\n"},{"title":"软件测试","year":2017,"month":4,"day":1,"date":"2017-08-06T15:10:00.000Z","_content":"### 行业内的主要知识点\n#### 软件危机\n#### 软件测试的分类\n- 按测试阶段划分\n\n软件测试 = 程序 + 文档 + 数据\n程序主流方向 B/S架构和手机app\n\n<!-- more -->\n\n#### 软件项目流程\n- 可行性分析\n- 立项\n- 需求\n- 原型设计\n- 概要设计\n- 详细设计\n- 开发\n- 验收\n- 维护\n#### 接口测试\n- 后台和前台的数据\n- 后台和前台可以交互\n### 文档\n- 需求文档\n- 设计文档\n- 开发文档\n- 测试文档\n- 验收文档\n- 用户文档\n### 软件测试\n- 测试计划\n- 测试用例\n- 测试方案\n- 测试报告\n- 测试方案\n- 测试报告（总结）\n\n### 软件测试就是保证\n### 软件测试的分类\n- 通用软件产品\n- 电信行业\n- 金融证券行业\n- 游戏测试\n- 嵌入式软件测试\n- 电子商务软件测试\n\n### 岗位分类\n- 软件测试工程师\n- 硬件测试工程师\n- 自动化工程师\n- 性能测试工程师\n- 安全测试工程师\n\n### 软件测试人员的职责\n- 了解项目需求内容\n- 编写合理的测试计划\n- \n\n作业：\n1. 你对目前软件测试行业现状怎么看？\n2. 你觉得现在的测试人员能力水平如何？\n3. 你觉得作为测试人员有哪些素质和能力要求，你为什么会选择这个行业？\n\n### 软件缺陷管理\n\n#### 软件缺陷的定义\n- IEEE 1983 of IEEE Standard 729中对软件缺陷作了一个标准的定义：\n&emsp;&emsp; 从产品内部看，软件缺陷软件产品开发或维护过程中所存在的错误、毛病等各种总是从外部看，软件缺陷是系统所需要实现的某种功能的失效或违背。\n- 因此软件缺陷就是软件产品中所存在的问题，最终表现为用户需要的功能没有完全实现，没有满足用户的需求。\n\n#### 软件缺陷的表现\n- 功能、我没有实现或部分实现。\n- 设计不合理，功能我和明确，逻辑不清楚或存在矛盾。\n- 产品实际结果和所期望的结果不一样。\n- 没有达到需求规格说明书所规定的性能指标等。\n- 运行出错，包括运行中断、系统崩溃、界面混乱等。\n- 数据不正确、精度不够、不完整或格式不统一。\n- 用户不能接受的其他问题，如存取时间过长、界面不美观。\n- 硬件或系统软件上存在的其他问题。\n\n#### 软件缺陷示例\n- 计算器说明书一般声称该计算器将准确无误地进行加、减、乘、除运算。如果测试人员或用户选定了两个数值后，随意按下了“+”号键，结果没有任何反应。\n&emsp;&emsp;软件未达到软件需求规格说明书表明的功能\n- 若在进行测试时，发现除了规定的加、减、乘、除功能之外，还能够进行求平方根的埃，而这一功能并没有在说明书的功能中规定。\n&emsp;&emsp;软件的功能超出了软件需求规格说明书指明的范围\n- 若在测试过程中发现，因为电池没电而导致了计算不正确，但软件需求规格说明书未能指出在此情况下应如何进行处理。\n&emsp;&emsp;软件未达到软件需求规格说明书未指明而应达到的目标\n- 假如计算器说明书指明计算kkdi付出现崩溃、死锁或者停止反应，而在用户随意按、敲击键盘后，计算器停止接受输入或没有反应。\n&emsp;&emsp;软件出现了软件需求规格说明书指明不会出现的错误\n- 测试人员或最终用户发现计算器某些地方不好用，比如，按键太小、显示屏在亮光下无法看清等。\n&emsp;&emsp;软件测试人员认为软件难以理解、不易使用、运行速度慢，或者最终用户认为不好\n\n#### 软件缺陷产生的原因\n&emsp;软件缺陷产生是不可避免的，造成软件缺陷产生的原因主要归纳如下：\n- 需求解释或者记录错误\n- 用户需求定义错误 \n- 设计说明存在错误 \n- 编码说明、程序代码有误\n- 硬件或者软件系统上存在错误\n- 其他，如文档错误、内容不正确\n\n#### 软件缺陷的根源\n- 交流不充分\n&emsp;&emsp;客户与开发人员、开发人员与测试人员等 等\n- 软件的复杂性\n&emsp;&emsp;功能复杂、开发复杂、测试复杂\n- 开发人员的错误\n&emsp;&emsp;对需求的理解、开发压力、功能与经验\n- 需求的变化\n&emsp;&emsp;需求说明书、设计文档、程序的变更\n- 进度压力\n&emsp;&emsp;项目周期比较紧\n\n#### 缺陷发现的手段\n&emsp;一提到缺陷发现的手段，大家首先且基本能想到的就是测试。测试是一项重要的缺陷发现手段，但不是唯一的缺陷发现手段。缺陷发现的手段有如下：\n- 评审\n- QA\n- 客户\n\n#### 软件缺陷修的费用\n\n需求规格说明书、设计、编码、测试、发布，费用越来越高\n\n#### 软件缺陷的信息\n\n- 缺陷ID\n- 缺陷状态* ———— 缺陷状态指缺陷通过一个跟踪修复过程的进展情况\n- 缺陷标题*\n- 缺陷的严重程度* ———— 程度分为致命、较严重、严重、一般、低\n- 缺陷的优先级*\n- 缺陷所属模块*\n- 缺陷记录者\n- 缺陷提交时间\n- 缺陷处理人\n- 处理结果描述\n- 缺陷处理时间\n- 缺陷验证人\n- 缺陷结果描述\n- 缺陷详细描述*\n- 缺陷环境说明\n- 必要的附件\n\n作业：\n1。 \nBUG标题： 一句话描述BUG\nBUG的等级： 致命错误、严重错误、一般、较小、\n测试建议\n提交时间\n软件版本\n软件环境：win7/Android7\n产生概率： 100%\n产生模块\n处理人\n产生步骤： 1。。。2。。。3。。。\n期待结果\n\n#### 软件缺陷分类————BUG类型\n\n- 系统缺陷\n1.由于程序所引起的死机，异常退出\n2.程序死循环\n3.程序错误，不能执行正常工作或重要功能，使系统崩溃或资源不足\n- 数据缺陷\n1.数据计算错误\n2.数据约束错误\n3.数据输入、输出错误\n- 数据库缺陷\n1. 数据库发生死锁\n2. 数据库的表、缺省值未加约束条件\n3. 数据库连接错误\n4. 数据库中的表有过多的空字段\n- 接口缺陷\n1.数据通信错误\n2.程序接口错误\n- 功能缺陷\n1.功能无法实现\n2.功能实现错误\n- 安全性缺陷\n1.用户权限无法实现\n2.超时限制错误\n3.访问控制错误\n4.加密错误\n- 兼容性缺陷\n1.与需求文档配置兼容性不符合\n- 性能缺陷\n1.未达到预期的性能目标\n2.性能测试中出错，导致无法继续进行测试\n- 界面缺陷\n1.操作界面错误\n2.打印内容、格式错误\n3.删除操作未给出提示\n4.长时间操作未给出提示\n5.界面不规范\n- 建议\n1.功能建议\n2.操作建议","source":"_posts/SoftwareTesting.md","raw":"title: 软件测试\nyear: 2017\nmonth: 4\nday: 1\ntags:\n  - 读书笔记\ncategories: []\ndate: 2017-08-06 23:10:00\n---\n### 行业内的主要知识点\n#### 软件危机\n#### 软件测试的分类\n- 按测试阶段划分\n\n软件测试 = 程序 + 文档 + 数据\n程序主流方向 B/S架构和手机app\n\n<!-- more -->\n\n#### 软件项目流程\n- 可行性分析\n- 立项\n- 需求\n- 原型设计\n- 概要设计\n- 详细设计\n- 开发\n- 验收\n- 维护\n#### 接口测试\n- 后台和前台的数据\n- 后台和前台可以交互\n### 文档\n- 需求文档\n- 设计文档\n- 开发文档\n- 测试文档\n- 验收文档\n- 用户文档\n### 软件测试\n- 测试计划\n- 测试用例\n- 测试方案\n- 测试报告\n- 测试方案\n- 测试报告（总结）\n\n### 软件测试就是保证\n### 软件测试的分类\n- 通用软件产品\n- 电信行业\n- 金融证券行业\n- 游戏测试\n- 嵌入式软件测试\n- 电子商务软件测试\n\n### 岗位分类\n- 软件测试工程师\n- 硬件测试工程师\n- 自动化工程师\n- 性能测试工程师\n- 安全测试工程师\n\n### 软件测试人员的职责\n- 了解项目需求内容\n- 编写合理的测试计划\n- \n\n作业：\n1. 你对目前软件测试行业现状怎么看？\n2. 你觉得现在的测试人员能力水平如何？\n3. 你觉得作为测试人员有哪些素质和能力要求，你为什么会选择这个行业？\n\n### 软件缺陷管理\n\n#### 软件缺陷的定义\n- IEEE 1983 of IEEE Standard 729中对软件缺陷作了一个标准的定义：\n&emsp;&emsp; 从产品内部看，软件缺陷软件产品开发或维护过程中所存在的错误、毛病等各种总是从外部看，软件缺陷是系统所需要实现的某种功能的失效或违背。\n- 因此软件缺陷就是软件产品中所存在的问题，最终表现为用户需要的功能没有完全实现，没有满足用户的需求。\n\n#### 软件缺陷的表现\n- 功能、我没有实现或部分实现。\n- 设计不合理，功能我和明确，逻辑不清楚或存在矛盾。\n- 产品实际结果和所期望的结果不一样。\n- 没有达到需求规格说明书所规定的性能指标等。\n- 运行出错，包括运行中断、系统崩溃、界面混乱等。\n- 数据不正确、精度不够、不完整或格式不统一。\n- 用户不能接受的其他问题，如存取时间过长、界面不美观。\n- 硬件或系统软件上存在的其他问题。\n\n#### 软件缺陷示例\n- 计算器说明书一般声称该计算器将准确无误地进行加、减、乘、除运算。如果测试人员或用户选定了两个数值后，随意按下了“+”号键，结果没有任何反应。\n&emsp;&emsp;软件未达到软件需求规格说明书表明的功能\n- 若在进行测试时，发现除了规定的加、减、乘、除功能之外，还能够进行求平方根的埃，而这一功能并没有在说明书的功能中规定。\n&emsp;&emsp;软件的功能超出了软件需求规格说明书指明的范围\n- 若在测试过程中发现，因为电池没电而导致了计算不正确，但软件需求规格说明书未能指出在此情况下应如何进行处理。\n&emsp;&emsp;软件未达到软件需求规格说明书未指明而应达到的目标\n- 假如计算器说明书指明计算kkdi付出现崩溃、死锁或者停止反应，而在用户随意按、敲击键盘后，计算器停止接受输入或没有反应。\n&emsp;&emsp;软件出现了软件需求规格说明书指明不会出现的错误\n- 测试人员或最终用户发现计算器某些地方不好用，比如，按键太小、显示屏在亮光下无法看清等。\n&emsp;&emsp;软件测试人员认为软件难以理解、不易使用、运行速度慢，或者最终用户认为不好\n\n#### 软件缺陷产生的原因\n&emsp;软件缺陷产生是不可避免的，造成软件缺陷产生的原因主要归纳如下：\n- 需求解释或者记录错误\n- 用户需求定义错误 \n- 设计说明存在错误 \n- 编码说明、程序代码有误\n- 硬件或者软件系统上存在错误\n- 其他，如文档错误、内容不正确\n\n#### 软件缺陷的根源\n- 交流不充分\n&emsp;&emsp;客户与开发人员、开发人员与测试人员等 等\n- 软件的复杂性\n&emsp;&emsp;功能复杂、开发复杂、测试复杂\n- 开发人员的错误\n&emsp;&emsp;对需求的理解、开发压力、功能与经验\n- 需求的变化\n&emsp;&emsp;需求说明书、设计文档、程序的变更\n- 进度压力\n&emsp;&emsp;项目周期比较紧\n\n#### 缺陷发现的手段\n&emsp;一提到缺陷发现的手段，大家首先且基本能想到的就是测试。测试是一项重要的缺陷发现手段，但不是唯一的缺陷发现手段。缺陷发现的手段有如下：\n- 评审\n- QA\n- 客户\n\n#### 软件缺陷修的费用\n\n需求规格说明书、设计、编码、测试、发布，费用越来越高\n\n#### 软件缺陷的信息\n\n- 缺陷ID\n- 缺陷状态* ———— 缺陷状态指缺陷通过一个跟踪修复过程的进展情况\n- 缺陷标题*\n- 缺陷的严重程度* ———— 程度分为致命、较严重、严重、一般、低\n- 缺陷的优先级*\n- 缺陷所属模块*\n- 缺陷记录者\n- 缺陷提交时间\n- 缺陷处理人\n- 处理结果描述\n- 缺陷处理时间\n- 缺陷验证人\n- 缺陷结果描述\n- 缺陷详细描述*\n- 缺陷环境说明\n- 必要的附件\n\n作业：\n1。 \nBUG标题： 一句话描述BUG\nBUG的等级： 致命错误、严重错误、一般、较小、\n测试建议\n提交时间\n软件版本\n软件环境：win7/Android7\n产生概率： 100%\n产生模块\n处理人\n产生步骤： 1。。。2。。。3。。。\n期待结果\n\n#### 软件缺陷分类————BUG类型\n\n- 系统缺陷\n1.由于程序所引起的死机，异常退出\n2.程序死循环\n3.程序错误，不能执行正常工作或重要功能，使系统崩溃或资源不足\n- 数据缺陷\n1.数据计算错误\n2.数据约束错误\n3.数据输入、输出错误\n- 数据库缺陷\n1. 数据库发生死锁\n2. 数据库的表、缺省值未加约束条件\n3. 数据库连接错误\n4. 数据库中的表有过多的空字段\n- 接口缺陷\n1.数据通信错误\n2.程序接口错误\n- 功能缺陷\n1.功能无法实现\n2.功能实现错误\n- 安全性缺陷\n1.用户权限无法实现\n2.超时限制错误\n3.访问控制错误\n4.加密错误\n- 兼容性缺陷\n1.与需求文档配置兼容性不符合\n- 性能缺陷\n1.未达到预期的性能目标\n2.性能测试中出错，导致无法继续进行测试\n- 界面缺陷\n1.操作界面错误\n2.打印内容、格式错误\n3.删除操作未给出提示\n4.长时间操作未给出提示\n5.界面不规范\n- 建议\n1.功能建议\n2.操作建议","slug":"SoftwareTesting","published":1,"updated":"2023-04-11T03:30:27.111Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgbppebd0018bvch12ng2v9i","content":"<h3><a href=\"#xing-ye-nei-de-zhu-yao-zhi-shi-dian\" class=\"header-anchor\"></a><span id=\"xing-ye-nei-de-zhu-yao-zhi-shi-dian\">行业内的主要知识点</span></h3><h4><a href=\"#ruan-jian-wei-ji\" class=\"header-anchor\"></a><span id=\"ruan-jian-wei-ji\">软件危机</span></h4><h4><a href=\"#ruan-jian-ce-shi-de-fen-lei\" class=\"header-anchor\"></a><span id=\"ruan-jian-ce-shi-de-fen-lei\">软件测试的分类</span></h4><ul>\n<li>按测试阶段划分</li>\n</ul>\n<p>软件测试 &#x3D; 程序 + 文档 + 数据<br>程序主流方向 B&#x2F;S架构和手机app</p>\n<span id=\"more\"></span>\n\n<h4><a href=\"#ruan-jian-xiang-mu-liu-cheng\" class=\"header-anchor\"></a><span id=\"ruan-jian-xiang-mu-liu-cheng\">软件项目流程</span></h4><ul>\n<li>可行性分析</li>\n<li>立项</li>\n<li>需求</li>\n<li>原型设计</li>\n<li>概要设计</li>\n<li>详细设计</li>\n<li>开发</li>\n<li>验收</li>\n<li>维护</li>\n</ul>\n<h4><a href=\"#jie-kou-ce-shi\" class=\"header-anchor\"></a><span id=\"jie-kou-ce-shi\">接口测试</span></h4><ul>\n<li>后台和前台的数据</li>\n<li>后台和前台可以交互</li>\n</ul>\n<h3><a href=\"#wen-dang\" class=\"header-anchor\"></a><span id=\"wen-dang\">文档</span></h3><ul>\n<li>需求文档</li>\n<li>设计文档</li>\n<li>开发文档</li>\n<li>测试文档</li>\n<li>验收文档</li>\n<li>用户文档</li>\n</ul>\n<h3><a href=\"#ruan-jian-ce-shi\" class=\"header-anchor\"></a><span id=\"ruan-jian-ce-shi\">软件测试</span></h3><ul>\n<li>测试计划</li>\n<li>测试用例</li>\n<li>测试方案</li>\n<li>测试报告</li>\n<li>测试方案</li>\n<li>测试报告（总结）</li>\n</ul>\n<h3><a href=\"#ruan-jian-ce-shi-jiu-shi-bao-zheng\" class=\"header-anchor\"></a><span id=\"ruan-jian-ce-shi-jiu-shi-bao-zheng\">软件测试就是保证</span></h3><h3><a href=\"#ruan-jian-ce-shi-de-fen-lei\" class=\"header-anchor\"></a><span id=\"ruan-jian-ce-shi-de-fen-lei\">软件测试的分类</span></h3><ul>\n<li>通用软件产品</li>\n<li>电信行业</li>\n<li>金融证券行业</li>\n<li>游戏测试</li>\n<li>嵌入式软件测试</li>\n<li>电子商务软件测试</li>\n</ul>\n<h3><a href=\"#gang-wei-fen-lei\" class=\"header-anchor\"></a><span id=\"gang-wei-fen-lei\">岗位分类</span></h3><ul>\n<li>软件测试工程师</li>\n<li>硬件测试工程师</li>\n<li>自动化工程师</li>\n<li>性能测试工程师</li>\n<li>安全测试工程师</li>\n</ul>\n<h3><a href=\"#ruan-jian-ce-shi-ren-yuan-de-zhi-ze\" class=\"header-anchor\"></a><span id=\"ruan-jian-ce-shi-ren-yuan-de-zhi-ze\">软件测试人员的职责</span></h3><ul>\n<li>了解项目需求内容</li>\n<li>编写合理的测试计划</li>\n<li></li>\n</ul>\n<p>作业：</p>\n<ol>\n<li>你对目前软件测试行业现状怎么看？</li>\n<li>你觉得现在的测试人员能力水平如何？</li>\n<li>你觉得作为测试人员有哪些素质和能力要求，你为什么会选择这个行业？</li>\n</ol>\n<h3><a href=\"#ruan-jian-que-xian-guan-li\" class=\"header-anchor\"></a><span id=\"ruan-jian-que-xian-guan-li\">软件缺陷管理</span></h3><h4><a href=\"#ruan-jian-que-xian-de-ding-yi\" class=\"header-anchor\"></a><span id=\"ruan-jian-que-xian-de-ding-yi\">软件缺陷的定义</span></h4><ul>\n<li>IEEE 1983 of IEEE Standard 729中对软件缺陷作了一个标准的定义：<br>&amp;emsp;&amp;emsp; 从产品内部看，软件缺陷软件产品开发或维护过程中所存在的错误、毛病等各种总是从外部看，软件缺陷是系统所需要实现的某种功能的失效或违背。</li>\n<li>因此软件缺陷就是软件产品中所存在的问题，最终表现为用户需要的功能没有完全实现，没有满足用户的需求。</li>\n</ul>\n<h4><a href=\"#ruan-jian-que-xian-de-biao-xian\" class=\"header-anchor\"></a><span id=\"ruan-jian-que-xian-de-biao-xian\">软件缺陷的表现</span></h4><ul>\n<li>功能、我没有实现或部分实现。</li>\n<li>设计不合理，功能我和明确，逻辑不清楚或存在矛盾。</li>\n<li>产品实际结果和所期望的结果不一样。</li>\n<li>没有达到需求规格说明书所规定的性能指标等。</li>\n<li>运行出错，包括运行中断、系统崩溃、界面混乱等。</li>\n<li>数据不正确、精度不够、不完整或格式不统一。</li>\n<li>用户不能接受的其他问题，如存取时间过长、界面不美观。</li>\n<li>硬件或系统软件上存在的其他问题。</li>\n</ul>\n<h4><a href=\"#ruan-jian-que-xian-shi-li\" class=\"header-anchor\"></a><span id=\"ruan-jian-que-xian-shi-li\">软件缺陷示例</span></h4><ul>\n<li>计算器说明书一般声称该计算器将准确无误地进行加、减、乘、除运算。如果测试人员或用户选定了两个数值后，随意按下了“+”号键，结果没有任何反应。<br>&amp;emsp;&amp;emsp;软件未达到软件需求规格说明书表明的功能</li>\n<li>若在进行测试时，发现除了规定的加、减、乘、除功能之外，还能够进行求平方根的埃，而这一功能并没有在说明书的功能中规定。<br>&amp;emsp;&amp;emsp;软件的功能超出了软件需求规格说明书指明的范围</li>\n<li>若在测试过程中发现，因为电池没电而导致了计算不正确，但软件需求规格说明书未能指出在此情况下应如何进行处理。<br>&amp;emsp;&amp;emsp;软件未达到软件需求规格说明书未指明而应达到的目标</li>\n<li>假如计算器说明书指明计算kkdi付出现崩溃、死锁或者停止反应，而在用户随意按、敲击键盘后，计算器停止接受输入或没有反应。<br>&amp;emsp;&amp;emsp;软件出现了软件需求规格说明书指明不会出现的错误</li>\n<li>测试人员或最终用户发现计算器某些地方不好用，比如，按键太小、显示屏在亮光下无法看清等。<br>&amp;emsp;&amp;emsp;软件测试人员认为软件难以理解、不易使用、运行速度慢，或者最终用户认为不好</li>\n</ul>\n<h4><a href=\"#ruan-jian-que-xian-chan-sheng-de-yuan-yin\" class=\"header-anchor\"></a><span id=\"ruan-jian-que-xian-chan-sheng-de-yuan-yin\">软件缺陷产生的原因</span></h4><p>&amp;emsp;软件缺陷产生是不可避免的，造成软件缺陷产生的原因主要归纳如下：</p>\n<ul>\n<li>需求解释或者记录错误</li>\n<li>用户需求定义错误 </li>\n<li>设计说明存在错误 </li>\n<li>编码说明、程序代码有误</li>\n<li>硬件或者软件系统上存在错误</li>\n<li>其他，如文档错误、内容不正确</li>\n</ul>\n<h4><a href=\"#ruan-jian-que-xian-de-gen-yuan\" class=\"header-anchor\"></a><span id=\"ruan-jian-que-xian-de-gen-yuan\">软件缺陷的根源</span></h4><ul>\n<li>交流不充分<br>&amp;emsp;&amp;emsp;客户与开发人员、开发人员与测试人员等 等</li>\n<li>软件的复杂性<br>&amp;emsp;&amp;emsp;功能复杂、开发复杂、测试复杂</li>\n<li>开发人员的错误<br>&amp;emsp;&amp;emsp;对需求的理解、开发压力、功能与经验</li>\n<li>需求的变化<br>&amp;emsp;&amp;emsp;需求说明书、设计文档、程序的变更</li>\n<li>进度压力<br>&amp;emsp;&amp;emsp;项目周期比较紧</li>\n</ul>\n<h4><a href=\"#que-xian-fa-xian-de-shou-duan\" class=\"header-anchor\"></a><span id=\"que-xian-fa-xian-de-shou-duan\">缺陷发现的手段</span></h4><p>&amp;emsp;一提到缺陷发现的手段，大家首先且基本能想到的就是测试。测试是一项重要的缺陷发现手段，但不是唯一的缺陷发现手段。缺陷发现的手段有如下：</p>\n<ul>\n<li>评审</li>\n<li>QA</li>\n<li>客户</li>\n</ul>\n<h4><a href=\"#ruan-jian-que-xian-xiu-de-fei-yong\" class=\"header-anchor\"></a><span id=\"ruan-jian-que-xian-xiu-de-fei-yong\">软件缺陷修的费用</span></h4><p>需求规格说明书、设计、编码、测试、发布，费用越来越高</p>\n<h4><a href=\"#ruan-jian-que-xian-de-xin-xi\" class=\"header-anchor\"></a><span id=\"ruan-jian-que-xian-de-xin-xi\">软件缺陷的信息</span></h4><ul>\n<li>缺陷ID</li>\n<li>缺陷状态* ———— 缺陷状态指缺陷通过一个跟踪修复过程的进展情况</li>\n<li>缺陷标题*</li>\n<li>缺陷的严重程度* ———— 程度分为致命、较严重、严重、一般、低</li>\n<li>缺陷的优先级*</li>\n<li>缺陷所属模块*</li>\n<li>缺陷记录者</li>\n<li>缺陷提交时间</li>\n<li>缺陷处理人</li>\n<li>处理结果描述</li>\n<li>缺陷处理时间</li>\n<li>缺陷验证人</li>\n<li>缺陷结果描述</li>\n<li>缺陷详细描述*</li>\n<li>缺陷环境说明</li>\n<li>必要的附件</li>\n</ul>\n<p>作业：<br>1。<br>BUG标题： 一句话描述BUG<br>BUG的等级： 致命错误、严重错误、一般、较小、<br>测试建议<br>提交时间<br>软件版本<br>软件环境：win7&#x2F;Android7<br>产生概率： 100%<br>产生模块<br>处理人<br>产生步骤： 1。。。2。。。3。。。<br>期待结果</p>\n<h4><a href=\"#ruan-jian-que-xian-fen-lei-bug-lei-xing\" class=\"header-anchor\"></a><span id=\"ruan-jian-que-xian-fen-lei-bug-lei-xing\">软件缺陷分类————BUG类型</span></h4><ul>\n<li>系统缺陷<br>1.由于程序所引起的死机，异常退出<br>2.程序死循环<br>3.程序错误，不能执行正常工作或重要功能，使系统崩溃或资源不足</li>\n<li>数据缺陷<br>1.数据计算错误<br>2.数据约束错误<br>3.数据输入、输出错误</li>\n<li>数据库缺陷</li>\n</ul>\n<ol>\n<li>数据库发生死锁</li>\n<li>数据库的表、缺省值未加约束条件</li>\n<li>数据库连接错误</li>\n<li>数据库中的表有过多的空字段</li>\n</ol>\n<ul>\n<li>接口缺陷<br>1.数据通信错误<br>2.程序接口错误</li>\n<li>功能缺陷<br>1.功能无法实现<br>2.功能实现错误</li>\n<li>安全性缺陷<br>1.用户权限无法实现<br>2.超时限制错误<br>3.访问控制错误<br>4.加密错误</li>\n<li>兼容性缺陷<br>1.与需求文档配置兼容性不符合</li>\n<li>性能缺陷<br>1.未达到预期的性能目标<br>2.性能测试中出错，导致无法继续进行测试</li>\n<li>界面缺陷<br>1.操作界面错误<br>2.打印内容、格式错误<br>3.删除操作未给出提示<br>4.长时间操作未给出提示<br>5.界面不规范</li>\n<li>建议<br>1.功能建议<br>2.操作建议</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h3 id=\"行业内的主要知识点\"><a href=\"#行业内的主要知识点\" class=\"headerlink\" title=\"行业内的主要知识点\"></a>行业内的主要知识点</h3><h4 id=\"软件危机\"><a href=\"#软件危机\" class=\"headerlink\" title=\"软件危机\"></a>软件危机</h4><h4 id=\"软件测试的分类\"><a href=\"#软件测试的分类\" class=\"headerlink\" title=\"软件测试的分类\"></a>软件测试的分类</h4><ul>\n<li>按测试阶段划分</li>\n</ul>\n<p>软件测试 &#x3D; 程序 + 文档 + 数据<br>程序主流方向 B&#x2F;S架构和手机app</p>","more":"<h4 id=\"软件项目流程\"><a href=\"#软件项目流程\" class=\"headerlink\" title=\"软件项目流程\"></a>软件项目流程</h4><ul>\n<li>可行性分析</li>\n<li>立项</li>\n<li>需求</li>\n<li>原型设计</li>\n<li>概要设计</li>\n<li>详细设计</li>\n<li>开发</li>\n<li>验收</li>\n<li>维护</li>\n</ul>\n<h4 id=\"接口测试\"><a href=\"#接口测试\" class=\"headerlink\" title=\"接口测试\"></a>接口测试</h4><ul>\n<li>后台和前台的数据</li>\n<li>后台和前台可以交互</li>\n</ul>\n<h3 id=\"文档\"><a href=\"#文档\" class=\"headerlink\" title=\"文档\"></a>文档</h3><ul>\n<li>需求文档</li>\n<li>设计文档</li>\n<li>开发文档</li>\n<li>测试文档</li>\n<li>验收文档</li>\n<li>用户文档</li>\n</ul>\n<h3 id=\"软件测试\"><a href=\"#软件测试\" class=\"headerlink\" title=\"软件测试\"></a>软件测试</h3><ul>\n<li>测试计划</li>\n<li>测试用例</li>\n<li>测试方案</li>\n<li>测试报告</li>\n<li>测试方案</li>\n<li>测试报告（总结）</li>\n</ul>\n<h3 id=\"软件测试就是保证\"><a href=\"#软件测试就是保证\" class=\"headerlink\" title=\"软件测试就是保证\"></a>软件测试就是保证</h3><h3 id=\"软件测试的分类-1\"><a href=\"#软件测试的分类-1\" class=\"headerlink\" title=\"软件测试的分类\"></a>软件测试的分类</h3><ul>\n<li>通用软件产品</li>\n<li>电信行业</li>\n<li>金融证券行业</li>\n<li>游戏测试</li>\n<li>嵌入式软件测试</li>\n<li>电子商务软件测试</li>\n</ul>\n<h3 id=\"岗位分类\"><a href=\"#岗位分类\" class=\"headerlink\" title=\"岗位分类\"></a>岗位分类</h3><ul>\n<li>软件测试工程师</li>\n<li>硬件测试工程师</li>\n<li>自动化工程师</li>\n<li>性能测试工程师</li>\n<li>安全测试工程师</li>\n</ul>\n<h3 id=\"软件测试人员的职责\"><a href=\"#软件测试人员的职责\" class=\"headerlink\" title=\"软件测试人员的职责\"></a>软件测试人员的职责</h3><ul>\n<li>了解项目需求内容</li>\n<li>编写合理的测试计划</li>\n<li></li>\n</ul>\n<p>作业：</p>\n<ol>\n<li>你对目前软件测试行业现状怎么看？</li>\n<li>你觉得现在的测试人员能力水平如何？</li>\n<li>你觉得作为测试人员有哪些素质和能力要求，你为什么会选择这个行业？</li>\n</ol>\n<h3 id=\"软件缺陷管理\"><a href=\"#软件缺陷管理\" class=\"headerlink\" title=\"软件缺陷管理\"></a>软件缺陷管理</h3><h4 id=\"软件缺陷的定义\"><a href=\"#软件缺陷的定义\" class=\"headerlink\" title=\"软件缺陷的定义\"></a>软件缺陷的定义</h4><ul>\n<li>IEEE 1983 of IEEE Standard 729中对软件缺陷作了一个标准的定义：<br>&amp;emsp;&amp;emsp; 从产品内部看，软件缺陷软件产品开发或维护过程中所存在的错误、毛病等各种总是从外部看，软件缺陷是系统所需要实现的某种功能的失效或违背。</li>\n<li>因此软件缺陷就是软件产品中所存在的问题，最终表现为用户需要的功能没有完全实现，没有满足用户的需求。</li>\n</ul>\n<h4 id=\"软件缺陷的表现\"><a href=\"#软件缺陷的表现\" class=\"headerlink\" title=\"软件缺陷的表现\"></a>软件缺陷的表现</h4><ul>\n<li>功能、我没有实现或部分实现。</li>\n<li>设计不合理，功能我和明确，逻辑不清楚或存在矛盾。</li>\n<li>产品实际结果和所期望的结果不一样。</li>\n<li>没有达到需求规格说明书所规定的性能指标等。</li>\n<li>运行出错，包括运行中断、系统崩溃、界面混乱等。</li>\n<li>数据不正确、精度不够、不完整或格式不统一。</li>\n<li>用户不能接受的其他问题，如存取时间过长、界面不美观。</li>\n<li>硬件或系统软件上存在的其他问题。</li>\n</ul>\n<h4 id=\"软件缺陷示例\"><a href=\"#软件缺陷示例\" class=\"headerlink\" title=\"软件缺陷示例\"></a>软件缺陷示例</h4><ul>\n<li>计算器说明书一般声称该计算器将准确无误地进行加、减、乘、除运算。如果测试人员或用户选定了两个数值后，随意按下了“+”号键，结果没有任何反应。<br>&amp;emsp;&amp;emsp;软件未达到软件需求规格说明书表明的功能</li>\n<li>若在进行测试时，发现除了规定的加、减、乘、除功能之外，还能够进行求平方根的埃，而这一功能并没有在说明书的功能中规定。<br>&amp;emsp;&amp;emsp;软件的功能超出了软件需求规格说明书指明的范围</li>\n<li>若在测试过程中发现，因为电池没电而导致了计算不正确，但软件需求规格说明书未能指出在此情况下应如何进行处理。<br>&amp;emsp;&amp;emsp;软件未达到软件需求规格说明书未指明而应达到的目标</li>\n<li>假如计算器说明书指明计算kkdi付出现崩溃、死锁或者停止反应，而在用户随意按、敲击键盘后，计算器停止接受输入或没有反应。<br>&amp;emsp;&amp;emsp;软件出现了软件需求规格说明书指明不会出现的错误</li>\n<li>测试人员或最终用户发现计算器某些地方不好用，比如，按键太小、显示屏在亮光下无法看清等。<br>&amp;emsp;&amp;emsp;软件测试人员认为软件难以理解、不易使用、运行速度慢，或者最终用户认为不好</li>\n</ul>\n<h4 id=\"软件缺陷产生的原因\"><a href=\"#软件缺陷产生的原因\" class=\"headerlink\" title=\"软件缺陷产生的原因\"></a>软件缺陷产生的原因</h4><p>&amp;emsp;软件缺陷产生是不可避免的，造成软件缺陷产生的原因主要归纳如下：</p>\n<ul>\n<li>需求解释或者记录错误</li>\n<li>用户需求定义错误 </li>\n<li>设计说明存在错误 </li>\n<li>编码说明、程序代码有误</li>\n<li>硬件或者软件系统上存在错误</li>\n<li>其他，如文档错误、内容不正确</li>\n</ul>\n<h4 id=\"软件缺陷的根源\"><a href=\"#软件缺陷的根源\" class=\"headerlink\" title=\"软件缺陷的根源\"></a>软件缺陷的根源</h4><ul>\n<li>交流不充分<br>&amp;emsp;&amp;emsp;客户与开发人员、开发人员与测试人员等 等</li>\n<li>软件的复杂性<br>&amp;emsp;&amp;emsp;功能复杂、开发复杂、测试复杂</li>\n<li>开发人员的错误<br>&amp;emsp;&amp;emsp;对需求的理解、开发压力、功能与经验</li>\n<li>需求的变化<br>&amp;emsp;&amp;emsp;需求说明书、设计文档、程序的变更</li>\n<li>进度压力<br>&amp;emsp;&amp;emsp;项目周期比较紧</li>\n</ul>\n<h4 id=\"缺陷发现的手段\"><a href=\"#缺陷发现的手段\" class=\"headerlink\" title=\"缺陷发现的手段\"></a>缺陷发现的手段</h4><p>&amp;emsp;一提到缺陷发现的手段，大家首先且基本能想到的就是测试。测试是一项重要的缺陷发现手段，但不是唯一的缺陷发现手段。缺陷发现的手段有如下：</p>\n<ul>\n<li>评审</li>\n<li>QA</li>\n<li>客户</li>\n</ul>\n<h4 id=\"软件缺陷修的费用\"><a href=\"#软件缺陷修的费用\" class=\"headerlink\" title=\"软件缺陷修的费用\"></a>软件缺陷修的费用</h4><p>需求规格说明书、设计、编码、测试、发布，费用越来越高</p>\n<h4 id=\"软件缺陷的信息\"><a href=\"#软件缺陷的信息\" class=\"headerlink\" title=\"软件缺陷的信息\"></a>软件缺陷的信息</h4><ul>\n<li>缺陷ID</li>\n<li>缺陷状态* ———— 缺陷状态指缺陷通过一个跟踪修复过程的进展情况</li>\n<li>缺陷标题*</li>\n<li>缺陷的严重程度* ———— 程度分为致命、较严重、严重、一般、低</li>\n<li>缺陷的优先级*</li>\n<li>缺陷所属模块*</li>\n<li>缺陷记录者</li>\n<li>缺陷提交时间</li>\n<li>缺陷处理人</li>\n<li>处理结果描述</li>\n<li>缺陷处理时间</li>\n<li>缺陷验证人</li>\n<li>缺陷结果描述</li>\n<li>缺陷详细描述*</li>\n<li>缺陷环境说明</li>\n<li>必要的附件</li>\n</ul>\n<p>作业：<br>1。<br>BUG标题： 一句话描述BUG<br>BUG的等级： 致命错误、严重错误、一般、较小、<br>测试建议<br>提交时间<br>软件版本<br>软件环境：win7&#x2F;Android7<br>产生概率： 100%<br>产生模块<br>处理人<br>产生步骤： 1。。。2。。。3。。。<br>期待结果</p>\n<h4 id=\"软件缺陷分类————BUG类型\"><a href=\"#软件缺陷分类————BUG类型\" class=\"headerlink\" title=\"软件缺陷分类————BUG类型\"></a>软件缺陷分类————BUG类型</h4><ul>\n<li>系统缺陷<br>1.由于程序所引起的死机，异常退出<br>2.程序死循环<br>3.程序错误，不能执行正常工作或重要功能，使系统崩溃或资源不足</li>\n<li>数据缺陷<br>1.数据计算错误<br>2.数据约束错误<br>3.数据输入、输出错误</li>\n<li>数据库缺陷</li>\n</ul>\n<ol>\n<li>数据库发生死锁</li>\n<li>数据库的表、缺省值未加约束条件</li>\n<li>数据库连接错误</li>\n<li>数据库中的表有过多的空字段</li>\n</ol>\n<ul>\n<li>接口缺陷<br>1.数据通信错误<br>2.程序接口错误</li>\n<li>功能缺陷<br>1.功能无法实现<br>2.功能实现错误</li>\n<li>安全性缺陷<br>1.用户权限无法实现<br>2.超时限制错误<br>3.访问控制错误<br>4.加密错误</li>\n<li>兼容性缺陷<br>1.与需求文档配置兼容性不符合</li>\n<li>性能缺陷<br>1.未达到预期的性能目标<br>2.性能测试中出错，导致无法继续进行测试</li>\n<li>界面缺陷<br>1.操作界面错误<br>2.打印内容、格式错误<br>3.删除操作未给出提示<br>4.长时间操作未给出提示<br>5.界面不规范</li>\n<li>建议<br>1.功能建议<br>2.操作建议</li>\n</ul>"},{"title":"双栏布局（一）","date":"2017-04-26T16:07:00.000Z","_content":"今天写代码的时候遇到了一个需求，想想也是觉得这个需求挺常见的，所以就写下来记一下。\n\n### 需求说明：\n\n这个需求其实很简单，就是在页面中，希望左边的一个卡片固定宽度，右边卡片自适应地撑开。这个需求其实是非常常见的，网上一搜出来的结果也很多，而我更倾向于左边卡片用浮动，右边卡片用一个左边距来撑开这种方法；具体代码如下：\n\n<!-- more -->\n\n```HTML\n<!-- demo1 -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>insteresting CSS</title>\n</head>\n<style>\n    .contaner{\n        width: 600px;\n        height: 800px;\n    }\n    .left-panel{\n        width: 200px;\n        height: 100px;\n        float: left;\n        background: #d20e67;\n        text-align: center;\n        padding-top: 30px;\n    }\n    .right-panel{\n        height: 130px;\n        background-color: #19bd8e;\n        margin-left: 220px;\n    }\n    .box{\n        width: 50px;\n        height: 50px;\n        float: left;\n        background-color: red;\n        margin: 10px 10px 0 10px;\n    }\n</style>\n<body>\n    <div class=\"container\">\n        <div class=\"left-panel\">\n            <img src=\"logo.png\" alt=\"\">\n        </div>\n        <div class=\"right-panel\">\n            <div class=\"box\"></div>\n            <div class=\"box\"></div>\n            <div class=\"box\"></div>\n            <div class=\"box\"></div>\n            <div class=\"box\"></div>\n            <div class=\"box\"></div>\n            <div class=\"box\"></div>\n            <div class=\"box\"></div>\n            <div class=\"box\"></div>\n            <div class=\"box\"></div>\n            <div class=\"box\"></div>\n        </div>\n    </div>\n</body>\n</html>\n```\n\n然后做成的事例大概就是这个样子：\n\n![demo1](demo1.gif)\n\n上面的例子是利用了文档流默认是左对齐的原理，然后用flaot属性让左边的卡片脱离文档流，然后右卡片便会自适应地向左排过去，左卡片由于浮动会盖住右卡片的部分，所以右卡片用左margin来撑开使它完整地显示出来。\n\n**注意：左卡片要浮动，右卡片不要设置宽度！！**\n\n不过问题来了，如果是想要右边固定，左边自适应的话，那又应该怎么做了呢？\n\n粗略想了一下，同样地可以利用元素脱离文档流的方法来实现这个功能，如果继续使用float属性，那得改变Html的Dom顺序，代码如下：\n\n```html\n<!-- demo2.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>insteresting CSS</title>\n</head>\n<style>\n    .contaner{\n        width: 600px;\n        height: 800px;\n    }\n    .left-panel{\n        height: 100px;\n        background: #d20e67;\n        text-align: center;\n        padding-top: 30px;\n    }\n    .right-panel{\n        width: 200px;\n        float: right;\n        height: 130px;\n        background-color: #19bd8e;\n    }\n    .box{\n        width: 50px;\n        height: 50px;\n        float: left;\n        background-color: red;\n        margin: 10px 10px 0 10px;\n    }\n</style>\n<body>\n    <div class=\"container\">\n        <div class=\"right-panel\">\n            <img src=\"logo.png\" alt=\"\">\n        </div>\n        <div class=\"left-panel\">\n            <div class=\"box\"></div>\n            <div class=\"box\"></div>\n            <div class=\"box\"></div>\n            <div class=\"box\"></div>\n            <div class=\"box\"></div>\n            <div class=\"box\"></div>\n            <div class=\"box\"></div>\n            <div class=\"box\"></div>\n            <div class=\"box\"></div>\n            <div class=\"box\"></div>\n            <div class=\"box\"></div>\n        </div>\n    </div>\n</body>\n</html>\n```\n\n当然，作为一个有代码洁癖的前段切图仔，虽然没有什么伟大的理想，但是对是代码质量的追求还是有的。所以对于为了页面布局而改变html代码结构顺序这种事情是不能容忍的（起码不能给自己留Bug）。所以除了用float属性外，还可以用绝对定位来使元素脱离文档流。详细代码如下：\n\n```html\n<!-- demo3.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>insteresting CSS</title>\n</head>\n<style>\n    .container{\n        position: relative;\n    }\n    .left-panel{\n        height: 130px;\n        background: #d20e67;\n        margin-right: 200px;\n    }\n    .right-panel{\n        width: 200px;\n        height: 110px;\n        background-color: #19bd8e;\n        position: absolute;\n        right: 0;\n        top: 0;\n        padding-top: 20px;\n        text-align: center;\n    }\n    .box{\n        width: 50px;\n        height: 50px;\n        float: left;\n        background-color: red;\n        margin: 10px 10px 0 10px;\n    }\n</style>\n<body>\n    <div class=\"container\">\n        <div class=\"left-panel\">\n            <div class=\"box\"></div>\n            <div class=\"box\"></div>\n            <div class=\"box\"></div>\n            <div class=\"box\"></div>\n            <div class=\"box\"></div>\n            <div class=\"box\"></div>\n            <div class=\"box\"></div>\n            <div class=\"box\"></div>\n            <div class=\"box\"></div>\n            <div class=\"box\"></div>\n            <div class=\"box\"></div>\n        </div>\n        <div class=\"right-panel\">\n            <img src=\"logo.png\" alt=\"\">\n        </div>\n    </div>\n</body>\n</html>\n```\n\n效果如下图：\n\n![demo3](/images/demo3.gif)\n\n*[此案例在线demo地址：](http://lenkuntang.cn/blogDemo/interestingCSS/index.html)*","source":"_posts/interestingCSS.md","raw":"title: 双栏布局（一）\ntags:\n  - 每周一练\ncategories:\n  - Css-Less-Sass\n  - ''\ndate: 2017-04-27 00:07:00\n---\n今天写代码的时候遇到了一个需求，想想也是觉得这个需求挺常见的，所以就写下来记一下。\n\n### 需求说明：\n\n这个需求其实很简单，就是在页面中，希望左边的一个卡片固定宽度，右边卡片自适应地撑开。这个需求其实是非常常见的，网上一搜出来的结果也很多，而我更倾向于左边卡片用浮动，右边卡片用一个左边距来撑开这种方法；具体代码如下：\n\n<!-- more -->\n\n```HTML\n<!-- demo1 -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>insteresting CSS</title>\n</head>\n<style>\n    .contaner{\n        width: 600px;\n        height: 800px;\n    }\n    .left-panel{\n        width: 200px;\n        height: 100px;\n        float: left;\n        background: #d20e67;\n        text-align: center;\n        padding-top: 30px;\n    }\n    .right-panel{\n        height: 130px;\n        background-color: #19bd8e;\n        margin-left: 220px;\n    }\n    .box{\n        width: 50px;\n        height: 50px;\n        float: left;\n        background-color: red;\n        margin: 10px 10px 0 10px;\n    }\n</style>\n<body>\n    <div class=\"container\">\n        <div class=\"left-panel\">\n            <img src=\"logo.png\" alt=\"\">\n        </div>\n        <div class=\"right-panel\">\n            <div class=\"box\"></div>\n            <div class=\"box\"></div>\n            <div class=\"box\"></div>\n            <div class=\"box\"></div>\n            <div class=\"box\"></div>\n            <div class=\"box\"></div>\n            <div class=\"box\"></div>\n            <div class=\"box\"></div>\n            <div class=\"box\"></div>\n            <div class=\"box\"></div>\n            <div class=\"box\"></div>\n        </div>\n    </div>\n</body>\n</html>\n```\n\n然后做成的事例大概就是这个样子：\n\n![demo1](demo1.gif)\n\n上面的例子是利用了文档流默认是左对齐的原理，然后用flaot属性让左边的卡片脱离文档流，然后右卡片便会自适应地向左排过去，左卡片由于浮动会盖住右卡片的部分，所以右卡片用左margin来撑开使它完整地显示出来。\n\n**注意：左卡片要浮动，右卡片不要设置宽度！！**\n\n不过问题来了，如果是想要右边固定，左边自适应的话，那又应该怎么做了呢？\n\n粗略想了一下，同样地可以利用元素脱离文档流的方法来实现这个功能，如果继续使用float属性，那得改变Html的Dom顺序，代码如下：\n\n```html\n<!-- demo2.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>insteresting CSS</title>\n</head>\n<style>\n    .contaner{\n        width: 600px;\n        height: 800px;\n    }\n    .left-panel{\n        height: 100px;\n        background: #d20e67;\n        text-align: center;\n        padding-top: 30px;\n    }\n    .right-panel{\n        width: 200px;\n        float: right;\n        height: 130px;\n        background-color: #19bd8e;\n    }\n    .box{\n        width: 50px;\n        height: 50px;\n        float: left;\n        background-color: red;\n        margin: 10px 10px 0 10px;\n    }\n</style>\n<body>\n    <div class=\"container\">\n        <div class=\"right-panel\">\n            <img src=\"logo.png\" alt=\"\">\n        </div>\n        <div class=\"left-panel\">\n            <div class=\"box\"></div>\n            <div class=\"box\"></div>\n            <div class=\"box\"></div>\n            <div class=\"box\"></div>\n            <div class=\"box\"></div>\n            <div class=\"box\"></div>\n            <div class=\"box\"></div>\n            <div class=\"box\"></div>\n            <div class=\"box\"></div>\n            <div class=\"box\"></div>\n            <div class=\"box\"></div>\n        </div>\n    </div>\n</body>\n</html>\n```\n\n当然，作为一个有代码洁癖的前段切图仔，虽然没有什么伟大的理想，但是对是代码质量的追求还是有的。所以对于为了页面布局而改变html代码结构顺序这种事情是不能容忍的（起码不能给自己留Bug）。所以除了用float属性外，还可以用绝对定位来使元素脱离文档流。详细代码如下：\n\n```html\n<!-- demo3.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>insteresting CSS</title>\n</head>\n<style>\n    .container{\n        position: relative;\n    }\n    .left-panel{\n        height: 130px;\n        background: #d20e67;\n        margin-right: 200px;\n    }\n    .right-panel{\n        width: 200px;\n        height: 110px;\n        background-color: #19bd8e;\n        position: absolute;\n        right: 0;\n        top: 0;\n        padding-top: 20px;\n        text-align: center;\n    }\n    .box{\n        width: 50px;\n        height: 50px;\n        float: left;\n        background-color: red;\n        margin: 10px 10px 0 10px;\n    }\n</style>\n<body>\n    <div class=\"container\">\n        <div class=\"left-panel\">\n            <div class=\"box\"></div>\n            <div class=\"box\"></div>\n            <div class=\"box\"></div>\n            <div class=\"box\"></div>\n            <div class=\"box\"></div>\n            <div class=\"box\"></div>\n            <div class=\"box\"></div>\n            <div class=\"box\"></div>\n            <div class=\"box\"></div>\n            <div class=\"box\"></div>\n            <div class=\"box\"></div>\n        </div>\n        <div class=\"right-panel\">\n            <img src=\"logo.png\" alt=\"\">\n        </div>\n    </div>\n</body>\n</html>\n```\n\n效果如下图：\n\n![demo3](/images/demo3.gif)\n\n*[此案例在线demo地址：](http://lenkuntang.cn/blogDemo/interestingCSS/index.html)*","slug":"interestingCSS","published":1,"updated":"2023-04-11T03:30:27.115Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgbppebf001cbvchf47g7x0l","content":"<p>今天写代码的时候遇到了一个需求，想想也是觉得这个需求挺常见的，所以就写下来记一下。</p>\n<h3><a href=\"#xu-qiu-shuo-ming\" class=\"header-anchor\"></a><span id=\"xu-qiu-shuo-ming\">需求说明：</span></h3><p>这个需求其实很简单，就是在页面中，希望左边的一个卡片固定宽度，右边卡片自适应地撑开。这个需求其实是非常常见的，网上一搜出来的结果也很多，而我更倾向于左边卡片用浮动，右边卡片用一个左边距来撑开这种方法；具体代码如下：</p>\n<span id=\"more\"></span>\n\n<pre><code class=\"HTML\">&lt;!-- demo1 --&gt;\n&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;\n    &lt;title&gt;insteresting CSS&lt;/title&gt;\n&lt;/head&gt;\n&lt;style&gt;\n    .contaner&#123;\n        width: 600px;\n        height: 800px;\n    &#125;\n    .left-panel&#123;\n        width: 200px;\n        height: 100px;\n        float: left;\n        background: #d20e67;\n        text-align: center;\n        padding-top: 30px;\n    &#125;\n    .right-panel&#123;\n        height: 130px;\n        background-color: #19bd8e;\n        margin-left: 220px;\n    &#125;\n    .box&#123;\n        width: 50px;\n        height: 50px;\n        float: left;\n        background-color: red;\n        margin: 10px 10px 0 10px;\n    &#125;\n&lt;/style&gt;\n&lt;body&gt;\n    &lt;div class=&quot;container&quot;&gt;\n        &lt;div class=&quot;left-panel&quot;&gt;\n            &lt;img src=&quot;logo.png&quot; alt=&quot;&quot;&gt;\n        &lt;/div&gt;\n        &lt;div class=&quot;right-panel&quot;&gt;\n            &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n            &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n            &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n            &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n            &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n            &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n            &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n            &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n            &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n            &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n            &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p>然后做成的事例大概就是这个样子：</p>\n<p><img src=\"/demo1.gif\" alt=\"demo1\"></p>\n<p>上面的例子是利用了文档流默认是左对齐的原理，然后用flaot属性让左边的卡片脱离文档流，然后右卡片便会自适应地向左排过去，左卡片由于浮动会盖住右卡片的部分，所以右卡片用左margin来撑开使它完整地显示出来。</p>\n<p><strong>注意：左卡片要浮动，右卡片不要设置宽度！！</strong></p>\n<p>不过问题来了，如果是想要右边固定，左边自适应的话，那又应该怎么做了呢？</p>\n<p>粗略想了一下，同样地可以利用元素脱离文档流的方法来实现这个功能，如果继续使用float属性，那得改变Html的Dom顺序，代码如下：</p>\n<pre><code class=\"html\">&lt;!-- demo2.html --&gt;\n&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;\n    &lt;title&gt;insteresting CSS&lt;/title&gt;\n&lt;/head&gt;\n&lt;style&gt;\n    .contaner&#123;\n        width: 600px;\n        height: 800px;\n    &#125;\n    .left-panel&#123;\n        height: 100px;\n        background: #d20e67;\n        text-align: center;\n        padding-top: 30px;\n    &#125;\n    .right-panel&#123;\n        width: 200px;\n        float: right;\n        height: 130px;\n        background-color: #19bd8e;\n    &#125;\n    .box&#123;\n        width: 50px;\n        height: 50px;\n        float: left;\n        background-color: red;\n        margin: 10px 10px 0 10px;\n    &#125;\n&lt;/style&gt;\n&lt;body&gt;\n    &lt;div class=&quot;container&quot;&gt;\n        &lt;div class=&quot;right-panel&quot;&gt;\n            &lt;img src=&quot;logo.png&quot; alt=&quot;&quot;&gt;\n        &lt;/div&gt;\n        &lt;div class=&quot;left-panel&quot;&gt;\n            &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n            &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n            &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n            &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n            &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n            &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n            &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n            &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n            &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n            &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n            &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p>当然，作为一个有代码洁癖的前段切图仔，虽然没有什么伟大的理想，但是对是代码质量的追求还是有的。所以对于为了页面布局而改变html代码结构顺序这种事情是不能容忍的（起码不能给自己留Bug）。所以除了用float属性外，还可以用绝对定位来使元素脱离文档流。详细代码如下：</p>\n<pre><code class=\"html\">&lt;!-- demo3.html --&gt;\n&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;\n    &lt;title&gt;insteresting CSS&lt;/title&gt;\n&lt;/head&gt;\n&lt;style&gt;\n    .container&#123;\n        position: relative;\n    &#125;\n    .left-panel&#123;\n        height: 130px;\n        background: #d20e67;\n        margin-right: 200px;\n    &#125;\n    .right-panel&#123;\n        width: 200px;\n        height: 110px;\n        background-color: #19bd8e;\n        position: absolute;\n        right: 0;\n        top: 0;\n        padding-top: 20px;\n        text-align: center;\n    &#125;\n    .box&#123;\n        width: 50px;\n        height: 50px;\n        float: left;\n        background-color: red;\n        margin: 10px 10px 0 10px;\n    &#125;\n&lt;/style&gt;\n&lt;body&gt;\n    &lt;div class=&quot;container&quot;&gt;\n        &lt;div class=&quot;left-panel&quot;&gt;\n            &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n            &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n            &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n            &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n            &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n            &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n            &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n            &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n            &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n            &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n            &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n        &lt;/div&gt;\n        &lt;div class=&quot;right-panel&quot;&gt;\n            &lt;img src=&quot;logo.png&quot; alt=&quot;&quot;&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p>效果如下图：</p>\n<p><img src=\"/images/demo3.gif\" alt=\"demo3\"></p>\n<p><em><a href=\"http://lenkuntang.cn/blogDemo/interestingCSS/index.html\">此案例在线demo地址：</a></em></p>\n","site":{"data":{}},"excerpt":"<p>今天写代码的时候遇到了一个需求，想想也是觉得这个需求挺常见的，所以就写下来记一下。</p>\n<h3 id=\"需求说明：\"><a href=\"#需求说明：\" class=\"headerlink\" title=\"需求说明：\"></a>需求说明：</h3><p>这个需求其实很简单，就是在页面中，希望左边的一个卡片固定宽度，右边卡片自适应地撑开。这个需求其实是非常常见的，网上一搜出来的结果也很多，而我更倾向于左边卡片用浮动，右边卡片用一个左边距来撑开这种方法；具体代码如下：</p>","more":"<pre><code class=\"HTML\">&lt;!-- demo1 --&gt;\n&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;\n    &lt;title&gt;insteresting CSS&lt;/title&gt;\n&lt;/head&gt;\n&lt;style&gt;\n    .contaner&#123;\n        width: 600px;\n        height: 800px;\n    &#125;\n    .left-panel&#123;\n        width: 200px;\n        height: 100px;\n        float: left;\n        background: #d20e67;\n        text-align: center;\n        padding-top: 30px;\n    &#125;\n    .right-panel&#123;\n        height: 130px;\n        background-color: #19bd8e;\n        margin-left: 220px;\n    &#125;\n    .box&#123;\n        width: 50px;\n        height: 50px;\n        float: left;\n        background-color: red;\n        margin: 10px 10px 0 10px;\n    &#125;\n&lt;/style&gt;\n&lt;body&gt;\n    &lt;div class=&quot;container&quot;&gt;\n        &lt;div class=&quot;left-panel&quot;&gt;\n            &lt;img src=&quot;logo.png&quot; alt=&quot;&quot;&gt;\n        &lt;/div&gt;\n        &lt;div class=&quot;right-panel&quot;&gt;\n            &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n            &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n            &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n            &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n            &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n            &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n            &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n            &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n            &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n            &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n            &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p>然后做成的事例大概就是这个样子：</p>\n<p><img src=\"/demo1.gif\" alt=\"demo1\"></p>\n<p>上面的例子是利用了文档流默认是左对齐的原理，然后用flaot属性让左边的卡片脱离文档流，然后右卡片便会自适应地向左排过去，左卡片由于浮动会盖住右卡片的部分，所以右卡片用左margin来撑开使它完整地显示出来。</p>\n<p><strong>注意：左卡片要浮动，右卡片不要设置宽度！！</strong></p>\n<p>不过问题来了，如果是想要右边固定，左边自适应的话，那又应该怎么做了呢？</p>\n<p>粗略想了一下，同样地可以利用元素脱离文档流的方法来实现这个功能，如果继续使用float属性，那得改变Html的Dom顺序，代码如下：</p>\n<pre><code class=\"html\">&lt;!-- demo2.html --&gt;\n&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;\n    &lt;title&gt;insteresting CSS&lt;/title&gt;\n&lt;/head&gt;\n&lt;style&gt;\n    .contaner&#123;\n        width: 600px;\n        height: 800px;\n    &#125;\n    .left-panel&#123;\n        height: 100px;\n        background: #d20e67;\n        text-align: center;\n        padding-top: 30px;\n    &#125;\n    .right-panel&#123;\n        width: 200px;\n        float: right;\n        height: 130px;\n        background-color: #19bd8e;\n    &#125;\n    .box&#123;\n        width: 50px;\n        height: 50px;\n        float: left;\n        background-color: red;\n        margin: 10px 10px 0 10px;\n    &#125;\n&lt;/style&gt;\n&lt;body&gt;\n    &lt;div class=&quot;container&quot;&gt;\n        &lt;div class=&quot;right-panel&quot;&gt;\n            &lt;img src=&quot;logo.png&quot; alt=&quot;&quot;&gt;\n        &lt;/div&gt;\n        &lt;div class=&quot;left-panel&quot;&gt;\n            &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n            &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n            &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n            &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n            &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n            &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n            &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n            &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n            &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n            &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n            &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p>当然，作为一个有代码洁癖的前段切图仔，虽然没有什么伟大的理想，但是对是代码质量的追求还是有的。所以对于为了页面布局而改变html代码结构顺序这种事情是不能容忍的（起码不能给自己留Bug）。所以除了用float属性外，还可以用绝对定位来使元素脱离文档流。详细代码如下：</p>\n<pre><code class=\"html\">&lt;!-- demo3.html --&gt;\n&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;\n    &lt;title&gt;insteresting CSS&lt;/title&gt;\n&lt;/head&gt;\n&lt;style&gt;\n    .container&#123;\n        position: relative;\n    &#125;\n    .left-panel&#123;\n        height: 130px;\n        background: #d20e67;\n        margin-right: 200px;\n    &#125;\n    .right-panel&#123;\n        width: 200px;\n        height: 110px;\n        background-color: #19bd8e;\n        position: absolute;\n        right: 0;\n        top: 0;\n        padding-top: 20px;\n        text-align: center;\n    &#125;\n    .box&#123;\n        width: 50px;\n        height: 50px;\n        float: left;\n        background-color: red;\n        margin: 10px 10px 0 10px;\n    &#125;\n&lt;/style&gt;\n&lt;body&gt;\n    &lt;div class=&quot;container&quot;&gt;\n        &lt;div class=&quot;left-panel&quot;&gt;\n            &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n            &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n            &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n            &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n            &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n            &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n            &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n            &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n            &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n            &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n            &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n        &lt;/div&gt;\n        &lt;div class=&quot;right-panel&quot;&gt;\n            &lt;img src=&quot;logo.png&quot; alt=&quot;&quot;&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p>效果如下图：</p>\n<p><img src=\"/images/demo3.gif\" alt=\"demo3\"></p>\n<p><em><a href=\"http://lenkuntang.cn/blogDemo/interestingCSS/index.html\">此案例在线demo地址：</a></em></p>"},{"title":"关于移动端像素的显示问题","date":"2017-12-09T15:01:00.000Z","_content":"在移动端开发的过程中大家都会发现，移动端的显示一般与桌面端的不一样。比如在iphone6上显示一个1334x750像素大小块状元素，虽然在苹果官网上iphone6标称的屏幕像素密度是1334x750规格，但是我们却发现这个1334x750像素大小的块状元素却不能铺满整个屏幕。那到底是为什么呢？下面从几个方面来作探讨。\n\n### 像素密度（PPI）\n\n**PPI(Pixel Per Inch)，即表示每英寸有多少像素**，类似于人口密度和建筑密度，如下图举例了几种PPI的表示。\n\n![几种PPI表示](/images/pic1.png)\n\n以iphone6为例，一般像素密度的计算公式为： \n`Math.sqrt(1366*1366 + 640*640)`\n\n但是要计算这个PPI，那么我们先要知道设备的屏幕上到底有多少个像素，也就是Pixel Per Inch 中的第一个Pixel。\n\n### 设备像素（DP）&& 设备像素比（DPR）\n\n**设备像素（Device pixel），也称物理像素（Physical pixel）**，也就是本文一开始提到iphone6的屏幕规格。像素密度中所指的像素就是设备像素，对于一般的显示设备来说，一个像素对应着屏幕上的一个发光点，因此PPI也称为DPI（dots per inch），但是这仅在显示设备上才等价，比如在打印机上就不一样了。\n\n由于市面上每一台手机的屏幕规格不一样，有的是720P，有的是1080P，甚者是2K等等，这些设备的屏幕有些像素多，有些像素少，如果同样显示一个像素的话，则会出现像以下的情况：\n\n![一个像素在不同PPI屏幕上的显示](/images/pic2.png)\n\n越高PPI的屏幕，显示一个像素点的面积就越小，一张由4x4个像素点组成的图显示在PPI为64的屏幕上，那么换到256PPI的屏幕上显示则会缩小为原来大小的一半。\n\n反过来，如果要在PPI为256的屏幕上显示效果与PPI为64的屏幕一样，那么得要把图片放大2倍。\n\n因此配有高清屏幕的手机，厂商为了其设备的可用性，即图标和文字可以被正确识别和准确点击，就必须保证各类素材在其设备上的显示与标清设备一样，而这个解决方法就是把所有尺寸都放大若干倍。**这个放大比例就叫作设备像素比(Device Pixel Ratio, DPR)**，一般DPR对应着下面这个表：\n\n    | ldpi | mdpi | hdpi | xhdpi\n----|------|------|------|------\nppi | 120  | 160  | 240  | 320\ndpr | 0.75 | 1.0  | 1.5  | 2.0\n\n因此高清设备上应该配有高清图片显示，不然图片在高清设备上放大后没有足够的像素显示其细节，那么这张图片就会变得看起来很模糊。\n\n### CSS像素\n\n讲了这么多概念，仿佛还是没有很好地解释文章开头的问题。下面讨论完CSS像素后估计大家会有一个比较清晰的概念。\n\n我们通宵在写CSS的时候会用到像素单位px，但是这个像素单位并不一直是与设备像素一一对应，也就是说在CSS中1px（像素）不是对应着设备屏幕中的一个像素点。为了与设备像素区别，**CSS中所指的像素px我们一般称为CSS像素**。也就是说CSS像素是一个虚拟的、相对的单位。\n\n![不改变CSS使得元素在屏幕上更大地显示](/images/pic4.png)\n![不改变CSS使得元素在屏幕上更大地显示](/images/pic5.png)\n\n例如在页面上画一个300px宽的块元素，在一般的显示器下它只会占屏幕的一部分，但如果我们手动地去放大页面，很快这个块状元素也会充满整个页面。由此说明，一般情况下CSS像素与*系统分辨率*下的像素大小相等，**即在标清设备中，一个CSS像素应该是与一个设备像素大小相等的。但是是高清设备或者用户缩放的过程中，一个CSS像素也有可能等于多个设备像素。**\n\n![一个CSS像素在不同PPI屏幕上的显示](/images/pic3.png)\n\n举另外一个例子，在移动原生应用开发中，如果必须以一个设备像素为单位进行开发，那将会是一件非常痛苦的事，因为不是每一台移动设备的*系统分辨率*都是对应着一个设备像素，有的是1:2，有的是1:2.46，正是因为有这种差异，在安卓开发中会有例如dp,dt这种单位（在iOS中会有pt单位），当我们给一个元素定义大小时，只需要给定一个dp值，系统将会根据这个值再与**系统分辨率与设备像素的比值（即DPR）**进行换算，最终计算出显示在屏幕上的实际设备像素。\n\n上面所指出的dp这种抽象单位称为**设备无关像素（device independent pixel）**。当然CSS像素也属于设备无关像素，我们在写CSS像素的时候，不用关心一个CSS像素对应着多少个设备像素，系统会自动地根据DPR来帮我们换算好。我们要关心的只是如何保证网页元素因为系统换算而导致被放大的时候下，还能清晰地展示在设备上。\n\n### 视口（Viewport）\n\n正常来说，在移动端打开一个页面，如果浏览器先会以正常的比例来渲染页面，**然后再自动地设置一个比例来缩放页面**，目的是为了让内容更好地展示出来，即页面内容刚好铺满整个手机屏幕，当然如果页面没有禁止掉用户缩放的话，你也可以用两个手指把页面缩放回原始的比例。这整个过程就是通过视口（viewport）来实现的，原始页面渲染好后通过视口缩放使得与系统宽度一样，从而可以完整地展示页面。\n\n![viewport缩放](/images/pic6.jpg)\n\n我们可以通过在`content`中添加`inital-scale`属性来控制渲染时视窗的缩放比例，把它设置为1则无缩放。\n\n`<meta name=\"viewport\" content=\"initial-scale=1\">`\n\n我们也可以定义`device-width`属性来控制`viewport`的宽度\n\n`<meta name=\"viewport\" content=\"width=device-width\">`\n\n一般在移动开发中我们会设置不允许用户缩放，并把最大、最小缩放比设为1\n\n`<meta name=\"viewport\" content=\"width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no\">`\n\n### 总结（Summary）\n\n通过连续几天的翻阅资料与探索，终于完整地对移动开发最入门的地方有了准确的理解，之前也只是一直把`meta`里的代码直接复制过来用就是了，一直没去弄清楚，这次趁着有空并且手上刚好有相关的资料，一并整体地走一遍，最后记录成此文档，希望对日后甚至会对大家有帮助。\n\n> 参与资料：\n> \n> [1.深入了解viewport和px](http://tgideas.qq.com/webplat/info/news_version3/804/7104/7106/m5723/201509/376281.shtml)\n> \n> [2.高性能响应式Web开发实战](https://item.jd.com/11933227.html)","source":"_posts/The-problem-of-mobile-web-developing.md","raw":"title: 关于移动端像素的显示问题\ntags:\n  - 个人总结\ncategories:\n  - Css-Less-Sass\n  - ''\ndate: 2017-12-09 23:01:00\n---\n在移动端开发的过程中大家都会发现，移动端的显示一般与桌面端的不一样。比如在iphone6上显示一个1334x750像素大小块状元素，虽然在苹果官网上iphone6标称的屏幕像素密度是1334x750规格，但是我们却发现这个1334x750像素大小的块状元素却不能铺满整个屏幕。那到底是为什么呢？下面从几个方面来作探讨。\n\n### 像素密度（PPI）\n\n**PPI(Pixel Per Inch)，即表示每英寸有多少像素**，类似于人口密度和建筑密度，如下图举例了几种PPI的表示。\n\n![几种PPI表示](/images/pic1.png)\n\n以iphone6为例，一般像素密度的计算公式为： \n`Math.sqrt(1366*1366 + 640*640)`\n\n但是要计算这个PPI，那么我们先要知道设备的屏幕上到底有多少个像素，也就是Pixel Per Inch 中的第一个Pixel。\n\n### 设备像素（DP）&& 设备像素比（DPR）\n\n**设备像素（Device pixel），也称物理像素（Physical pixel）**，也就是本文一开始提到iphone6的屏幕规格。像素密度中所指的像素就是设备像素，对于一般的显示设备来说，一个像素对应着屏幕上的一个发光点，因此PPI也称为DPI（dots per inch），但是这仅在显示设备上才等价，比如在打印机上就不一样了。\n\n由于市面上每一台手机的屏幕规格不一样，有的是720P，有的是1080P，甚者是2K等等，这些设备的屏幕有些像素多，有些像素少，如果同样显示一个像素的话，则会出现像以下的情况：\n\n![一个像素在不同PPI屏幕上的显示](/images/pic2.png)\n\n越高PPI的屏幕，显示一个像素点的面积就越小，一张由4x4个像素点组成的图显示在PPI为64的屏幕上，那么换到256PPI的屏幕上显示则会缩小为原来大小的一半。\n\n反过来，如果要在PPI为256的屏幕上显示效果与PPI为64的屏幕一样，那么得要把图片放大2倍。\n\n因此配有高清屏幕的手机，厂商为了其设备的可用性，即图标和文字可以被正确识别和准确点击，就必须保证各类素材在其设备上的显示与标清设备一样，而这个解决方法就是把所有尺寸都放大若干倍。**这个放大比例就叫作设备像素比(Device Pixel Ratio, DPR)**，一般DPR对应着下面这个表：\n\n    | ldpi | mdpi | hdpi | xhdpi\n----|------|------|------|------\nppi | 120  | 160  | 240  | 320\ndpr | 0.75 | 1.0  | 1.5  | 2.0\n\n因此高清设备上应该配有高清图片显示，不然图片在高清设备上放大后没有足够的像素显示其细节，那么这张图片就会变得看起来很模糊。\n\n### CSS像素\n\n讲了这么多概念，仿佛还是没有很好地解释文章开头的问题。下面讨论完CSS像素后估计大家会有一个比较清晰的概念。\n\n我们通宵在写CSS的时候会用到像素单位px，但是这个像素单位并不一直是与设备像素一一对应，也就是说在CSS中1px（像素）不是对应着设备屏幕中的一个像素点。为了与设备像素区别，**CSS中所指的像素px我们一般称为CSS像素**。也就是说CSS像素是一个虚拟的、相对的单位。\n\n![不改变CSS使得元素在屏幕上更大地显示](/images/pic4.png)\n![不改变CSS使得元素在屏幕上更大地显示](/images/pic5.png)\n\n例如在页面上画一个300px宽的块元素，在一般的显示器下它只会占屏幕的一部分，但如果我们手动地去放大页面，很快这个块状元素也会充满整个页面。由此说明，一般情况下CSS像素与*系统分辨率*下的像素大小相等，**即在标清设备中，一个CSS像素应该是与一个设备像素大小相等的。但是是高清设备或者用户缩放的过程中，一个CSS像素也有可能等于多个设备像素。**\n\n![一个CSS像素在不同PPI屏幕上的显示](/images/pic3.png)\n\n举另外一个例子，在移动原生应用开发中，如果必须以一个设备像素为单位进行开发，那将会是一件非常痛苦的事，因为不是每一台移动设备的*系统分辨率*都是对应着一个设备像素，有的是1:2，有的是1:2.46，正是因为有这种差异，在安卓开发中会有例如dp,dt这种单位（在iOS中会有pt单位），当我们给一个元素定义大小时，只需要给定一个dp值，系统将会根据这个值再与**系统分辨率与设备像素的比值（即DPR）**进行换算，最终计算出显示在屏幕上的实际设备像素。\n\n上面所指出的dp这种抽象单位称为**设备无关像素（device independent pixel）**。当然CSS像素也属于设备无关像素，我们在写CSS像素的时候，不用关心一个CSS像素对应着多少个设备像素，系统会自动地根据DPR来帮我们换算好。我们要关心的只是如何保证网页元素因为系统换算而导致被放大的时候下，还能清晰地展示在设备上。\n\n### 视口（Viewport）\n\n正常来说，在移动端打开一个页面，如果浏览器先会以正常的比例来渲染页面，**然后再自动地设置一个比例来缩放页面**，目的是为了让内容更好地展示出来，即页面内容刚好铺满整个手机屏幕，当然如果页面没有禁止掉用户缩放的话，你也可以用两个手指把页面缩放回原始的比例。这整个过程就是通过视口（viewport）来实现的，原始页面渲染好后通过视口缩放使得与系统宽度一样，从而可以完整地展示页面。\n\n![viewport缩放](/images/pic6.jpg)\n\n我们可以通过在`content`中添加`inital-scale`属性来控制渲染时视窗的缩放比例，把它设置为1则无缩放。\n\n`<meta name=\"viewport\" content=\"initial-scale=1\">`\n\n我们也可以定义`device-width`属性来控制`viewport`的宽度\n\n`<meta name=\"viewport\" content=\"width=device-width\">`\n\n一般在移动开发中我们会设置不允许用户缩放，并把最大、最小缩放比设为1\n\n`<meta name=\"viewport\" content=\"width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no\">`\n\n### 总结（Summary）\n\n通过连续几天的翻阅资料与探索，终于完整地对移动开发最入门的地方有了准确的理解，之前也只是一直把`meta`里的代码直接复制过来用就是了，一直没去弄清楚，这次趁着有空并且手上刚好有相关的资料，一并整体地走一遍，最后记录成此文档，希望对日后甚至会对大家有帮助。\n\n> 参与资料：\n> \n> [1.深入了解viewport和px](http://tgideas.qq.com/webplat/info/news_version3/804/7104/7106/m5723/201509/376281.shtml)\n> \n> [2.高性能响应式Web开发实战](https://item.jd.com/11933227.html)","slug":"The-problem-of-mobile-web-developing","published":1,"updated":"2023-04-11T03:30:27.111Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgbppebf001ebvcheu7z45wh","content":"<p>在移动端开发的过程中大家都会发现，移动端的显示一般与桌面端的不一样。比如在iphone6上显示一个1334x750像素大小块状元素，虽然在苹果官网上iphone6标称的屏幕像素密度是1334x750规格，但是我们却发现这个1334x750像素大小的块状元素却不能铺满整个屏幕。那到底是为什么呢？下面从几个方面来作探讨。</p>\n<h3><a href=\"#xiang-su-mi-du-ppi\" class=\"header-anchor\"></a><span id=\"xiang-su-mi-du-ppi\">像素密度（PPI）</span></h3><p><strong>PPI(Pixel Per Inch)，即表示每英寸有多少像素</strong>，类似于人口密度和建筑密度，如下图举例了几种PPI的表示。</p>\n<p><img src=\"/images/pic1.png\" alt=\"几种PPI表示\"></p>\n<p>以iphone6为例，一般像素密度的计算公式为：<br><code>Math.sqrt(1366*1366 + 640*640)</code></p>\n<p>但是要计算这个PPI，那么我们先要知道设备的屏幕上到底有多少个像素，也就是Pixel Per Inch 中的第一个Pixel。</p>\n<h3><a href=\"#she-bei-xiang-su-dp-amp-amp-she-bei-xiang-su-bi-dpr\" class=\"header-anchor\"></a><span id=\"she-bei-xiang-su-dp-amp-amp-she-bei-xiang-su-bi-dpr\">设备像素（DP）&amp;&amp; 设备像素比（DPR）</span></h3><p><strong>设备像素（Device pixel），也称物理像素（Physical pixel）</strong>，也就是本文一开始提到iphone6的屏幕规格。像素密度中所指的像素就是设备像素，对于一般的显示设备来说，一个像素对应着屏幕上的一个发光点，因此PPI也称为DPI（dots per inch），但是这仅在显示设备上才等价，比如在打印机上就不一样了。</p>\n<p>由于市面上每一台手机的屏幕规格不一样，有的是720P，有的是1080P，甚者是2K等等，这些设备的屏幕有些像素多，有些像素少，如果同样显示一个像素的话，则会出现像以下的情况：</p>\n<p><img src=\"/images/pic2.png\" alt=\"一个像素在不同PPI屏幕上的显示\"></p>\n<p>越高PPI的屏幕，显示一个像素点的面积就越小，一张由4x4个像素点组成的图显示在PPI为64的屏幕上，那么换到256PPI的屏幕上显示则会缩小为原来大小的一半。</p>\n<p>反过来，如果要在PPI为256的屏幕上显示效果与PPI为64的屏幕一样，那么得要把图片放大2倍。</p>\n<p>因此配有高清屏幕的手机，厂商为了其设备的可用性，即图标和文字可以被正确识别和准确点击，就必须保证各类素材在其设备上的显示与标清设备一样，而这个解决方法就是把所有尺寸都放大若干倍。**这个放大比例就叫作设备像素比(Device Pixel Ratio, DPR)**，一般DPR对应着下面这个表：</p>\n<pre><code>| ldpi | mdpi | hdpi | xhdpi\n</code></pre>\n<p>—-|——|——|——|——<br>ppi | 120  | 160  | 240  | 320<br>dpr | 0.75 | 1.0  | 1.5  | 2.0</p>\n<p>因此高清设备上应该配有高清图片显示，不然图片在高清设备上放大后没有足够的像素显示其细节，那么这张图片就会变得看起来很模糊。</p>\n<h3><a href=\"#css-xiang-su\" class=\"header-anchor\"></a><span id=\"css-xiang-su\">CSS像素</span></h3><p>讲了这么多概念，仿佛还是没有很好地解释文章开头的问题。下面讨论完CSS像素后估计大家会有一个比较清晰的概念。</p>\n<p>我们通宵在写CSS的时候会用到像素单位px，但是这个像素单位并不一直是与设备像素一一对应，也就是说在CSS中1px（像素）不是对应着设备屏幕中的一个像素点。为了与设备像素区别，<strong>CSS中所指的像素px我们一般称为CSS像素</strong>。也就是说CSS像素是一个虚拟的、相对的单位。</p>\n<p><img src=\"/images/pic4.png\" alt=\"不改变CSS使得元素在屏幕上更大地显示\"><br><img src=\"/images/pic5.png\" alt=\"不改变CSS使得元素在屏幕上更大地显示\"></p>\n<p>例如在页面上画一个300px宽的块元素，在一般的显示器下它只会占屏幕的一部分，但如果我们手动地去放大页面，很快这个块状元素也会充满整个页面。由此说明，一般情况下CSS像素与<em>系统分辨率</em>下的像素大小相等，<strong>即在标清设备中，一个CSS像素应该是与一个设备像素大小相等的。但是是高清设备或者用户缩放的过程中，一个CSS像素也有可能等于多个设备像素。</strong></p>\n<p><img src=\"/images/pic3.png\" alt=\"一个CSS像素在不同PPI屏幕上的显示\"></p>\n<p>举另外一个例子，在移动原生应用开发中，如果必须以一个设备像素为单位进行开发，那将会是一件非常痛苦的事，因为不是每一台移动设备的<em>系统分辨率</em>都是对应着一个设备像素，有的是1:2，有的是1:2.46，正是因为有这种差异，在安卓开发中会有例如dp,dt这种单位（在iOS中会有pt单位），当我们给一个元素定义大小时，只需要给定一个dp值，系统将会根据这个值再与<strong>系统分辨率与设备像素的比值（即DPR）</strong>进行换算，最终计算出显示在屏幕上的实际设备像素。</p>\n<p>上面所指出的dp这种抽象单位称为<strong>设备无关像素（device independent pixel）</strong>。当然CSS像素也属于设备无关像素，我们在写CSS像素的时候，不用关心一个CSS像素对应着多少个设备像素，系统会自动地根据DPR来帮我们换算好。我们要关心的只是如何保证网页元素因为系统换算而导致被放大的时候下，还能清晰地展示在设备上。</p>\n<h3><a href=\"#shi-kou-viewport\" class=\"header-anchor\"></a><span id=\"shi-kou-viewport\">视口（Viewport）</span></h3><p>正常来说，在移动端打开一个页面，如果浏览器先会以正常的比例来渲染页面，<strong>然后再自动地设置一个比例来缩放页面</strong>，目的是为了让内容更好地展示出来，即页面内容刚好铺满整个手机屏幕，当然如果页面没有禁止掉用户缩放的话，你也可以用两个手指把页面缩放回原始的比例。这整个过程就是通过视口（viewport）来实现的，原始页面渲染好后通过视口缩放使得与系统宽度一样，从而可以完整地展示页面。</p>\n<p><img src=\"/images/pic6.jpg\" alt=\"viewport缩放\"></p>\n<p>我们可以通过在<code>content</code>中添加<code>inital-scale</code>属性来控制渲染时视窗的缩放比例，把它设置为1则无缩放。</p>\n<p><code>&lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1&quot;&gt;</code></p>\n<p>我们也可以定义<code>device-width</code>属性来控制<code>viewport</code>的宽度</p>\n<p><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt;</code></p>\n<p>一般在移动开发中我们会设置不允许用户缩放，并把最大、最小缩放比设为1</p>\n<p><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no&quot;&gt;</code></p>\n<h3><a href=\"#zong-jie-summary\" class=\"header-anchor\"></a><span id=\"zong-jie-summary\">总结（Summary）</span></h3><p>通过连续几天的翻阅资料与探索，终于完整地对移动开发最入门的地方有了准确的理解，之前也只是一直把<code>meta</code>里的代码直接复制过来用就是了，一直没去弄清楚，这次趁着有空并且手上刚好有相关的资料，一并整体地走一遍，最后记录成此文档，希望对日后甚至会对大家有帮助。</p>\n<blockquote>\n<p>参与资料：</p>\n<p><a href=\"http://tgideas.qq.com/webplat/info/news_version3/804/7104/7106/m5723/201509/376281.shtml\">1.深入了解viewport和px</a></p>\n<p><a href=\"https://item.jd.com/11933227.html\">2.高性能响应式Web开发实战</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p>在移动端开发的过程中大家都会发现，移动端的显示一般与桌面端的不一样。比如在iphone6上显示一个1334x750像素大小块状元素，虽然在苹果官网上iphone6标称的屏幕像素密度是1334x750规格，但是我们却发现这个1334x750像素大小的块状元素却不能铺满整个屏幕。那到底是为什么呢？下面从几个方面来作探讨。</p>\n<h3 id=\"像素密度（PPI）\"><a href=\"#像素密度（PPI）\" class=\"headerlink\" title=\"像素密度（PPI）\"></a>像素密度（PPI）</h3><p><strong>PPI(Pixel Per Inch)，即表示每英寸有多少像素</strong>，类似于人口密度和建筑密度，如下图举例了几种PPI的表示。</p>\n<p><img src=\"/images/pic1.png\" alt=\"几种PPI表示\"></p>\n<p>以iphone6为例，一般像素密度的计算公式为：<br><code>Math.sqrt(1366*1366 + 640*640)</code></p>\n<p>但是要计算这个PPI，那么我们先要知道设备的屏幕上到底有多少个像素，也就是Pixel Per Inch 中的第一个Pixel。</p>\n<h3 id=\"设备像素（DP）-amp-amp-设备像素比（DPR）\"><a href=\"#设备像素（DP）-amp-amp-设备像素比（DPR）\" class=\"headerlink\" title=\"设备像素（DP）&amp;&amp; 设备像素比（DPR）\"></a>设备像素（DP）&amp;&amp; 设备像素比（DPR）</h3><p><strong>设备像素（Device pixel），也称物理像素（Physical pixel）</strong>，也就是本文一开始提到iphone6的屏幕规格。像素密度中所指的像素就是设备像素，对于一般的显示设备来说，一个像素对应着屏幕上的一个发光点，因此PPI也称为DPI（dots per inch），但是这仅在显示设备上才等价，比如在打印机上就不一样了。</p>\n<p>由于市面上每一台手机的屏幕规格不一样，有的是720P，有的是1080P，甚者是2K等等，这些设备的屏幕有些像素多，有些像素少，如果同样显示一个像素的话，则会出现像以下的情况：</p>\n<p><img src=\"/images/pic2.png\" alt=\"一个像素在不同PPI屏幕上的显示\"></p>\n<p>越高PPI的屏幕，显示一个像素点的面积就越小，一张由4x4个像素点组成的图显示在PPI为64的屏幕上，那么换到256PPI的屏幕上显示则会缩小为原来大小的一半。</p>\n<p>反过来，如果要在PPI为256的屏幕上显示效果与PPI为64的屏幕一样，那么得要把图片放大2倍。</p>\n<p>因此配有高清屏幕的手机，厂商为了其设备的可用性，即图标和文字可以被正确识别和准确点击，就必须保证各类素材在其设备上的显示与标清设备一样，而这个解决方法就是把所有尺寸都放大若干倍。**这个放大比例就叫作设备像素比(Device Pixel Ratio, DPR)**，一般DPR对应着下面这个表：</p>\n<pre><code>| ldpi | mdpi | hdpi | xhdpi\n</code></pre>\n<p>—-|——|——|——|——<br>ppi | 120  | 160  | 240  | 320<br>dpr | 0.75 | 1.0  | 1.5  | 2.0</p>\n<p>因此高清设备上应该配有高清图片显示，不然图片在高清设备上放大后没有足够的像素显示其细节，那么这张图片就会变得看起来很模糊。</p>\n<h3 id=\"CSS像素\"><a href=\"#CSS像素\" class=\"headerlink\" title=\"CSS像素\"></a>CSS像素</h3><p>讲了这么多概念，仿佛还是没有很好地解释文章开头的问题。下面讨论完CSS像素后估计大家会有一个比较清晰的概念。</p>\n<p>我们通宵在写CSS的时候会用到像素单位px，但是这个像素单位并不一直是与设备像素一一对应，也就是说在CSS中1px（像素）不是对应着设备屏幕中的一个像素点。为了与设备像素区别，<strong>CSS中所指的像素px我们一般称为CSS像素</strong>。也就是说CSS像素是一个虚拟的、相对的单位。</p>\n<p><img src=\"/images/pic4.png\" alt=\"不改变CSS使得元素在屏幕上更大地显示\"><br><img src=\"/images/pic5.png\" alt=\"不改变CSS使得元素在屏幕上更大地显示\"></p>\n<p>例如在页面上画一个300px宽的块元素，在一般的显示器下它只会占屏幕的一部分，但如果我们手动地去放大页面，很快这个块状元素也会充满整个页面。由此说明，一般情况下CSS像素与<em>系统分辨率</em>下的像素大小相等，<strong>即在标清设备中，一个CSS像素应该是与一个设备像素大小相等的。但是是高清设备或者用户缩放的过程中，一个CSS像素也有可能等于多个设备像素。</strong></p>\n<p><img src=\"/images/pic3.png\" alt=\"一个CSS像素在不同PPI屏幕上的显示\"></p>\n<p>举另外一个例子，在移动原生应用开发中，如果必须以一个设备像素为单位进行开发，那将会是一件非常痛苦的事，因为不是每一台移动设备的<em>系统分辨率</em>都是对应着一个设备像素，有的是1:2，有的是1:2.46，正是因为有这种差异，在安卓开发中会有例如dp,dt这种单位（在iOS中会有pt单位），当我们给一个元素定义大小时，只需要给定一个dp值，系统将会根据这个值再与<strong>系统分辨率与设备像素的比值（即DPR）</strong>进行换算，最终计算出显示在屏幕上的实际设备像素。</p>\n<p>上面所指出的dp这种抽象单位称为<strong>设备无关像素（device independent pixel）</strong>。当然CSS像素也属于设备无关像素，我们在写CSS像素的时候，不用关心一个CSS像素对应着多少个设备像素，系统会自动地根据DPR来帮我们换算好。我们要关心的只是如何保证网页元素因为系统换算而导致被放大的时候下，还能清晰地展示在设备上。</p>\n<h3 id=\"视口（Viewport）\"><a href=\"#视口（Viewport）\" class=\"headerlink\" title=\"视口（Viewport）\"></a>视口（Viewport）</h3><p>正常来说，在移动端打开一个页面，如果浏览器先会以正常的比例来渲染页面，<strong>然后再自动地设置一个比例来缩放页面</strong>，目的是为了让内容更好地展示出来，即页面内容刚好铺满整个手机屏幕，当然如果页面没有禁止掉用户缩放的话，你也可以用两个手指把页面缩放回原始的比例。这整个过程就是通过视口（viewport）来实现的，原始页面渲染好后通过视口缩放使得与系统宽度一样，从而可以完整地展示页面。</p>\n<p><img src=\"/images/pic6.jpg\" alt=\"viewport缩放\"></p>\n<p>我们可以通过在<code>content</code>中添加<code>inital-scale</code>属性来控制渲染时视窗的缩放比例，把它设置为1则无缩放。</p>\n<p><code>&lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1&quot;&gt;</code></p>\n<p>我们也可以定义<code>device-width</code>属性来控制<code>viewport</code>的宽度</p>\n<p><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt;</code></p>\n<p>一般在移动开发中我们会设置不允许用户缩放，并把最大、最小缩放比设为1</p>\n<p><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no&quot;&gt;</code></p>\n<h3 id=\"总结（Summary）\"><a href=\"#总结（Summary）\" class=\"headerlink\" title=\"总结（Summary）\"></a>总结（Summary）</h3><p>通过连续几天的翻阅资料与探索，终于完整地对移动开发最入门的地方有了准确的理解，之前也只是一直把<code>meta</code>里的代码直接复制过来用就是了，一直没去弄清楚，这次趁着有空并且手上刚好有相关的资料，一并整体地走一遍，最后记录成此文档，希望对日后甚至会对大家有帮助。</p>\n<blockquote>\n<p>参与资料：</p>\n<p><a href=\"http://tgideas.qq.com/webplat/info/news_version3/804/7104/7106/m5723/201509/376281.shtml\">1.深入了解viewport和px</a></p>\n<p><a href=\"https://item.jd.com/11933227.html\">2.高性能响应式Web开发实战</a></p>\n</blockquote>\n"},{"layout":"[post]","title":"mac下卸载Node.js并使用nvm来管理Node版本","date":"2018-11-11T17:07:00.000Z","_content":"\n> 转载自：https://www.zhihu.com/question/27389115/answer/36434788\n> 转载自：https://blog.csdn.net/xieamy/article/details/70270039\n\n<!-- more -->\n\n### 前言\n\n因为不小心的缘故，把自己电脑上的node版本由LTS升到了Current，从而遇到了之前有一个基于vue-cli上搭建的项目跑不起来，在读取配置文件的时候直接报fs模块的错误，因此有了想卸载Node.js再从新安装的想法。\n\n### 当前环境\n\n当前的环境是 Mac os Sierra 10.12.6, 由于之前是通过直接在官网上下载安装包的方式来安装Node，并没有使用类似n或者nvm这类的Node版本管理工具，所以卸载的方法有点不一样。\n\n### 删除代码\n\n1. 删除/usr/local/lib中的所有node和node_modules\n2. 删除/usr/local/lib中的所有node和node_modules的文件夹\n3. 如果是从brew安装的, 运行brew uninstall node\n4. 检查~/中所有的local, lib或者include文件夹, 删除里面所有node和node_modules\n5. 在/usr/local/bin中, 删除所有node的可执行文件\n6. 最后运行以下代码:\n\n```\nsudo rm /usr/local/bin/npm\nsudo rm /usr/local/share/man/man1/node.1\nsudo rm /usr/local/lib/dtrace/node.d\nsudo rm -rf ~/.npm\nsudo rm -rf ~/.node-gyp\nsudo rm /opt/local/bin/node\nsudo rm /opt/local/include/node\nsudo rm -rf /opt/local/lib/node_modules\n\n```\n\n### 安装nvm\n \n打开nvm的github地址：[https://github.com/creationix/nvm](https://github.com/creationix/nvm)。在下面的简介中找到install，按照指示执行代码：\n\n`curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.1/install.sh | bash`\n\n当安装好之后会提示：\n\n```\n=> Appending nvm source string to /Users/kuntang/.bash_profile\n=> Appending bash_completion source string to /Users/kuntang/.bash_profile\n=> Close and reopen your terminal to start using nvm or run the following to use it now:\n\nexport NVM_DIR=\"$HOME/.nvm\"\n[ -s \"$NVM_DIR/nvm.sh\" ] && \\. \"$NVM_DIR/nvm.sh\"  # This loads nvm\n[ -s \"$NVM_DIR/bash_completion\" ] && \\. \"$NVM_DIR/bash_completion\"  # This loads nvm bash_completion\nTomzi-Maxs-MacBook-Pro:bin kuntang$ nvm\n-bash: nvm: command not found\n```\n\n这个时候直接敲 nvm还不能执行，需要执行一下它提示的代码：\n\n`export NVM_DIR=\"$HOME/.nvm\"\n[ -s \"$NVM_DIR/nvm.sh\" ] && \\. \"$NVM_DIR/nvm.sh\"  # This loads nvm`\n\n这样就可以使用nvm还管理node版本了。\n","source":"_posts/manage-Node-js-version-via-mvn.md","raw":"layout: '[post]'\ntitle: mac下卸载Node.js并使用nvm来管理Node版本\ntags:\n  - 转载\n  - 备忘翻阅\ncategories:\n  - ''\ndate: 2018-11-12 01:07:00\n---\n\n> 转载自：https://www.zhihu.com/question/27389115/answer/36434788\n> 转载自：https://blog.csdn.net/xieamy/article/details/70270039\n\n<!-- more -->\n\n### 前言\n\n因为不小心的缘故，把自己电脑上的node版本由LTS升到了Current，从而遇到了之前有一个基于vue-cli上搭建的项目跑不起来，在读取配置文件的时候直接报fs模块的错误，因此有了想卸载Node.js再从新安装的想法。\n\n### 当前环境\n\n当前的环境是 Mac os Sierra 10.12.6, 由于之前是通过直接在官网上下载安装包的方式来安装Node，并没有使用类似n或者nvm这类的Node版本管理工具，所以卸载的方法有点不一样。\n\n### 删除代码\n\n1. 删除/usr/local/lib中的所有node和node_modules\n2. 删除/usr/local/lib中的所有node和node_modules的文件夹\n3. 如果是从brew安装的, 运行brew uninstall node\n4. 检查~/中所有的local, lib或者include文件夹, 删除里面所有node和node_modules\n5. 在/usr/local/bin中, 删除所有node的可执行文件\n6. 最后运行以下代码:\n\n```\nsudo rm /usr/local/bin/npm\nsudo rm /usr/local/share/man/man1/node.1\nsudo rm /usr/local/lib/dtrace/node.d\nsudo rm -rf ~/.npm\nsudo rm -rf ~/.node-gyp\nsudo rm /opt/local/bin/node\nsudo rm /opt/local/include/node\nsudo rm -rf /opt/local/lib/node_modules\n\n```\n\n### 安装nvm\n \n打开nvm的github地址：[https://github.com/creationix/nvm](https://github.com/creationix/nvm)。在下面的简介中找到install，按照指示执行代码：\n\n`curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.1/install.sh | bash`\n\n当安装好之后会提示：\n\n```\n=> Appending nvm source string to /Users/kuntang/.bash_profile\n=> Appending bash_completion source string to /Users/kuntang/.bash_profile\n=> Close and reopen your terminal to start using nvm or run the following to use it now:\n\nexport NVM_DIR=\"$HOME/.nvm\"\n[ -s \"$NVM_DIR/nvm.sh\" ] && \\. \"$NVM_DIR/nvm.sh\"  # This loads nvm\n[ -s \"$NVM_DIR/bash_completion\" ] && \\. \"$NVM_DIR/bash_completion\"  # This loads nvm bash_completion\nTomzi-Maxs-MacBook-Pro:bin kuntang$ nvm\n-bash: nvm: command not found\n```\n\n这个时候直接敲 nvm还不能执行，需要执行一下它提示的代码：\n\n`export NVM_DIR=\"$HOME/.nvm\"\n[ -s \"$NVM_DIR/nvm.sh\" ] && \\. \"$NVM_DIR/nvm.sh\"  # This loads nvm`\n\n这样就可以使用nvm还管理node版本了。\n","slug":"manage-Node-js-version-via-mvn","published":1,"updated":"2023-04-11T03:30:27.124Z","comments":1,"photos":[],"link":"","_id":"clgbppebg001hbvch5qrx6rp1","content":"<blockquote>\n<p>转载自：<a href=\"https://www.zhihu.com/question/27389115/answer/36434788\">https://www.zhihu.com/question/27389115/answer/36434788</a><br>转载自：<a href=\"https://blog.csdn.net/xieamy/article/details/70270039\">https://blog.csdn.net/xieamy/article/details/70270039</a></p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h3><a href=\"#qian-yan\" class=\"header-anchor\"></a><span id=\"qian-yan\">前言</span></h3><p>因为不小心的缘故，把自己电脑上的node版本由LTS升到了Current，从而遇到了之前有一个基于vue-cli上搭建的项目跑不起来，在读取配置文件的时候直接报fs模块的错误，因此有了想卸载Node.js再从新安装的想法。</p>\n<h3><a href=\"#dang-qian-huan-jing\" class=\"header-anchor\"></a><span id=\"dang-qian-huan-jing\">当前环境</span></h3><p>当前的环境是 Mac os Sierra 10.12.6, 由于之前是通过直接在官网上下载安装包的方式来安装Node，并没有使用类似n或者nvm这类的Node版本管理工具，所以卸载的方法有点不一样。</p>\n<h3><a href=\"#shan-chu-dai-ma\" class=\"header-anchor\"></a><span id=\"shan-chu-dai-ma\">删除代码</span></h3><ol>\n<li>删除&#x2F;usr&#x2F;local&#x2F;lib中的所有node和node_modules</li>\n<li>删除&#x2F;usr&#x2F;local&#x2F;lib中的所有node和node_modules的文件夹</li>\n<li>如果是从brew安装的, 运行brew uninstall node</li>\n<li>检查~&#x2F;中所有的local, lib或者include文件夹, 删除里面所有node和node_modules</li>\n<li>在&#x2F;usr&#x2F;local&#x2F;bin中, 删除所有node的可执行文件</li>\n<li>最后运行以下代码:</li>\n</ol>\n<pre><code>sudo rm /usr/local/bin/npm\nsudo rm /usr/local/share/man/man1/node.1\nsudo rm /usr/local/lib/dtrace/node.d\nsudo rm -rf ~/.npm\nsudo rm -rf ~/.node-gyp\nsudo rm /opt/local/bin/node\nsudo rm /opt/local/include/node\nsudo rm -rf /opt/local/lib/node_modules\n</code></pre>\n<h3><a href=\"#an-zhuang-nvm\" class=\"header-anchor\"></a><span id=\"an-zhuang-nvm\">安装nvm</span></h3><p>打开nvm的github地址：<a href=\"https://github.com/creationix/nvm\">https://github.com/creationix/nvm</a>。在下面的简介中找到install，按照指示执行代码：</p>\n<p><code>curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.1/install.sh | bash</code></p>\n<p>当安装好之后会提示：</p>\n<pre><code>=&gt; Appending nvm source string to /Users/kuntang/.bash_profile\n=&gt; Appending bash_completion source string to /Users/kuntang/.bash_profile\n=&gt; Close and reopen your terminal to start using nvm or run the following to use it now:\n\nexport NVM_DIR=&quot;$HOME/.nvm&quot;\n[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \\. &quot;$NVM_DIR/nvm.sh&quot;  # This loads nvm\n[ -s &quot;$NVM_DIR/bash_completion&quot; ] &amp;&amp; \\. &quot;$NVM_DIR/bash_completion&quot;  # This loads nvm bash_completion\nTomzi-Maxs-MacBook-Pro:bin kuntang$ nvm\n-bash: nvm: command not found\n</code></pre>\n<p>这个时候直接敲 nvm还不能执行，需要执行一下它提示的代码：</p>\n<p><code>export NVM_DIR=&quot;$HOME/.nvm&quot; [ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \\. &quot;$NVM_DIR/nvm.sh&quot;  # This loads nvm</code></p>\n<p>这样就可以使用nvm还管理node版本了。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>转载自：<a href=\"https://www.zhihu.com/question/27389115/answer/36434788\">https://www.zhihu.com/question/27389115/answer/36434788</a><br>转载自：<a href=\"https://blog.csdn.net/xieamy/article/details/70270039\">https://blog.csdn.net/xieamy/article/details/70270039</a></p>\n</blockquote>","more":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>因为不小心的缘故，把自己电脑上的node版本由LTS升到了Current，从而遇到了之前有一个基于vue-cli上搭建的项目跑不起来，在读取配置文件的时候直接报fs模块的错误，因此有了想卸载Node.js再从新安装的想法。</p>\n<h3 id=\"当前环境\"><a href=\"#当前环境\" class=\"headerlink\" title=\"当前环境\"></a>当前环境</h3><p>当前的环境是 Mac os Sierra 10.12.6, 由于之前是通过直接在官网上下载安装包的方式来安装Node，并没有使用类似n或者nvm这类的Node版本管理工具，所以卸载的方法有点不一样。</p>\n<h3 id=\"删除代码\"><a href=\"#删除代码\" class=\"headerlink\" title=\"删除代码\"></a>删除代码</h3><ol>\n<li>删除&#x2F;usr&#x2F;local&#x2F;lib中的所有node和node_modules</li>\n<li>删除&#x2F;usr&#x2F;local&#x2F;lib中的所有node和node_modules的文件夹</li>\n<li>如果是从brew安装的, 运行brew uninstall node</li>\n<li>检查~&#x2F;中所有的local, lib或者include文件夹, 删除里面所有node和node_modules</li>\n<li>在&#x2F;usr&#x2F;local&#x2F;bin中, 删除所有node的可执行文件</li>\n<li>最后运行以下代码:</li>\n</ol>\n<pre><code>sudo rm /usr/local/bin/npm\nsudo rm /usr/local/share/man/man1/node.1\nsudo rm /usr/local/lib/dtrace/node.d\nsudo rm -rf ~/.npm\nsudo rm -rf ~/.node-gyp\nsudo rm /opt/local/bin/node\nsudo rm /opt/local/include/node\nsudo rm -rf /opt/local/lib/node_modules\n</code></pre>\n<h3 id=\"安装nvm\"><a href=\"#安装nvm\" class=\"headerlink\" title=\"安装nvm\"></a>安装nvm</h3><p>打开nvm的github地址：<a href=\"https://github.com/creationix/nvm\">https://github.com/creationix/nvm</a>。在下面的简介中找到install，按照指示执行代码：</p>\n<p><code>curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.1/install.sh | bash</code></p>\n<p>当安装好之后会提示：</p>\n<pre><code>=&gt; Appending nvm source string to /Users/kuntang/.bash_profile\n=&gt; Appending bash_completion source string to /Users/kuntang/.bash_profile\n=&gt; Close and reopen your terminal to start using nvm or run the following to use it now:\n\nexport NVM_DIR=&quot;$HOME/.nvm&quot;\n[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \\. &quot;$NVM_DIR/nvm.sh&quot;  # This loads nvm\n[ -s &quot;$NVM_DIR/bash_completion&quot; ] &amp;&amp; \\. &quot;$NVM_DIR/bash_completion&quot;  # This loads nvm bash_completion\nTomzi-Maxs-MacBook-Pro:bin kuntang$ nvm\n-bash: nvm: command not found\n</code></pre>\n<p>这个时候直接敲 nvm还不能执行，需要执行一下它提示的代码：</p>\n<p><code>export NVM_DIR=&quot;$HOME/.nvm&quot; [ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \\. &quot;$NVM_DIR/nvm.sh&quot;  # This loads nvm</code></p>\n<p>这样就可以使用nvm还管理node版本了。</p>"},{"layout":"[post]","title":"MongoDB Shell命令","date":"2017-11-30T08:39:00.000Z","_content":"#### 开启MongoDB数据库服务\n\n&emsp;&emsp;mongo根目录`/bin/mongod -f` 配置文件目录/配置文件名\n例：`./bin/mongod -f conf/mongod.conf`\n\nMongod.conf文件内容参考如下：\n\n```\ndbpath = /data/mongodb\nlogpath = /data/mongodb/mongodb.log\nlogappend = true\nport = 27017\nfork = true\nauth = true\n```\n\nMongod命令各常用参数说明：\n\n| 参数                 | 说明                                                         |\n| -------------------- | ------------------------------------------------------------ |\n| --quiet              | 安静输出                                                     |\n| --port arg           | 指定服务端口号，默认端口27017                                |\n| --bind_ip arg        | 绑定服务IP，若绑定127.0.0.1，则只能本机访问，不指定默认本地所有IP |\n| --logpath arg        | 指定MongoDB日志文件，注意是指定文件不是目录                  |\n| --logappend          | 使用追加的方式写日志                                         |\n| --journal            | 启用日志选项，MongoDB的数据操作将会写入到journal文件夹的文件里 |\n| --journalOptions arg | 启用日志诊断选项                                             |\n| --fork               | 以守护进程的方式运行MongoDB，创建服务器进程                  |\n| --maxConns arg       | 最大同时连接数 默认2000                                      |\n| --auth               | 启用验证                                                     |\n| --noauth             | 不启用验证                                                   |\n| --dbpath arg         | 指定数据库路径                                               |\n| --ipv6               | 启用IPv6选项                                                 |\n| --pidfilepath arg    | PID File 的完整路径，如果没有设置，则没有PID文件             |\n\n<!-- more -->\n\n#### 强行关闭MongoDB\n\n&emsp;&emsp;先用命令 `ps -ef | grep mongod `查出mongod 的进程pid\n然后`kill pid `即可\n\n#### 数据库\n\n##### 连接MongoDB数据库\n\n&emsp;&emsp;mongo根目录`/bin/mongo` 数据库地址:端口号/库名称\n例： `./bin/mongo 127.0.0.1:12345/test`\n\n##### 关闭MongoDB数据库\n\n&emsp;&emsp;`db.shutdownServer()`\n\n##### 新建和切换数据库\n\n&emsp;&emsp;MongoDB不用特别地去声明新建一个数据库，直接用`use 数据库名` 就可以了。\n\n##### 删除数据库\n\n&emsp;&emsp;先用`db.use`切换到要删除的数据库，然后使用`db.dropDatabase()`来删除数据库\n\n#### 数据操作\n\n##### 插入一条数据\n\n`db.collection.insert({key: value})`\n\n其中集名称可以自己起\n\n##### 插入多条数据\n\n&emsp;&emsp;可以使用for循环插入： `for(i＝3;i<100;i++)db.collection.insert({key: value})`\n\n##### 查询所有数据\n\n`db.collection.find()`\n\n##### 查询单条数据\n\n`db.collection.find({key: value})`\n\n##### 查询后有条件地进行处理\n\n`db.collection.find({key: value}).skip(3).limit(5).sort({key: value})`\n\n上面查询语句后的限制分别是skip（跳过多少条数据）、limit（限制查多少条数据）、sort(将查询出来的结果集排序)\n\n##### 显示库中的所有集名称\n\n`show collections`\n\n##### 删除数据库中的集合\n\n`db.collection.drop()`\n\n#### 索引\n\n##### 查看索引\n\n`db.imooc_2.getIndexes()`\n\n##### _id索引\n\n- _id索引是绝大多数集合默认建立的索引。\n- 对于每个插入的数据，MongoDB都会自动生成一条唯一的_id字段。\n\n##### 创建一个单键索引\n\n- 单键索引是最普通的索引\n- 单键索引不会自动创建\n\n&emsp;&emsp;例如： 一条记录为`{x: 1, y: 2, z: 3}`，如果我们在x上建立了索引，就可以使用x为条件进行查寻。\n\n`db.collection.ensureIndex({index: order})`\n\n- index: 索引\n- order: 1表示升序， -1表示降序\n\n##### 创建一个多键索引\n\n多键索引与单键索引创建形式相同，区别在于字段的值。 \n\n- 单键索引：值为一个单一的值，如字符串，数字或日期。 \n- 多键索引：值具有多个记录，如数组。\n\n`db.collection.insert({x:[1,2,3,4,5]}) //插入一条数组数据`\n\n`db.collection.insert({x:new Date()}) //插入一条数组数据`\n\n##### 创建一个复合索引\n\n&emsp;&emsp;当我们的查询条件不止一个的时候，就需要建立复合索引\n\n&emsp;&emsp;例如{x:1,y:2,z:3}这样一条数据，要按照x与y的值进行查询，就需要创建复合索引`db.collection.ensureIndex({x:1, y:1})`，然后就可以使用`{x: 1, y:1}`作为条件进行查询\n\n`db.collection.ensureIndex({x:1, y:1})`\n\n##### 创建一个过期索引\n\n- 在一段时间后会过期的索引 \n- 在索引过期后，相应的数据会被删除 \n- 适合存储在一段时间之后会失效的数据，比如用户的登录信息、存储的日志等。\n\n`db.imooc_2.ensureIndex({time:1},{expireAfterSeconds: seconds})` 创建过期索引，time-字段，expireAfterSeconds在多少秒后过期，单位：秒\n\n&emsp;&emsp;过30秒后再find，刚才的数据就已经不存在了。\n\n&emsp;&emsp;过期索引的限制： \n\n1. 存储在过期索引字段的值必须是指定的时间类型，必须是ISODate或者ISODate数组，不能使用时间戳，否则不能自动删除。 \n   例如 >db.imooc_2.insert({time:1})，这种是不能被自动删除的 \n2. 如果指定了ISODate数组，则按照最小的时间进行删除。 \n3. 过期索引不能是复合索引。因为不能指定两个过期时间。 \n4. 删除时间是不精确的。删除过程是由MongoDB的后台进程每60s跑一次的，而且删除也需要一定时间，所以存在误差","source":"_posts/mongodb-command.md","raw":"layout: '[post]'\ntitle: MongoDB Shell命令\ntags:\n  - 备忘翻阅\ncategories:\n  - Mongodb\n  - ''\ndate: 2017-11-30 16:39:00\n---\n#### 开启MongoDB数据库服务\n\n&emsp;&emsp;mongo根目录`/bin/mongod -f` 配置文件目录/配置文件名\n例：`./bin/mongod -f conf/mongod.conf`\n\nMongod.conf文件内容参考如下：\n\n```\ndbpath = /data/mongodb\nlogpath = /data/mongodb/mongodb.log\nlogappend = true\nport = 27017\nfork = true\nauth = true\n```\n\nMongod命令各常用参数说明：\n\n| 参数                 | 说明                                                         |\n| -------------------- | ------------------------------------------------------------ |\n| --quiet              | 安静输出                                                     |\n| --port arg           | 指定服务端口号，默认端口27017                                |\n| --bind_ip arg        | 绑定服务IP，若绑定127.0.0.1，则只能本机访问，不指定默认本地所有IP |\n| --logpath arg        | 指定MongoDB日志文件，注意是指定文件不是目录                  |\n| --logappend          | 使用追加的方式写日志                                         |\n| --journal            | 启用日志选项，MongoDB的数据操作将会写入到journal文件夹的文件里 |\n| --journalOptions arg | 启用日志诊断选项                                             |\n| --fork               | 以守护进程的方式运行MongoDB，创建服务器进程                  |\n| --maxConns arg       | 最大同时连接数 默认2000                                      |\n| --auth               | 启用验证                                                     |\n| --noauth             | 不启用验证                                                   |\n| --dbpath arg         | 指定数据库路径                                               |\n| --ipv6               | 启用IPv6选项                                                 |\n| --pidfilepath arg    | PID File 的完整路径，如果没有设置，则没有PID文件             |\n\n<!-- more -->\n\n#### 强行关闭MongoDB\n\n&emsp;&emsp;先用命令 `ps -ef | grep mongod `查出mongod 的进程pid\n然后`kill pid `即可\n\n#### 数据库\n\n##### 连接MongoDB数据库\n\n&emsp;&emsp;mongo根目录`/bin/mongo` 数据库地址:端口号/库名称\n例： `./bin/mongo 127.0.0.1:12345/test`\n\n##### 关闭MongoDB数据库\n\n&emsp;&emsp;`db.shutdownServer()`\n\n##### 新建和切换数据库\n\n&emsp;&emsp;MongoDB不用特别地去声明新建一个数据库，直接用`use 数据库名` 就可以了。\n\n##### 删除数据库\n\n&emsp;&emsp;先用`db.use`切换到要删除的数据库，然后使用`db.dropDatabase()`来删除数据库\n\n#### 数据操作\n\n##### 插入一条数据\n\n`db.collection.insert({key: value})`\n\n其中集名称可以自己起\n\n##### 插入多条数据\n\n&emsp;&emsp;可以使用for循环插入： `for(i＝3;i<100;i++)db.collection.insert({key: value})`\n\n##### 查询所有数据\n\n`db.collection.find()`\n\n##### 查询单条数据\n\n`db.collection.find({key: value})`\n\n##### 查询后有条件地进行处理\n\n`db.collection.find({key: value}).skip(3).limit(5).sort({key: value})`\n\n上面查询语句后的限制分别是skip（跳过多少条数据）、limit（限制查多少条数据）、sort(将查询出来的结果集排序)\n\n##### 显示库中的所有集名称\n\n`show collections`\n\n##### 删除数据库中的集合\n\n`db.collection.drop()`\n\n#### 索引\n\n##### 查看索引\n\n`db.imooc_2.getIndexes()`\n\n##### _id索引\n\n- _id索引是绝大多数集合默认建立的索引。\n- 对于每个插入的数据，MongoDB都会自动生成一条唯一的_id字段。\n\n##### 创建一个单键索引\n\n- 单键索引是最普通的索引\n- 单键索引不会自动创建\n\n&emsp;&emsp;例如： 一条记录为`{x: 1, y: 2, z: 3}`，如果我们在x上建立了索引，就可以使用x为条件进行查寻。\n\n`db.collection.ensureIndex({index: order})`\n\n- index: 索引\n- order: 1表示升序， -1表示降序\n\n##### 创建一个多键索引\n\n多键索引与单键索引创建形式相同，区别在于字段的值。 \n\n- 单键索引：值为一个单一的值，如字符串，数字或日期。 \n- 多键索引：值具有多个记录，如数组。\n\n`db.collection.insert({x:[1,2,3,4,5]}) //插入一条数组数据`\n\n`db.collection.insert({x:new Date()}) //插入一条数组数据`\n\n##### 创建一个复合索引\n\n&emsp;&emsp;当我们的查询条件不止一个的时候，就需要建立复合索引\n\n&emsp;&emsp;例如{x:1,y:2,z:3}这样一条数据，要按照x与y的值进行查询，就需要创建复合索引`db.collection.ensureIndex({x:1, y:1})`，然后就可以使用`{x: 1, y:1}`作为条件进行查询\n\n`db.collection.ensureIndex({x:1, y:1})`\n\n##### 创建一个过期索引\n\n- 在一段时间后会过期的索引 \n- 在索引过期后，相应的数据会被删除 \n- 适合存储在一段时间之后会失效的数据，比如用户的登录信息、存储的日志等。\n\n`db.imooc_2.ensureIndex({time:1},{expireAfterSeconds: seconds})` 创建过期索引，time-字段，expireAfterSeconds在多少秒后过期，单位：秒\n\n&emsp;&emsp;过30秒后再find，刚才的数据就已经不存在了。\n\n&emsp;&emsp;过期索引的限制： \n\n1. 存储在过期索引字段的值必须是指定的时间类型，必须是ISODate或者ISODate数组，不能使用时间戳，否则不能自动删除。 \n   例如 >db.imooc_2.insert({time:1})，这种是不能被自动删除的 \n2. 如果指定了ISODate数组，则按照最小的时间进行删除。 \n3. 过期索引不能是复合索引。因为不能指定两个过期时间。 \n4. 删除时间是不精确的。删除过程是由MongoDB的后台进程每60s跑一次的，而且删除也需要一定时间，所以存在误差","slug":"mongodb-command","published":1,"updated":"2023-04-11T03:30:27.124Z","comments":1,"photos":[],"link":"","_id":"clgbppebg001kbvch4z6b7q2k","content":"<h4><a href=\"#kai-qi-mongodb-shu-ju-ku-fu-wu\" class=\"header-anchor\"></a><span id=\"kai-qi-mongodb-shu-ju-ku-fu-wu\">开启MongoDB数据库服务</span></h4><p>&amp;emsp;&amp;emsp;mongo根目录<code>/bin/mongod -f</code> 配置文件目录&#x2F;配置文件名<br>例：<code>./bin/mongod -f conf/mongod.conf</code></p>\n<p>Mongod.conf文件内容参考如下：</p>\n<pre><code>dbpath = /data/mongodb\nlogpath = /data/mongodb/mongodb.log\nlogappend = true\nport = 27017\nfork = true\nauth = true\n</code></pre>\n<p>Mongod命令各常用参数说明：</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>–quiet</td>\n<td>安静输出</td>\n</tr>\n<tr>\n<td>–port arg</td>\n<td>指定服务端口号，默认端口27017</td>\n</tr>\n<tr>\n<td>–bind_ip arg</td>\n<td>绑定服务IP，若绑定127.0.0.1，则只能本机访问，不指定默认本地所有IP</td>\n</tr>\n<tr>\n<td>–logpath arg</td>\n<td>指定MongoDB日志文件，注意是指定文件不是目录</td>\n</tr>\n<tr>\n<td>–logappend</td>\n<td>使用追加的方式写日志</td>\n</tr>\n<tr>\n<td>–journal</td>\n<td>启用日志选项，MongoDB的数据操作将会写入到journal文件夹的文件里</td>\n</tr>\n<tr>\n<td>–journalOptions arg</td>\n<td>启用日志诊断选项</td>\n</tr>\n<tr>\n<td>–fork</td>\n<td>以守护进程的方式运行MongoDB，创建服务器进程</td>\n</tr>\n<tr>\n<td>–maxConns arg</td>\n<td>最大同时连接数 默认2000</td>\n</tr>\n<tr>\n<td>–auth</td>\n<td>启用验证</td>\n</tr>\n<tr>\n<td>–noauth</td>\n<td>不启用验证</td>\n</tr>\n<tr>\n<td>–dbpath arg</td>\n<td>指定数据库路径</td>\n</tr>\n<tr>\n<td>–ipv6</td>\n<td>启用IPv6选项</td>\n</tr>\n<tr>\n<td>–pidfilepath arg</td>\n<td>PID File 的完整路径，如果没有设置，则没有PID文件</td>\n</tr>\n</tbody></table>\n<span id=\"more\"></span>\n\n<h4><a href=\"#qiang-xing-guan-bi-mongodb\" class=\"header-anchor\"></a><span id=\"qiang-xing-guan-bi-mongodb\">强行关闭MongoDB</span></h4><p>&amp;emsp;&amp;emsp;先用命令 <code>ps -ef | grep mongod </code>查出mongod 的进程pid<br>然后<code>kill pid </code>即可</p>\n<h4><a href=\"#shu-ju-ku\" class=\"header-anchor\"></a><span id=\"shu-ju-ku\">数据库</span></h4><h5><a href=\"#lian-jie-mongodb-shu-ju-ku\" class=\"header-anchor\"></a><span id=\"lian-jie-mongodb-shu-ju-ku\">连接MongoDB数据库</span></h5><p>&amp;emsp;&amp;emsp;mongo根目录<code>/bin/mongo</code> 数据库地址:端口号&#x2F;库名称<br>例： <code>./bin/mongo 127.0.0.1:12345/test</code></p>\n<h5><a href=\"#guan-bi-mongodb-shu-ju-ku\" class=\"header-anchor\"></a><span id=\"guan-bi-mongodb-shu-ju-ku\">关闭MongoDB数据库</span></h5><p>&amp;emsp;&amp;emsp;<code>db.shutdownServer()</code></p>\n<h5><a href=\"#xin-jian-he-qie-huan-shu-ju-ku\" class=\"header-anchor\"></a><span id=\"xin-jian-he-qie-huan-shu-ju-ku\">新建和切换数据库</span></h5><p>&amp;emsp;&amp;emsp;MongoDB不用特别地去声明新建一个数据库，直接用<code>use 数据库名</code> 就可以了。</p>\n<h5><a href=\"#shan-chu-shu-ju-ku\" class=\"header-anchor\"></a><span id=\"shan-chu-shu-ju-ku\">删除数据库</span></h5><p>&amp;emsp;&amp;emsp;先用<code>db.use</code>切换到要删除的数据库，然后使用<code>db.dropDatabase()</code>来删除数据库</p>\n<h4><a href=\"#shu-ju-cao-zuo\" class=\"header-anchor\"></a><span id=\"shu-ju-cao-zuo\">数据操作</span></h4><h5><a href=\"#cha-ru-yi-tiao-shu-ju\" class=\"header-anchor\"></a><span id=\"cha-ru-yi-tiao-shu-ju\">插入一条数据</span></h5><p><code>db.collection.insert(&#123;key: value&#125;)</code></p>\n<p>其中集名称可以自己起</p>\n<h5><a href=\"#cha-ru-duo-tiao-shu-ju\" class=\"header-anchor\"></a><span id=\"cha-ru-duo-tiao-shu-ju\">插入多条数据</span></h5><p>&amp;emsp;&amp;emsp;可以使用for循环插入： <code>for(i＝3;i&lt;100;i++)db.collection.insert(&#123;key: value&#125;)</code></p>\n<h5><a href=\"#cha-xun-suo-you-shu-ju\" class=\"header-anchor\"></a><span id=\"cha-xun-suo-you-shu-ju\">查询所有数据</span></h5><p><code>db.collection.find()</code></p>\n<h5><a href=\"#cha-xun-dan-tiao-shu-ju\" class=\"header-anchor\"></a><span id=\"cha-xun-dan-tiao-shu-ju\">查询单条数据</span></h5><p><code>db.collection.find(&#123;key: value&#125;)</code></p>\n<h5><a href=\"#cha-xun-hou-you-tiao-jian-di-jin-xing-chu-li\" class=\"header-anchor\"></a><span id=\"cha-xun-hou-you-tiao-jian-di-jin-xing-chu-li\">查询后有条件地进行处理</span></h5><p><code>db.collection.find(&#123;key: value&#125;).skip(3).limit(5).sort(&#123;key: value&#125;)</code></p>\n<p>上面查询语句后的限制分别是skip（跳过多少条数据）、limit（限制查多少条数据）、sort(将查询出来的结果集排序)</p>\n<h5><a href=\"#xian-shi-ku-zhong-de-suo-you-ji-ming-cheng\" class=\"header-anchor\"></a><span id=\"xian-shi-ku-zhong-de-suo-you-ji-ming-cheng\">显示库中的所有集名称</span></h5><p><code>show collections</code></p>\n<h5><a href=\"#shan-chu-shu-ju-ku-zhong-de-ji-he\" class=\"header-anchor\"></a><span id=\"shan-chu-shu-ju-ku-zhong-de-ji-he\">删除数据库中的集合</span></h5><p><code>db.collection.drop()</code></p>\n<h4><a href=\"#suo-yin\" class=\"header-anchor\"></a><span id=\"suo-yin\">索引</span></h4><h5><a href=\"#cha-kan-suo-yin\" class=\"header-anchor\"></a><span id=\"cha-kan-suo-yin\">查看索引</span></h5><p><code>db.imooc_2.getIndexes()</code></p>\n<h5><a href=\"#id-suo-yin\" class=\"header-anchor\"></a><span id=\"id-suo-yin\">_id索引</span></h5><ul>\n<li>_id索引是绝大多数集合默认建立的索引。</li>\n<li>对于每个插入的数据，MongoDB都会自动生成一条唯一的_id字段。</li>\n</ul>\n<h5><a href=\"#chuang-jian-yi-ge-dan-jian-suo-yin\" class=\"header-anchor\"></a><span id=\"chuang-jian-yi-ge-dan-jian-suo-yin\">创建一个单键索引</span></h5><ul>\n<li>单键索引是最普通的索引</li>\n<li>单键索引不会自动创建</li>\n</ul>\n<p>&amp;emsp;&amp;emsp;例如： 一条记录为<code>&#123;x: 1, y: 2, z: 3&#125;</code>，如果我们在x上建立了索引，就可以使用x为条件进行查寻。</p>\n<p><code>db.collection.ensureIndex(&#123;index: order&#125;)</code></p>\n<ul>\n<li>index: 索引</li>\n<li>order: 1表示升序， -1表示降序</li>\n</ul>\n<h5><a href=\"#chuang-jian-yi-ge-duo-jian-suo-yin\" class=\"header-anchor\"></a><span id=\"chuang-jian-yi-ge-duo-jian-suo-yin\">创建一个多键索引</span></h5><p>多键索引与单键索引创建形式相同，区别在于字段的值。 </p>\n<ul>\n<li>单键索引：值为一个单一的值，如字符串，数字或日期。 </li>\n<li>多键索引：值具有多个记录，如数组。</li>\n</ul>\n<p><code>db.collection.insert(&#123;x:[1,2,3,4,5]&#125;) //插入一条数组数据</code></p>\n<p><code>db.collection.insert(&#123;x:new Date()&#125;) //插入一条数组数据</code></p>\n<h5><a href=\"#chuang-jian-yi-ge-fu-he-suo-yin\" class=\"header-anchor\"></a><span id=\"chuang-jian-yi-ge-fu-he-suo-yin\">创建一个复合索引</span></h5><p>&amp;emsp;&amp;emsp;当我们的查询条件不止一个的时候，就需要建立复合索引</p>\n<p>&amp;emsp;&amp;emsp;例如{x:1,y:2,z:3}这样一条数据，要按照x与y的值进行查询，就需要创建复合索引<code>db.collection.ensureIndex(&#123;x:1, y:1&#125;)</code>，然后就可以使用<code>&#123;x: 1, y:1&#125;</code>作为条件进行查询</p>\n<p><code>db.collection.ensureIndex(&#123;x:1, y:1&#125;)</code></p>\n<h5><a href=\"#chuang-jian-yi-ge-guo-qi-suo-yin\" class=\"header-anchor\"></a><span id=\"chuang-jian-yi-ge-guo-qi-suo-yin\">创建一个过期索引</span></h5><ul>\n<li>在一段时间后会过期的索引 </li>\n<li>在索引过期后，相应的数据会被删除 </li>\n<li>适合存储在一段时间之后会失效的数据，比如用户的登录信息、存储的日志等。</li>\n</ul>\n<p><code>db.imooc_2.ensureIndex(&#123;time:1&#125;,&#123;expireAfterSeconds: seconds&#125;)</code> 创建过期索引，time-字段，expireAfterSeconds在多少秒后过期，单位：秒</p>\n<p>&amp;emsp;&amp;emsp;过30秒后再find，刚才的数据就已经不存在了。</p>\n<p>&amp;emsp;&amp;emsp;过期索引的限制： </p>\n<ol>\n<li>存储在过期索引字段的值必须是指定的时间类型，必须是ISODate或者ISODate数组，不能使用时间戳，否则不能自动删除。<br>例如 &gt;db.imooc_2.insert({time:1})，这种是不能被自动删除的 </li>\n<li>如果指定了ISODate数组，则按照最小的时间进行删除。 </li>\n<li>过期索引不能是复合索引。因为不能指定两个过期时间。 </li>\n<li>删除时间是不精确的。删除过程是由MongoDB的后台进程每60s跑一次的，而且删除也需要一定时间，所以存在误差</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h4 id=\"开启MongoDB数据库服务\"><a href=\"#开启MongoDB数据库服务\" class=\"headerlink\" title=\"开启MongoDB数据库服务\"></a>开启MongoDB数据库服务</h4><p>&amp;emsp;&amp;emsp;mongo根目录<code>/bin/mongod -f</code> 配置文件目录&#x2F;配置文件名<br>例：<code>./bin/mongod -f conf/mongod.conf</code></p>\n<p>Mongod.conf文件内容参考如下：</p>\n<pre><code>dbpath = /data/mongodb\nlogpath = /data/mongodb/mongodb.log\nlogappend = true\nport = 27017\nfork = true\nauth = true\n</code></pre>\n<p>Mongod命令各常用参数说明：</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>–quiet</td>\n<td>安静输出</td>\n</tr>\n<tr>\n<td>–port arg</td>\n<td>指定服务端口号，默认端口27017</td>\n</tr>\n<tr>\n<td>–bind_ip arg</td>\n<td>绑定服务IP，若绑定127.0.0.1，则只能本机访问，不指定默认本地所有IP</td>\n</tr>\n<tr>\n<td>–logpath arg</td>\n<td>指定MongoDB日志文件，注意是指定文件不是目录</td>\n</tr>\n<tr>\n<td>–logappend</td>\n<td>使用追加的方式写日志</td>\n</tr>\n<tr>\n<td>–journal</td>\n<td>启用日志选项，MongoDB的数据操作将会写入到journal文件夹的文件里</td>\n</tr>\n<tr>\n<td>–journalOptions arg</td>\n<td>启用日志诊断选项</td>\n</tr>\n<tr>\n<td>–fork</td>\n<td>以守护进程的方式运行MongoDB，创建服务器进程</td>\n</tr>\n<tr>\n<td>–maxConns arg</td>\n<td>最大同时连接数 默认2000</td>\n</tr>\n<tr>\n<td>–auth</td>\n<td>启用验证</td>\n</tr>\n<tr>\n<td>–noauth</td>\n<td>不启用验证</td>\n</tr>\n<tr>\n<td>–dbpath arg</td>\n<td>指定数据库路径</td>\n</tr>\n<tr>\n<td>–ipv6</td>\n<td>启用IPv6选项</td>\n</tr>\n<tr>\n<td>–pidfilepath arg</td>\n<td>PID File 的完整路径，如果没有设置，则没有PID文件</td>\n</tr>\n</tbody></table>","more":"<h4 id=\"强行关闭MongoDB\"><a href=\"#强行关闭MongoDB\" class=\"headerlink\" title=\"强行关闭MongoDB\"></a>强行关闭MongoDB</h4><p>&amp;emsp;&amp;emsp;先用命令 <code>ps -ef | grep mongod </code>查出mongod 的进程pid<br>然后<code>kill pid </code>即可</p>\n<h4 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库</h4><h5 id=\"连接MongoDB数据库\"><a href=\"#连接MongoDB数据库\" class=\"headerlink\" title=\"连接MongoDB数据库\"></a>连接MongoDB数据库</h5><p>&amp;emsp;&amp;emsp;mongo根目录<code>/bin/mongo</code> 数据库地址:端口号&#x2F;库名称<br>例： <code>./bin/mongo 127.0.0.1:12345/test</code></p>\n<h5 id=\"关闭MongoDB数据库\"><a href=\"#关闭MongoDB数据库\" class=\"headerlink\" title=\"关闭MongoDB数据库\"></a>关闭MongoDB数据库</h5><p>&amp;emsp;&amp;emsp;<code>db.shutdownServer()</code></p>\n<h5 id=\"新建和切换数据库\"><a href=\"#新建和切换数据库\" class=\"headerlink\" title=\"新建和切换数据库\"></a>新建和切换数据库</h5><p>&amp;emsp;&amp;emsp;MongoDB不用特别地去声明新建一个数据库，直接用<code>use 数据库名</code> 就可以了。</p>\n<h5 id=\"删除数据库\"><a href=\"#删除数据库\" class=\"headerlink\" title=\"删除数据库\"></a>删除数据库</h5><p>&amp;emsp;&amp;emsp;先用<code>db.use</code>切换到要删除的数据库，然后使用<code>db.dropDatabase()</code>来删除数据库</p>\n<h4 id=\"数据操作\"><a href=\"#数据操作\" class=\"headerlink\" title=\"数据操作\"></a>数据操作</h4><h5 id=\"插入一条数据\"><a href=\"#插入一条数据\" class=\"headerlink\" title=\"插入一条数据\"></a>插入一条数据</h5><p><code>db.collection.insert(&#123;key: value&#125;)</code></p>\n<p>其中集名称可以自己起</p>\n<h5 id=\"插入多条数据\"><a href=\"#插入多条数据\" class=\"headerlink\" title=\"插入多条数据\"></a>插入多条数据</h5><p>&amp;emsp;&amp;emsp;可以使用for循环插入： <code>for(i＝3;i&lt;100;i++)db.collection.insert(&#123;key: value&#125;)</code></p>\n<h5 id=\"查询所有数据\"><a href=\"#查询所有数据\" class=\"headerlink\" title=\"查询所有数据\"></a>查询所有数据</h5><p><code>db.collection.find()</code></p>\n<h5 id=\"查询单条数据\"><a href=\"#查询单条数据\" class=\"headerlink\" title=\"查询单条数据\"></a>查询单条数据</h5><p><code>db.collection.find(&#123;key: value&#125;)</code></p>\n<h5 id=\"查询后有条件地进行处理\"><a href=\"#查询后有条件地进行处理\" class=\"headerlink\" title=\"查询后有条件地进行处理\"></a>查询后有条件地进行处理</h5><p><code>db.collection.find(&#123;key: value&#125;).skip(3).limit(5).sort(&#123;key: value&#125;)</code></p>\n<p>上面查询语句后的限制分别是skip（跳过多少条数据）、limit（限制查多少条数据）、sort(将查询出来的结果集排序)</p>\n<h5 id=\"显示库中的所有集名称\"><a href=\"#显示库中的所有集名称\" class=\"headerlink\" title=\"显示库中的所有集名称\"></a>显示库中的所有集名称</h5><p><code>show collections</code></p>\n<h5 id=\"删除数据库中的集合\"><a href=\"#删除数据库中的集合\" class=\"headerlink\" title=\"删除数据库中的集合\"></a>删除数据库中的集合</h5><p><code>db.collection.drop()</code></p>\n<h4 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h4><h5 id=\"查看索引\"><a href=\"#查看索引\" class=\"headerlink\" title=\"查看索引\"></a>查看索引</h5><p><code>db.imooc_2.getIndexes()</code></p>\n<h5 id=\"id索引\"><a href=\"#id索引\" class=\"headerlink\" title=\"_id索引\"></a>_id索引</h5><ul>\n<li>_id索引是绝大多数集合默认建立的索引。</li>\n<li>对于每个插入的数据，MongoDB都会自动生成一条唯一的_id字段。</li>\n</ul>\n<h5 id=\"创建一个单键索引\"><a href=\"#创建一个单键索引\" class=\"headerlink\" title=\"创建一个单键索引\"></a>创建一个单键索引</h5><ul>\n<li>单键索引是最普通的索引</li>\n<li>单键索引不会自动创建</li>\n</ul>\n<p>&amp;emsp;&amp;emsp;例如： 一条记录为<code>&#123;x: 1, y: 2, z: 3&#125;</code>，如果我们在x上建立了索引，就可以使用x为条件进行查寻。</p>\n<p><code>db.collection.ensureIndex(&#123;index: order&#125;)</code></p>\n<ul>\n<li>index: 索引</li>\n<li>order: 1表示升序， -1表示降序</li>\n</ul>\n<h5 id=\"创建一个多键索引\"><a href=\"#创建一个多键索引\" class=\"headerlink\" title=\"创建一个多键索引\"></a>创建一个多键索引</h5><p>多键索引与单键索引创建形式相同，区别在于字段的值。 </p>\n<ul>\n<li>单键索引：值为一个单一的值，如字符串，数字或日期。 </li>\n<li>多键索引：值具有多个记录，如数组。</li>\n</ul>\n<p><code>db.collection.insert(&#123;x:[1,2,3,4,5]&#125;) //插入一条数组数据</code></p>\n<p><code>db.collection.insert(&#123;x:new Date()&#125;) //插入一条数组数据</code></p>\n<h5 id=\"创建一个复合索引\"><a href=\"#创建一个复合索引\" class=\"headerlink\" title=\"创建一个复合索引\"></a>创建一个复合索引</h5><p>&amp;emsp;&amp;emsp;当我们的查询条件不止一个的时候，就需要建立复合索引</p>\n<p>&amp;emsp;&amp;emsp;例如{x:1,y:2,z:3}这样一条数据，要按照x与y的值进行查询，就需要创建复合索引<code>db.collection.ensureIndex(&#123;x:1, y:1&#125;)</code>，然后就可以使用<code>&#123;x: 1, y:1&#125;</code>作为条件进行查询</p>\n<p><code>db.collection.ensureIndex(&#123;x:1, y:1&#125;)</code></p>\n<h5 id=\"创建一个过期索引\"><a href=\"#创建一个过期索引\" class=\"headerlink\" title=\"创建一个过期索引\"></a>创建一个过期索引</h5><ul>\n<li>在一段时间后会过期的索引 </li>\n<li>在索引过期后，相应的数据会被删除 </li>\n<li>适合存储在一段时间之后会失效的数据，比如用户的登录信息、存储的日志等。</li>\n</ul>\n<p><code>db.imooc_2.ensureIndex(&#123;time:1&#125;,&#123;expireAfterSeconds: seconds&#125;)</code> 创建过期索引，time-字段，expireAfterSeconds在多少秒后过期，单位：秒</p>\n<p>&amp;emsp;&amp;emsp;过30秒后再find，刚才的数据就已经不存在了。</p>\n<p>&amp;emsp;&amp;emsp;过期索引的限制： </p>\n<ol>\n<li>存储在过期索引字段的值必须是指定的时间类型，必须是ISODate或者ISODate数组，不能使用时间戳，否则不能自动删除。<br>例如 &gt;db.imooc_2.insert({time:1})，这种是不能被自动删除的 </li>\n<li>如果指定了ISODate数组，则按照最小的时间进行删除。 </li>\n<li>过期索引不能是复合索引。因为不能指定两个过期时间。 </li>\n<li>删除时间是不精确的。删除过程是由MongoDB的后台进程每60s跑一次的，而且删除也需要一定时间，所以存在误差</li>\n</ol>"},{"title":"如何通过JS通过媒体查询规则来做样式控制","date":"2017-12-10T12:33:00.000Z","_content":"\n在移动开发中，我们可以通过CSS的@media媒体查询来控制在不同屏幕宽度上应用不同的样式，但是在某些情况下，我们也希望可以通过脚本来作更多的控制。下面就通过一个新特性`window.matchMedia`来作控制。\n\n通过传入一个@media规则进window.matchMedia方法会返回一个新的MediaQueryList 对象，这个对象表示指定的媒体查询字符串解析后的结果。\n\n`mql = window.matchMedia(mediaQueryString)`\n\n其中mediaQueryString参数是一个字符串，表示即将返回一个新MediaQueryList对象的媒体查询。\n\n> [更多详细查阅 MDN API](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/matchMedia)\n\nMediaQueryList对象在一个document上维持着一系列的媒体查询，并负责处理当媒体查询在其document上发生变化时向监听器进行通知的发送。\n\n如果你需要以编程方式来检测一个document上的媒体查询的值的变化，这个MediaQueryList对象使得通过观察其document而检测它的媒体查询的值的变化成为可能，而不是周期性地对这些媒体查询的值进行检查。\n\n它有两个方法：\n\n`void addListener(MediaQueryListListener listener);`\n`void removeListener(MediaQueryListListener listener);`\n\n**MediaQueryList对象是一个非标准的对象，使用时应注意其在浏览器上的可用性。**\n\n> [关于MediaQueryList的介绍](https://developer.mozilla.org/zh-CN/docs/Web/API/MediaQueryList)\n\n下面是一个兼容例子：\n\n```\nif (window.matchMedia) {\n    var mql = window.matchMedia(\"(min-width: 480px\");\n    mql.addListener(mediaChangeHandler);\n    mediaChangeHandler(mql);\n} else {\n    window.addEventListener('resize', function() {\n        var innerWidth = window.innerWidth\n                    || document.documentElement.clientWidth\n                    || document.body.clientWidth;\n        mediaChangeHandler(innerWidth >= 480 ? {matches: true} : {matches: false}, false);\n    })    \n}\n\nfunction mediaChangeHandler(mql) {\n    if (mql.matches) {\n        // 匹配成功时\n        \n    } else {\n        // 匹配失败时\n    }\n}\n```","source":"_posts/mediaMatch.md","raw":"title: 如何通过JS通过媒体查询规则来做样式控制\ntags:\n  - 个人总结\ncategories:\n  - JavaScript\n  - ''\ndate: 2017-12-10 20:33:00\n---\n\n在移动开发中，我们可以通过CSS的@media媒体查询来控制在不同屏幕宽度上应用不同的样式，但是在某些情况下，我们也希望可以通过脚本来作更多的控制。下面就通过一个新特性`window.matchMedia`来作控制。\n\n通过传入一个@media规则进window.matchMedia方法会返回一个新的MediaQueryList 对象，这个对象表示指定的媒体查询字符串解析后的结果。\n\n`mql = window.matchMedia(mediaQueryString)`\n\n其中mediaQueryString参数是一个字符串，表示即将返回一个新MediaQueryList对象的媒体查询。\n\n> [更多详细查阅 MDN API](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/matchMedia)\n\nMediaQueryList对象在一个document上维持着一系列的媒体查询，并负责处理当媒体查询在其document上发生变化时向监听器进行通知的发送。\n\n如果你需要以编程方式来检测一个document上的媒体查询的值的变化，这个MediaQueryList对象使得通过观察其document而检测它的媒体查询的值的变化成为可能，而不是周期性地对这些媒体查询的值进行检查。\n\n它有两个方法：\n\n`void addListener(MediaQueryListListener listener);`\n`void removeListener(MediaQueryListListener listener);`\n\n**MediaQueryList对象是一个非标准的对象，使用时应注意其在浏览器上的可用性。**\n\n> [关于MediaQueryList的介绍](https://developer.mozilla.org/zh-CN/docs/Web/API/MediaQueryList)\n\n下面是一个兼容例子：\n\n```\nif (window.matchMedia) {\n    var mql = window.matchMedia(\"(min-width: 480px\");\n    mql.addListener(mediaChangeHandler);\n    mediaChangeHandler(mql);\n} else {\n    window.addEventListener('resize', function() {\n        var innerWidth = window.innerWidth\n                    || document.documentElement.clientWidth\n                    || document.body.clientWidth;\n        mediaChangeHandler(innerWidth >= 480 ? {matches: true} : {matches: false}, false);\n    })    \n}\n\nfunction mediaChangeHandler(mql) {\n    if (mql.matches) {\n        // 匹配成功时\n        \n    } else {\n        // 匹配失败时\n    }\n}\n```","slug":"mediaMatch","published":1,"updated":"2023-04-11T03:30:27.124Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgbppebg001nbvch90yf8txr","content":"<p>在移动开发中，我们可以通过CSS的@media媒体查询来控制在不同屏幕宽度上应用不同的样式，但是在某些情况下，我们也希望可以通过脚本来作更多的控制。下面就通过一个新特性<code>window.matchMedia</code>来作控制。</p>\n<p>通过传入一个@media规则进window.matchMedia方法会返回一个新的MediaQueryList 对象，这个对象表示指定的媒体查询字符串解析后的结果。</p>\n<p><code>mql = window.matchMedia(mediaQueryString)</code></p>\n<p>其中mediaQueryString参数是一个字符串，表示即将返回一个新MediaQueryList对象的媒体查询。</p>\n<blockquote>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/matchMedia\">更多详细查阅 MDN API</a></p>\n</blockquote>\n<p>MediaQueryList对象在一个document上维持着一系列的媒体查询，并负责处理当媒体查询在其document上发生变化时向监听器进行通知的发送。</p>\n<p>如果你需要以编程方式来检测一个document上的媒体查询的值的变化，这个MediaQueryList对象使得通过观察其document而检测它的媒体查询的值的变化成为可能，而不是周期性地对这些媒体查询的值进行检查。</p>\n<p>它有两个方法：</p>\n<p><code>void addListener(MediaQueryListListener listener);</code><br><code>void removeListener(MediaQueryListListener listener);</code></p>\n<p><strong>MediaQueryList对象是一个非标准的对象，使用时应注意其在浏览器上的可用性。</strong></p>\n<blockquote>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/MediaQueryList\">关于MediaQueryList的介绍</a></p>\n</blockquote>\n<p>下面是一个兼容例子：</p>\n<pre><code>if (window.matchMedia) &#123;\n    var mql = window.matchMedia(&quot;(min-width: 480px&quot;);\n    mql.addListener(mediaChangeHandler);\n    mediaChangeHandler(mql);\n&#125; else &#123;\n    window.addEventListener(&#39;resize&#39;, function() &#123;\n        var innerWidth = window.innerWidth\n                    || document.documentElement.clientWidth\n                    || document.body.clientWidth;\n        mediaChangeHandler(innerWidth &gt;= 480 ? &#123;matches: true&#125; : &#123;matches: false&#125;, false);\n    &#125;)    \n&#125;\n\nfunction mediaChangeHandler(mql) &#123;\n    if (mql.matches) &#123;\n        // 匹配成功时\n        \n    &#125; else &#123;\n        // 匹配失败时\n    &#125;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>在移动开发中，我们可以通过CSS的@media媒体查询来控制在不同屏幕宽度上应用不同的样式，但是在某些情况下，我们也希望可以通过脚本来作更多的控制。下面就通过一个新特性<code>window.matchMedia</code>来作控制。</p>\n<p>通过传入一个@media规则进window.matchMedia方法会返回一个新的MediaQueryList 对象，这个对象表示指定的媒体查询字符串解析后的结果。</p>\n<p><code>mql = window.matchMedia(mediaQueryString)</code></p>\n<p>其中mediaQueryString参数是一个字符串，表示即将返回一个新MediaQueryList对象的媒体查询。</p>\n<blockquote>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/matchMedia\">更多详细查阅 MDN API</a></p>\n</blockquote>\n<p>MediaQueryList对象在一个document上维持着一系列的媒体查询，并负责处理当媒体查询在其document上发生变化时向监听器进行通知的发送。</p>\n<p>如果你需要以编程方式来检测一个document上的媒体查询的值的变化，这个MediaQueryList对象使得通过观察其document而检测它的媒体查询的值的变化成为可能，而不是周期性地对这些媒体查询的值进行检查。</p>\n<p>它有两个方法：</p>\n<p><code>void addListener(MediaQueryListListener listener);</code><br><code>void removeListener(MediaQueryListListener listener);</code></p>\n<p><strong>MediaQueryList对象是一个非标准的对象，使用时应注意其在浏览器上的可用性。</strong></p>\n<blockquote>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/MediaQueryList\">关于MediaQueryList的介绍</a></p>\n</blockquote>\n<p>下面是一个兼容例子：</p>\n<pre><code>if (window.matchMedia) &#123;\n    var mql = window.matchMedia(&quot;(min-width: 480px&quot;);\n    mql.addListener(mediaChangeHandler);\n    mediaChangeHandler(mql);\n&#125; else &#123;\n    window.addEventListener(&#39;resize&#39;, function() &#123;\n        var innerWidth = window.innerWidth\n                    || document.documentElement.clientWidth\n                    || document.body.clientWidth;\n        mediaChangeHandler(innerWidth &gt;= 480 ? &#123;matches: true&#125; : &#123;matches: false&#125;, false);\n    &#125;)    \n&#125;\n\nfunction mediaChangeHandler(mql) &#123;\n    if (mql.matches) &#123;\n        // 匹配成功时\n        \n    &#125; else &#123;\n        // 匹配失败时\n    &#125;\n&#125;\n</code></pre>\n"},{"layout":"[post]","title":"Nginx conf 常用配置","date":"2019-07-15T15:52:00.000Z","_content":"\n因为不熟悉Nginx，对他的匹配规则似懂非懂，所以平时在部署自己项目的时候经常会遇到各种问题，因此在此记录一下一路踩过的坑。\n\n### nginx.conf 与 conf.d 目录\n\n首先Nginx里有一份基础配置nginx.conf文件，里面通常是nginx的一些默认配置信息，注意在默认配置前有一行引入自定义文件的代码\n```\n# Load modular configuration files from the /etc/nginx/conf.d directory.\n# See http://nginx.org/en/docs/ngx_core_module.html#include\n# for more information.\ninclude /etc/nginx/conf.d/*.conf;\n```\n最后一行把 `conf` 目录下的所有以.conf后缀结尾的文件都引入进来，而因为Nginx配置文件的规则是前面先匹配到的先生效，所以我们可以把自己写的自定义配置文件在 `conf` 目录下，然后覆盖后面的默认配置。\n\n### server 块\n\n关于server块目前比较明白的有以下几个字段：\n\n- `listen` 代表着监听的端口\n  > 网页通常是监听80、443端口，还有一些服务应用应该监听对应\b的端口，如21、25等。\n- `server_name` 代表监听的域名\n  > 通常是在域名服务商通过设置相应的域名然后解析到服务器的ip，其设置的域名便是 `server_name` 的值\n- `root` 匹配后指向的访问路径（拼接匹配的url部分）\n  > \b要注意当前nginx使用的用户是否有该对指向的路径有相应的访问权限。\n\n### location 块\n\n`location` 处于 `server` 块下，一个 `server` 块可以有若干个 `location` ，先匹配到的 `location` 规则先处理，并停止往后匹配。\n\n```\nserver {\n  ...\n  location [pattern rule] {\n    ...\n  }\n}\n```\n\n`location` 后面接对应的 url 匹配规则，可以是要匹配的字符串（字符串后面可带`/`也可以不带），也可以是正则。\n\n通过 `location` 实现请求转发来处理前端接口跨域问题，还可以通过它来实现外部对内部服务的代理访问。一般我会用到以下几个字段：\n\n- `root` 匹配后指向的访问路径（拼接匹配的url部分）\n- `alias` 匹配后指向的访问路径（替换匹配的url部分）\n- `proxy_pass` 把请求转发到指向地\b址\n- `index` 匹配后指向的访问路径下的文件\n\n#### root 与 alias\n\n当 `location` 是用字符串来匹配时，配置 `root` 与 `alias` 是区别的：当 `location` 匹配到相应的 `url` `后，root` 对在匹配的规则后接上 `root` \b指向的路径，而 `alisa` 会直接替换掉匹配的url部分。\n\n举个例子：\n\n```\nlocation ~ ^/xingcard/ {\n  root /data/www/;\n}\n```\n\n当一个URI是 `/app/xingcard/index.html` 时，nginx将会返回服务器上 `/data/www/app/xingcard/index.html`的文件。root会根据完整的URI请求来映射，也就是/path/uri。\n\n如果我们把 `root` 换成 `alias` 的话：\n\n```\nlocation ~ ^/app/ {\n  alais /data/www/;\n}\n```\n\n则nginx会将`/data/www/xingcard/index.html`返回给客户端。区别就是在于有没有替换掉\b `location` 匹配的 `app`。\n\n> 注意：\n> 1. 使用alias时，目录名后面一定要加\"/\"。\n> 2. alias可以指定任何名称。\n> 3. alias在使用正则匹配时，必须捕捉要匹配的内容并在指定的内容处使用。\n> 4. alias只能位于location块中。\n\n#### proxy_pass 字段\n\n`ngixn` 对于 `proxy_pass` \b的处理分为两种，一种是只有IP和端口号，另一种是除了IP和端口号外还包含了其它路径（URI）（其中也包括单个`/`符）。\n\n对于不含URI的 `proxy_pass` ， nginx 将会保留location中的路径部分，\b即在 `proxy_pass` 的值后面拼接上 `loaction` 的匹配路径。\n\n对于含URI的 `proxy_pass` ，nginx将使用诸如alias的替换方式对URL进行替换。\n\n例如：\n\n```\nserver {\n  ...\n  location /api1/ {\n    proxy_pass http://localhost:8080;\n  }\n\n  location /api2/ {\n    proxy_pass http://localhost:8080/;\n  }\n}\n```\n\n访问 `ip/api1/login` 地址，\b\b转发到服务器的地址应该是 `http://localhost:8080/api1/login`\n访问 `ip/api2/login` 地址，\b\b转发到服务器的地址应该是 `http://localhost:8080/login`\n\n#### index 字段\n\n> 转载自：[Nginx之坑：完全理解location中的index，配置网站初始页](https://blog.csdn.net/qq_32331073/article/details/81945134)\n\n- 该指令后面可以跟多个文件，用空格隔开；\n- 如果包括多个文件，Nginx会根据文件的枚举顺序来检查，直到查找的文件存在；\n- 文件可以是相对路径也可以是绝对路径，绝对路径需要放在最后；\n- 文件可以使用变量$来命名；\n\n```\nserver {\n  ...\n  location /app {\n    ...\n    index  index.$geo.html  index.0.html  /index.html;\n  }\n}\n```\n\n该指令拥有默认值，index index.html ，即，如果没有给出index，默认初始页为index.html\n\nNginx给了三种方式来选择初始页，三种方式按照顺序来执行：\n\n- [ngx_http_random_index_module](http://nginx.org/en/docs/http/ngx_http_random_index_module.html) 模块，从给定的目录中随机选择一个文件作为初始页，而且这个动作发生在 [ngx_http_index_module](http://nginx.org/en/docs/http/ngx_http_index_module.html) 之前，注意：这个模块默认情况下没有被安装，需要在安装时提供配置参数 -with-http_random_index_module；\n- [ngx_http_index_module](http://nginx.org/en/docs/http/ngx_http_index_module.html) 模块，根据index指令规则来选择初始页；\n- [ngx_http_autoindex_module](http://nginx.org/en/docs/http/ngx_http_autoindex_module.html) 模块，可以使用指定方式，根据给定目录中的文件列表自动生成初始页，这个动作发生在 \n[ngx_http_index_module](http://nginx.org/en/docs/http/ngx_http_index_module.html) 之后，即只有通过index指令无法确认初始页，此时启用后的自动生成模块才会被使用。\n\n**如果文件存在，则使用文件作为路径，发起内部重定向。直观上看上去就像再一次从客户端发起请求，Nginx再一次搜索location一样。** 既然是内部重定向，域名+端口不发生变化，所以只会在同一个server下搜索。同样，如果内部重定向发生在proxy_pass反向代理后，那么重定向只会发生在代理配置中的同一个server。\n\n```\nserver {\n    listen      80;\n    server_name example.org www.example.org;    \n    \n    location / {\n        root    /data/www;\n        index   index.html index.php;\n    }\n    \n    location ~ \\.php$ {\n        root    /data/www/test;\n    }\n}\n```\n\n上面的例子中，如果你使用example.org或www.example.org直接发起请求，那么首先会访问到“/”的location，结合root与index指令，会先判断/data/www/index.html是否存在，如果不，则接着查看\n/data/www/index.php ，如果存在，则使用/index.php发起内部重定向，就像从客户端再一次发起请求一样，Nginx会再一次搜索location，毫无疑问匹配到第二个~ \\.php$，从而访问到/data/www/test/index.php。","source":"_posts/nginx-commmand-record.md","raw":"layout: '[post]'\ntitle: Nginx conf 常用配置\ntags:\n  - 转载\n  - 备忘翻阅\ncategories:\n  - 项目构建\n  - ''\ndate: 2019-07-15 23:52:00\n---\n\n因为不熟悉Nginx，对他的匹配规则似懂非懂，所以平时在部署自己项目的时候经常会遇到各种问题，因此在此记录一下一路踩过的坑。\n\n### nginx.conf 与 conf.d 目录\n\n首先Nginx里有一份基础配置nginx.conf文件，里面通常是nginx的一些默认配置信息，注意在默认配置前有一行引入自定义文件的代码\n```\n# Load modular configuration files from the /etc/nginx/conf.d directory.\n# See http://nginx.org/en/docs/ngx_core_module.html#include\n# for more information.\ninclude /etc/nginx/conf.d/*.conf;\n```\n最后一行把 `conf` 目录下的所有以.conf后缀结尾的文件都引入进来，而因为Nginx配置文件的规则是前面先匹配到的先生效，所以我们可以把自己写的自定义配置文件在 `conf` 目录下，然后覆盖后面的默认配置。\n\n### server 块\n\n关于server块目前比较明白的有以下几个字段：\n\n- `listen` 代表着监听的端口\n  > 网页通常是监听80、443端口，还有一些服务应用应该监听对应\b的端口，如21、25等。\n- `server_name` 代表监听的域名\n  > 通常是在域名服务商通过设置相应的域名然后解析到服务器的ip，其设置的域名便是 `server_name` 的值\n- `root` 匹配后指向的访问路径（拼接匹配的url部分）\n  > \b要注意当前nginx使用的用户是否有该对指向的路径有相应的访问权限。\n\n### location 块\n\n`location` 处于 `server` 块下，一个 `server` 块可以有若干个 `location` ，先匹配到的 `location` 规则先处理，并停止往后匹配。\n\n```\nserver {\n  ...\n  location [pattern rule] {\n    ...\n  }\n}\n```\n\n`location` 后面接对应的 url 匹配规则，可以是要匹配的字符串（字符串后面可带`/`也可以不带），也可以是正则。\n\n通过 `location` 实现请求转发来处理前端接口跨域问题，还可以通过它来实现外部对内部服务的代理访问。一般我会用到以下几个字段：\n\n- `root` 匹配后指向的访问路径（拼接匹配的url部分）\n- `alias` 匹配后指向的访问路径（替换匹配的url部分）\n- `proxy_pass` 把请求转发到指向地\b址\n- `index` 匹配后指向的访问路径下的文件\n\n#### root 与 alias\n\n当 `location` 是用字符串来匹配时，配置 `root` 与 `alias` 是区别的：当 `location` 匹配到相应的 `url` `后，root` 对在匹配的规则后接上 `root` \b指向的路径，而 `alisa` 会直接替换掉匹配的url部分。\n\n举个例子：\n\n```\nlocation ~ ^/xingcard/ {\n  root /data/www/;\n}\n```\n\n当一个URI是 `/app/xingcard/index.html` 时，nginx将会返回服务器上 `/data/www/app/xingcard/index.html`的文件。root会根据完整的URI请求来映射，也就是/path/uri。\n\n如果我们把 `root` 换成 `alias` 的话：\n\n```\nlocation ~ ^/app/ {\n  alais /data/www/;\n}\n```\n\n则nginx会将`/data/www/xingcard/index.html`返回给客户端。区别就是在于有没有替换掉\b `location` 匹配的 `app`。\n\n> 注意：\n> 1. 使用alias时，目录名后面一定要加\"/\"。\n> 2. alias可以指定任何名称。\n> 3. alias在使用正则匹配时，必须捕捉要匹配的内容并在指定的内容处使用。\n> 4. alias只能位于location块中。\n\n#### proxy_pass 字段\n\n`ngixn` 对于 `proxy_pass` \b的处理分为两种，一种是只有IP和端口号，另一种是除了IP和端口号外还包含了其它路径（URI）（其中也包括单个`/`符）。\n\n对于不含URI的 `proxy_pass` ， nginx 将会保留location中的路径部分，\b即在 `proxy_pass` 的值后面拼接上 `loaction` 的匹配路径。\n\n对于含URI的 `proxy_pass` ，nginx将使用诸如alias的替换方式对URL进行替换。\n\n例如：\n\n```\nserver {\n  ...\n  location /api1/ {\n    proxy_pass http://localhost:8080;\n  }\n\n  location /api2/ {\n    proxy_pass http://localhost:8080/;\n  }\n}\n```\n\n访问 `ip/api1/login` 地址，\b\b转发到服务器的地址应该是 `http://localhost:8080/api1/login`\n访问 `ip/api2/login` 地址，\b\b转发到服务器的地址应该是 `http://localhost:8080/login`\n\n#### index 字段\n\n> 转载自：[Nginx之坑：完全理解location中的index，配置网站初始页](https://blog.csdn.net/qq_32331073/article/details/81945134)\n\n- 该指令后面可以跟多个文件，用空格隔开；\n- 如果包括多个文件，Nginx会根据文件的枚举顺序来检查，直到查找的文件存在；\n- 文件可以是相对路径也可以是绝对路径，绝对路径需要放在最后；\n- 文件可以使用变量$来命名；\n\n```\nserver {\n  ...\n  location /app {\n    ...\n    index  index.$geo.html  index.0.html  /index.html;\n  }\n}\n```\n\n该指令拥有默认值，index index.html ，即，如果没有给出index，默认初始页为index.html\n\nNginx给了三种方式来选择初始页，三种方式按照顺序来执行：\n\n- [ngx_http_random_index_module](http://nginx.org/en/docs/http/ngx_http_random_index_module.html) 模块，从给定的目录中随机选择一个文件作为初始页，而且这个动作发生在 [ngx_http_index_module](http://nginx.org/en/docs/http/ngx_http_index_module.html) 之前，注意：这个模块默认情况下没有被安装，需要在安装时提供配置参数 -with-http_random_index_module；\n- [ngx_http_index_module](http://nginx.org/en/docs/http/ngx_http_index_module.html) 模块，根据index指令规则来选择初始页；\n- [ngx_http_autoindex_module](http://nginx.org/en/docs/http/ngx_http_autoindex_module.html) 模块，可以使用指定方式，根据给定目录中的文件列表自动生成初始页，这个动作发生在 \n[ngx_http_index_module](http://nginx.org/en/docs/http/ngx_http_index_module.html) 之后，即只有通过index指令无法确认初始页，此时启用后的自动生成模块才会被使用。\n\n**如果文件存在，则使用文件作为路径，发起内部重定向。直观上看上去就像再一次从客户端发起请求，Nginx再一次搜索location一样。** 既然是内部重定向，域名+端口不发生变化，所以只会在同一个server下搜索。同样，如果内部重定向发生在proxy_pass反向代理后，那么重定向只会发生在代理配置中的同一个server。\n\n```\nserver {\n    listen      80;\n    server_name example.org www.example.org;    \n    \n    location / {\n        root    /data/www;\n        index   index.html index.php;\n    }\n    \n    location ~ \\.php$ {\n        root    /data/www/test;\n    }\n}\n```\n\n上面的例子中，如果你使用example.org或www.example.org直接发起请求，那么首先会访问到“/”的location，结合root与index指令，会先判断/data/www/index.html是否存在，如果不，则接着查看\n/data/www/index.php ，如果存在，则使用/index.php发起内部重定向，就像从客户端再一次发起请求一样，Nginx会再一次搜索location，毫无疑问匹配到第二个~ \\.php$，从而访问到/data/www/test/index.php。","slug":"nginx-commmand-record","published":1,"updated":"2023-04-11T03:30:27.125Z","comments":1,"photos":[],"link":"","_id":"clgbppebh001rbvch3uwq2jnq","content":"<p>因为不熟悉Nginx，对他的匹配规则似懂非懂，所以平时在部署自己项目的时候经常会遇到各种问题，因此在此记录一下一路踩过的坑。</p>\n<h3><a href=\"#nginx-conf-yu-conf-d-mu-lu\" class=\"header-anchor\"></a><span id=\"nginx-conf-yu-conf-d-mu-lu\">nginx.conf 与 conf.d 目录</span></h3><p>首先Nginx里有一份基础配置nginx.conf文件，里面通常是nginx的一些默认配置信息，注意在默认配置前有一行引入自定义文件的代码</p>\n<pre><code># Load modular configuration files from the /etc/nginx/conf.d directory.\n# See http://nginx.org/en/docs/ngx_core_module.html#include\n# for more information.\ninclude /etc/nginx/conf.d/*.conf;\n</code></pre>\n<p>最后一行把 <code>conf</code> 目录下的所有以.conf后缀结尾的文件都引入进来，而因为Nginx配置文件的规则是前面先匹配到的先生效，所以我们可以把自己写的自定义配置文件在 <code>conf</code> 目录下，然后覆盖后面的默认配置。</p>\n<h3><a href=\"#server-kuai\" class=\"header-anchor\"></a><span id=\"server-kuai\">server 块</span></h3><p>关于server块目前比较明白的有以下几个字段：</p>\n<ul>\n<li><code>listen</code> 代表着监听的端口<blockquote>\n<p>网页通常是监听80、443端口，还有一些服务应用应该监听对应\b的端口，如21、25等。</p>\n</blockquote>\n</li>\n<li><code>server_name</code> 代表监听的域名<blockquote>\n<p>通常是在域名服务商通过设置相应的域名然后解析到服务器的ip，其设置的域名便是 <code>server_name</code> 的值</p>\n</blockquote>\n</li>\n<li><code>root</code> 匹配后指向的访问路径（拼接匹配的url部分）<blockquote>\n<p>\b要注意当前nginx使用的用户是否有该对指向的路径有相应的访问权限。</p>\n</blockquote>\n</li>\n</ul>\n<h3><a href=\"#location-kuai\" class=\"header-anchor\"></a><span id=\"location-kuai\">location 块</span></h3><p><code>location</code> 处于 <code>server</code> 块下，一个 <code>server</code> 块可以有若干个 <code>location</code> ，先匹配到的 <code>location</code> 规则先处理，并停止往后匹配。</p>\n<pre><code>server &#123;\n  ...\n  location [pattern rule] &#123;\n    ...\n  &#125;\n&#125;\n</code></pre>\n<p><code>location</code> 后面接对应的 url 匹配规则，可以是要匹配的字符串（字符串后面可带<code>/</code>也可以不带），也可以是正则。</p>\n<p>通过 <code>location</code> 实现请求转发来处理前端接口跨域问题，还可以通过它来实现外部对内部服务的代理访问。一般我会用到以下几个字段：</p>\n<ul>\n<li><code>root</code> 匹配后指向的访问路径（拼接匹配的url部分）</li>\n<li><code>alias</code> 匹配后指向的访问路径（替换匹配的url部分）</li>\n<li><code>proxy_pass</code> 把请求转发到指向地\b址</li>\n<li><code>index</code> 匹配后指向的访问路径下的文件</li>\n</ul>\n<h4><a href=\"#root-yu-alias\" class=\"header-anchor\"></a><span id=\"root-yu-alias\">root 与 alias</span></h4><p>当 <code>location</code> 是用字符串来匹配时，配置 <code>root</code> 与 <code>alias</code> 是区别的：当 <code>location</code> 匹配到相应的 <code>url</code> <code>后，root</code> 对在匹配的规则后接上 <code>root</code> \b指向的路径，而 <code>alisa</code> 会直接替换掉匹配的url部分。</p>\n<p>举个例子：</p>\n<pre><code>location ~ ^/xingcard/ &#123;\n  root /data/www/;\n&#125;\n</code></pre>\n<p>当一个URI是 <code>/app/xingcard/index.html</code> 时，nginx将会返回服务器上 <code>/data/www/app/xingcard/index.html</code>的文件。root会根据完整的URI请求来映射，也就是&#x2F;path&#x2F;uri。</p>\n<p>如果我们把 <code>root</code> 换成 <code>alias</code> 的话：</p>\n<pre><code>location ~ ^/app/ &#123;\n  alais /data/www/;\n&#125;\n</code></pre>\n<p>则nginx会将<code>/data/www/xingcard/index.html</code>返回给客户端。区别就是在于有没有替换掉\b <code>location</code> 匹配的 <code>app</code>。</p>\n<blockquote>\n<p>注意：</p>\n<ol>\n<li>使用alias时，目录名后面一定要加”&#x2F;“。</li>\n<li>alias可以指定任何名称。</li>\n<li>alias在使用正则匹配时，必须捕捉要匹配的内容并在指定的内容处使用。</li>\n<li>alias只能位于location块中。</li>\n</ol>\n</blockquote>\n<h4><a href=\"#proxy-pass-zi-duan\" class=\"header-anchor\"></a><span id=\"proxy-pass-zi-duan\">proxy_pass 字段</span></h4><p><code>ngixn</code> 对于 <code>proxy_pass</code> \b的处理分为两种，一种是只有IP和端口号，另一种是除了IP和端口号外还包含了其它路径（URI）（其中也包括单个<code>/</code>符）。</p>\n<p>对于不含URI的 <code>proxy_pass</code> ， nginx 将会保留location中的路径部分，\b即在 <code>proxy_pass</code> 的值后面拼接上 <code>loaction</code> 的匹配路径。</p>\n<p>对于含URI的 <code>proxy_pass</code> ，nginx将使用诸如alias的替换方式对URL进行替换。</p>\n<p>例如：</p>\n<pre><code>server &#123;\n  ...\n  location /api1/ &#123;\n    proxy_pass http://localhost:8080;\n  &#125;\n\n  location /api2/ &#123;\n    proxy_pass http://localhost:8080/;\n  &#125;\n&#125;\n</code></pre>\n<p>访问 <code>ip/api1/login</code> 地址，\b\b转发到服务器的地址应该是 <code>http://localhost:8080/api1/login</code><br>访问 <code>ip/api2/login</code> 地址，\b\b转发到服务器的地址应该是 <code>http://localhost:8080/login</code></p>\n<h4><a href=\"#index-zi-duan\" class=\"header-anchor\"></a><span id=\"index-zi-duan\">index 字段</span></h4><blockquote>\n<p>转载自：<a href=\"https://blog.csdn.net/qq_32331073/article/details/81945134\">Nginx之坑：完全理解location中的index，配置网站初始页</a></p>\n</blockquote>\n<ul>\n<li>该指令后面可以跟多个文件，用空格隔开；</li>\n<li>如果包括多个文件，Nginx会根据文件的枚举顺序来检查，直到查找的文件存在；</li>\n<li>文件可以是相对路径也可以是绝对路径，绝对路径需要放在最后；</li>\n<li>文件可以使用变量$来命名；</li>\n</ul>\n<pre><code>server &#123;\n  ...\n  location /app &#123;\n    ...\n    index  index.$geo.html  index.0.html  /index.html;\n  &#125;\n&#125;\n</code></pre>\n<p>该指令拥有默认值，index index.html ，即，如果没有给出index，默认初始页为index.html</p>\n<p>Nginx给了三种方式来选择初始页，三种方式按照顺序来执行：</p>\n<ul>\n<li><a href=\"http://nginx.org/en/docs/http/ngx_http_random_index_module.html\">ngx_http_random_index_module</a> 模块，从给定的目录中随机选择一个文件作为初始页，而且这个动作发生在 <a href=\"http://nginx.org/en/docs/http/ngx_http_index_module.html\">ngx_http_index_module</a> 之前，注意：这个模块默认情况下没有被安装，需要在安装时提供配置参数 -with-http_random_index_module；</li>\n<li><a href=\"http://nginx.org/en/docs/http/ngx_http_index_module.html\">ngx_http_index_module</a> 模块，根据index指令规则来选择初始页；</li>\n<li><a href=\"http://nginx.org/en/docs/http/ngx_http_autoindex_module.html\">ngx_http_autoindex_module</a> 模块，可以使用指定方式，根据给定目录中的文件列表自动生成初始页，这个动作发生在<br><a href=\"http://nginx.org/en/docs/http/ngx_http_index_module.html\">ngx_http_index_module</a> 之后，即只有通过index指令无法确认初始页，此时启用后的自动生成模块才会被使用。</li>\n</ul>\n<p><strong>如果文件存在，则使用文件作为路径，发起内部重定向。直观上看上去就像再一次从客户端发起请求，Nginx再一次搜索location一样。</strong> 既然是内部重定向，域名+端口不发生变化，所以只会在同一个server下搜索。同样，如果内部重定向发生在proxy_pass反向代理后，那么重定向只会发生在代理配置中的同一个server。</p>\n<pre><code>server &#123;\n    listen      80;\n    server_name example.org www.example.org;    \n    \n    location / &#123;\n        root    /data/www;\n        index   index.html index.php;\n    &#125;\n    \n    location ~ \\.php$ &#123;\n        root    /data/www/test;\n    &#125;\n&#125;\n</code></pre>\n<p>上面的例子中，如果你使用example.org或<a href=\"http://www.example.org直接发起请求,那么首先会访问到“/%E2%80%9D%E7%9A%84location%EF%BC%8C%E7%BB%93%E5%90%88root%E4%B8%8Eindex%E6%8C%87%E4%BB%A4%EF%BC%8C%E4%BC%9A%E5%85%88%E5%88%A4%E6%96%AD/data/www/index.html%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%B8%8D%EF%BC%8C%E5%88%99%E6%8E%A5%E7%9D%80%E6%9F%A5%E7%9C%8B\">www.example.org直接发起请求，那么首先会访问到“/”的location，结合root与index指令，会先判断/data/www/index.html是否存在，如果不，则接着查看</a><br>&#x2F;data&#x2F;www&#x2F;index.php ，如果存在，则使用&#x2F;index.php发起内部重定向，就像从客户端再一次发起请求一样，Nginx会再一次搜索location，毫无疑问匹配到第二个~ .php$，从而访问到&#x2F;data&#x2F;www&#x2F;test&#x2F;index.php。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>因为不熟悉Nginx，对他的匹配规则似懂非懂，所以平时在部署自己项目的时候经常会遇到各种问题，因此在此记录一下一路踩过的坑。</p>\n<h3 id=\"nginx-conf-与-conf-d-目录\"><a href=\"#nginx-conf-与-conf-d-目录\" class=\"headerlink\" title=\"nginx.conf 与 conf.d 目录\"></a>nginx.conf 与 conf.d 目录</h3><p>首先Nginx里有一份基础配置nginx.conf文件，里面通常是nginx的一些默认配置信息，注意在默认配置前有一行引入自定义文件的代码</p>\n<pre><code># Load modular configuration files from the /etc/nginx/conf.d directory.\n# See http://nginx.org/en/docs/ngx_core_module.html#include\n# for more information.\ninclude /etc/nginx/conf.d/*.conf;\n</code></pre>\n<p>最后一行把 <code>conf</code> 目录下的所有以.conf后缀结尾的文件都引入进来，而因为Nginx配置文件的规则是前面先匹配到的先生效，所以我们可以把自己写的自定义配置文件在 <code>conf</code> 目录下，然后覆盖后面的默认配置。</p>\n<h3 id=\"server-块\"><a href=\"#server-块\" class=\"headerlink\" title=\"server 块\"></a>server 块</h3><p>关于server块目前比较明白的有以下几个字段：</p>\n<ul>\n<li><code>listen</code> 代表着监听的端口<blockquote>\n<p>网页通常是监听80、443端口，还有一些服务应用应该监听对应\b的端口，如21、25等。</p>\n</blockquote>\n</li>\n<li><code>server_name</code> 代表监听的域名<blockquote>\n<p>通常是在域名服务商通过设置相应的域名然后解析到服务器的ip，其设置的域名便是 <code>server_name</code> 的值</p>\n</blockquote>\n</li>\n<li><code>root</code> 匹配后指向的访问路径（拼接匹配的url部分）<blockquote>\n<p>\b要注意当前nginx使用的用户是否有该对指向的路径有相应的访问权限。</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"location-块\"><a href=\"#location-块\" class=\"headerlink\" title=\"location 块\"></a>location 块</h3><p><code>location</code> 处于 <code>server</code> 块下，一个 <code>server</code> 块可以有若干个 <code>location</code> ，先匹配到的 <code>location</code> 规则先处理，并停止往后匹配。</p>\n<pre><code>server &#123;\n  ...\n  location [pattern rule] &#123;\n    ...\n  &#125;\n&#125;\n</code></pre>\n<p><code>location</code> 后面接对应的 url 匹配规则，可以是要匹配的字符串（字符串后面可带<code>/</code>也可以不带），也可以是正则。</p>\n<p>通过 <code>location</code> 实现请求转发来处理前端接口跨域问题，还可以通过它来实现外部对内部服务的代理访问。一般我会用到以下几个字段：</p>\n<ul>\n<li><code>root</code> 匹配后指向的访问路径（拼接匹配的url部分）</li>\n<li><code>alias</code> 匹配后指向的访问路径（替换匹配的url部分）</li>\n<li><code>proxy_pass</code> 把请求转发到指向地\b址</li>\n<li><code>index</code> 匹配后指向的访问路径下的文件</li>\n</ul>\n<h4 id=\"root-与-alias\"><a href=\"#root-与-alias\" class=\"headerlink\" title=\"root 与 alias\"></a>root 与 alias</h4><p>当 <code>location</code> 是用字符串来匹配时，配置 <code>root</code> 与 <code>alias</code> 是区别的：当 <code>location</code> 匹配到相应的 <code>url</code> <code>后，root</code> 对在匹配的规则后接上 <code>root</code> \b指向的路径，而 <code>alisa</code> 会直接替换掉匹配的url部分。</p>\n<p>举个例子：</p>\n<pre><code>location ~ ^/xingcard/ &#123;\n  root /data/www/;\n&#125;\n</code></pre>\n<p>当一个URI是 <code>/app/xingcard/index.html</code> 时，nginx将会返回服务器上 <code>/data/www/app/xingcard/index.html</code>的文件。root会根据完整的URI请求来映射，也就是&#x2F;path&#x2F;uri。</p>\n<p>如果我们把 <code>root</code> 换成 <code>alias</code> 的话：</p>\n<pre><code>location ~ ^/app/ &#123;\n  alais /data/www/;\n&#125;\n</code></pre>\n<p>则nginx会将<code>/data/www/xingcard/index.html</code>返回给客户端。区别就是在于有没有替换掉\b <code>location</code> 匹配的 <code>app</code>。</p>\n<blockquote>\n<p>注意：</p>\n<ol>\n<li>使用alias时，目录名后面一定要加”&#x2F;“。</li>\n<li>alias可以指定任何名称。</li>\n<li>alias在使用正则匹配时，必须捕捉要匹配的内容并在指定的内容处使用。</li>\n<li>alias只能位于location块中。</li>\n</ol>\n</blockquote>\n<h4 id=\"proxy-pass-字段\"><a href=\"#proxy-pass-字段\" class=\"headerlink\" title=\"proxy_pass 字段\"></a>proxy_pass 字段</h4><p><code>ngixn</code> 对于 <code>proxy_pass</code> \b的处理分为两种，一种是只有IP和端口号，另一种是除了IP和端口号外还包含了其它路径（URI）（其中也包括单个<code>/</code>符）。</p>\n<p>对于不含URI的 <code>proxy_pass</code> ， nginx 将会保留location中的路径部分，\b即在 <code>proxy_pass</code> 的值后面拼接上 <code>loaction</code> 的匹配路径。</p>\n<p>对于含URI的 <code>proxy_pass</code> ，nginx将使用诸如alias的替换方式对URL进行替换。</p>\n<p>例如：</p>\n<pre><code>server &#123;\n  ...\n  location /api1/ &#123;\n    proxy_pass http://localhost:8080;\n  &#125;\n\n  location /api2/ &#123;\n    proxy_pass http://localhost:8080/;\n  &#125;\n&#125;\n</code></pre>\n<p>访问 <code>ip/api1/login</code> 地址，\b\b转发到服务器的地址应该是 <code>http://localhost:8080/api1/login</code><br>访问 <code>ip/api2/login</code> 地址，\b\b转发到服务器的地址应该是 <code>http://localhost:8080/login</code></p>\n<h4 id=\"index-字段\"><a href=\"#index-字段\" class=\"headerlink\" title=\"index 字段\"></a>index 字段</h4><blockquote>\n<p>转载自：<a href=\"https://blog.csdn.net/qq_32331073/article/details/81945134\">Nginx之坑：完全理解location中的index，配置网站初始页</a></p>\n</blockquote>\n<ul>\n<li>该指令后面可以跟多个文件，用空格隔开；</li>\n<li>如果包括多个文件，Nginx会根据文件的枚举顺序来检查，直到查找的文件存在；</li>\n<li>文件可以是相对路径也可以是绝对路径，绝对路径需要放在最后；</li>\n<li>文件可以使用变量$来命名；</li>\n</ul>\n<pre><code>server &#123;\n  ...\n  location /app &#123;\n    ...\n    index  index.$geo.html  index.0.html  /index.html;\n  &#125;\n&#125;\n</code></pre>\n<p>该指令拥有默认值，index index.html ，即，如果没有给出index，默认初始页为index.html</p>\n<p>Nginx给了三种方式来选择初始页，三种方式按照顺序来执行：</p>\n<ul>\n<li><a href=\"http://nginx.org/en/docs/http/ngx_http_random_index_module.html\">ngx_http_random_index_module</a> 模块，从给定的目录中随机选择一个文件作为初始页，而且这个动作发生在 <a href=\"http://nginx.org/en/docs/http/ngx_http_index_module.html\">ngx_http_index_module</a> 之前，注意：这个模块默认情况下没有被安装，需要在安装时提供配置参数 -with-http_random_index_module；</li>\n<li><a href=\"http://nginx.org/en/docs/http/ngx_http_index_module.html\">ngx_http_index_module</a> 模块，根据index指令规则来选择初始页；</li>\n<li><a href=\"http://nginx.org/en/docs/http/ngx_http_autoindex_module.html\">ngx_http_autoindex_module</a> 模块，可以使用指定方式，根据给定目录中的文件列表自动生成初始页，这个动作发生在<br><a href=\"http://nginx.org/en/docs/http/ngx_http_index_module.html\">ngx_http_index_module</a> 之后，即只有通过index指令无法确认初始页，此时启用后的自动生成模块才会被使用。</li>\n</ul>\n<p><strong>如果文件存在，则使用文件作为路径，发起内部重定向。直观上看上去就像再一次从客户端发起请求，Nginx再一次搜索location一样。</strong> 既然是内部重定向，域名+端口不发生变化，所以只会在同一个server下搜索。同样，如果内部重定向发生在proxy_pass反向代理后，那么重定向只会发生在代理配置中的同一个server。</p>\n<pre><code>server &#123;\n    listen      80;\n    server_name example.org www.example.org;    \n    \n    location / &#123;\n        root    /data/www;\n        index   index.html index.php;\n    &#125;\n    \n    location ~ \\.php$ &#123;\n        root    /data/www/test;\n    &#125;\n&#125;\n</code></pre>\n<p>上面的例子中，如果你使用example.org或<a href=\"http://www.example.org直接发起请求,那么首先会访问到“/%E2%80%9D%E7%9A%84location%EF%BC%8C%E7%BB%93%E5%90%88root%E4%B8%8Eindex%E6%8C%87%E4%BB%A4%EF%BC%8C%E4%BC%9A%E5%85%88%E5%88%A4%E6%96%AD/data/www/index.html%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%B8%8D%EF%BC%8C%E5%88%99%E6%8E%A5%E7%9D%80%E6%9F%A5%E7%9C%8B\">www.example.org直接发起请求，那么首先会访问到“/”的location，结合root与index指令，会先判断/data/www/index.html是否存在，如果不，则接着查看</a><br>&#x2F;data&#x2F;www&#x2F;index.php ，如果存在，则使用&#x2F;index.php发起内部重定向，就像从客户端再一次发起请求一样，Nginx会再一次搜索location，毫无疑问匹配到第二个~ .php$，从而访问到&#x2F;data&#x2F;www&#x2F;test&#x2F;index.php。</p>\n"},{"layout":"[post]","title":"渐进式图片加载效果","date":"2017-09-11T01:01:00.000Z","_content":"前些日子在逛知乎，发现有个效果挺不错的，就是当一开始页面上的图片是模糊的，过一会图片变清晰。突然感觉这种效果比传统的占位图效果要好的多，于是在好奇心的驱使下百度了一下效果，得出的实现常用可以分为图床和图片地址替换。下面简单叙述一下两个方案的实现思路：\n\n### 图床\n\n就是在图片原来的地方放一个标签用来放模糊的照片，盖在原来清晰大图片的上方，当大图加载成功后，原来盖在上面的图片隐藏掉。图床可以是一个Div或者是Canvas等。\n\n<!-- more -->\n\n### 地址替换\n\n思路和上面差不多，一开始的时候先加载一张低清的图，把高清图片的地址存在某个属性里，等页面加载完成后，用JS取到高请图片的地址，然后用image对象加载，等加载完成后再把图片地址替换成高清的地址。\n\n本文介绍的是方法二用地址替换的方式来实现：\n\n### 案例效果\n\n![案例效果](/images/processing_image.gif)\n\n### 案例代码\n\n```HTML\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>Processing Image Effect Demo</title>\n    <link rel=\"stylesheet\" href=\"./css/index.css\">\n</head>\n<body>\n    <div class=\"img-con\" id=\"imgCon\">\n        <img src=\"./img/1_small.jpg\" data-src=\"./img/1_big.jpeg\" alt=\"图片1\" id=\"img\">\n        <img src=\"./img/2_small.jpg\" data-src=\"./img/2_big.jpg\" alt=\"图片2\" id=\"img\">\n        <img src=\"./img/3_small.jpg\" data-src=\"./img/3_big.jpg\" alt=\"图片3\" id=\"img\">\n        <img src=\"./img/4_small.jpg\" data-src=\"./img/4_big.jpg\" alt=\"图片4\" id=\"img\">\n        <img src=\"./img/5_small.jpg\" data-src=\"./img/5_big.jpg\" alt=\"图片5\" id=\"img\">\n    </div>\n    <script>\n        window.onload = function() {\n            var imgCon = document.getElementById('imgCon')\n            var imgs = imgCon.getElementsByTagName('img')\n            for (var i = 0; i < imgs.length; i++) {\n                \n                (function(curImg) {\n                    var tempImg = null;\n                    tempImg = document.createElement('img')\n                    console.log(curImg)\n                    tempImg.src = curImg.dataset.src;\n                    tempImg.onload = function(e) {\n                        curImg.src = tempImg.src\n                        curImg.style.filter = 'blur(0px)'\n                    }\n                })(imgs[i])\n            }\n        }\n    </script>\n</body>\n</html>\n```\n\n```CSS\n.img-con img {\n    width: 100%;\n    height: 400px;\n    -webkit-transition: filter .3s ease-out 0s;\n    -moz-transition: filter .3s ease-out 0s;\n    transition: filter .3s ease-out 0s;\n    filter: blur(10px);\n    -ms-filter: blur(10px);\n    -webkit-filter: blur(10px);\n}\n```\n\n### 关键知识点\n\n- JS Image对象\n- CSS3 filter blur 属性\n\n*注意： Image对象读取图片的过程是异步的，需要弄清楚代码执行的时序问题*","source":"_posts/processing-medium-effect.md","raw":"layout: '[post]'\ntitle: 渐进式图片加载效果\ntags:\n  - 每周一练\n  - 最佳实践\n  - ''\ncategories: []\ndate: 2017-09-11 09:01:00\n---\n前些日子在逛知乎，发现有个效果挺不错的，就是当一开始页面上的图片是模糊的，过一会图片变清晰。突然感觉这种效果比传统的占位图效果要好的多，于是在好奇心的驱使下百度了一下效果，得出的实现常用可以分为图床和图片地址替换。下面简单叙述一下两个方案的实现思路：\n\n### 图床\n\n就是在图片原来的地方放一个标签用来放模糊的照片，盖在原来清晰大图片的上方，当大图加载成功后，原来盖在上面的图片隐藏掉。图床可以是一个Div或者是Canvas等。\n\n<!-- more -->\n\n### 地址替换\n\n思路和上面差不多，一开始的时候先加载一张低清的图，把高清图片的地址存在某个属性里，等页面加载完成后，用JS取到高请图片的地址，然后用image对象加载，等加载完成后再把图片地址替换成高清的地址。\n\n本文介绍的是方法二用地址替换的方式来实现：\n\n### 案例效果\n\n![案例效果](/images/processing_image.gif)\n\n### 案例代码\n\n```HTML\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>Processing Image Effect Demo</title>\n    <link rel=\"stylesheet\" href=\"./css/index.css\">\n</head>\n<body>\n    <div class=\"img-con\" id=\"imgCon\">\n        <img src=\"./img/1_small.jpg\" data-src=\"./img/1_big.jpeg\" alt=\"图片1\" id=\"img\">\n        <img src=\"./img/2_small.jpg\" data-src=\"./img/2_big.jpg\" alt=\"图片2\" id=\"img\">\n        <img src=\"./img/3_small.jpg\" data-src=\"./img/3_big.jpg\" alt=\"图片3\" id=\"img\">\n        <img src=\"./img/4_small.jpg\" data-src=\"./img/4_big.jpg\" alt=\"图片4\" id=\"img\">\n        <img src=\"./img/5_small.jpg\" data-src=\"./img/5_big.jpg\" alt=\"图片5\" id=\"img\">\n    </div>\n    <script>\n        window.onload = function() {\n            var imgCon = document.getElementById('imgCon')\n            var imgs = imgCon.getElementsByTagName('img')\n            for (var i = 0; i < imgs.length; i++) {\n                \n                (function(curImg) {\n                    var tempImg = null;\n                    tempImg = document.createElement('img')\n                    console.log(curImg)\n                    tempImg.src = curImg.dataset.src;\n                    tempImg.onload = function(e) {\n                        curImg.src = tempImg.src\n                        curImg.style.filter = 'blur(0px)'\n                    }\n                })(imgs[i])\n            }\n        }\n    </script>\n</body>\n</html>\n```\n\n```CSS\n.img-con img {\n    width: 100%;\n    height: 400px;\n    -webkit-transition: filter .3s ease-out 0s;\n    -moz-transition: filter .3s ease-out 0s;\n    transition: filter .3s ease-out 0s;\n    filter: blur(10px);\n    -ms-filter: blur(10px);\n    -webkit-filter: blur(10px);\n}\n```\n\n### 关键知识点\n\n- JS Image对象\n- CSS3 filter blur 属性\n\n*注意： Image对象读取图片的过程是异步的，需要弄清楚代码执行的时序问题*","slug":"processing-medium-effect","published":1,"updated":"2023-04-11T03:30:27.125Z","comments":1,"photos":[],"link":"","_id":"clgbppebi001ubvchfzb0dvyf","content":"<p>前些日子在逛知乎，发现有个效果挺不错的，就是当一开始页面上的图片是模糊的，过一会图片变清晰。突然感觉这种效果比传统的占位图效果要好的多，于是在好奇心的驱使下百度了一下效果，得出的实现常用可以分为图床和图片地址替换。下面简单叙述一下两个方案的实现思路：</p>\n<h3><a href=\"#tu-chuang\" class=\"header-anchor\"></a><span id=\"tu-chuang\">图床</span></h3><p>就是在图片原来的地方放一个标签用来放模糊的照片，盖在原来清晰大图片的上方，当大图加载成功后，原来盖在上面的图片隐藏掉。图床可以是一个Div或者是Canvas等。</p>\n<span id=\"more\"></span>\n\n<h3><a href=\"#di-zhi-ti-huan\" class=\"header-anchor\"></a><span id=\"di-zhi-ti-huan\">地址替换</span></h3><p>思路和上面差不多，一开始的时候先加载一张低清的图，把高清图片的地址存在某个属性里，等页面加载完成后，用JS取到高请图片的地址，然后用image对象加载，等加载完成后再把图片地址替换成高清的地址。</p>\n<p>本文介绍的是方法二用地址替换的方式来实现：</p>\n<h3><a href=\"#an-li-xiao-guo\" class=\"header-anchor\"></a><span id=\"an-li-xiao-guo\">案例效果</span></h3><p><img src=\"/images/processing_image.gif\" alt=\"案例效果\"></p>\n<h3><a href=\"#an-li-dai-ma\" class=\"header-anchor\"></a><span id=\"an-li-dai-ma\">案例代码</span></h3><pre><code class=\"HTML\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;\n    &lt;title&gt;Processing Image Effect Demo&lt;/title&gt;\n    &lt;link rel=&quot;stylesheet&quot; href=&quot;./css/index.css&quot;&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div class=&quot;img-con&quot; id=&quot;imgCon&quot;&gt;\n        &lt;img src=&quot;./img/1_small.jpg&quot; data-src=&quot;./img/1_big.jpeg&quot; alt=&quot;图片1&quot; id=&quot;img&quot;&gt;\n        &lt;img src=&quot;./img/2_small.jpg&quot; data-src=&quot;./img/2_big.jpg&quot; alt=&quot;图片2&quot; id=&quot;img&quot;&gt;\n        &lt;img src=&quot;./img/3_small.jpg&quot; data-src=&quot;./img/3_big.jpg&quot; alt=&quot;图片3&quot; id=&quot;img&quot;&gt;\n        &lt;img src=&quot;./img/4_small.jpg&quot; data-src=&quot;./img/4_big.jpg&quot; alt=&quot;图片4&quot; id=&quot;img&quot;&gt;\n        &lt;img src=&quot;./img/5_small.jpg&quot; data-src=&quot;./img/5_big.jpg&quot; alt=&quot;图片5&quot; id=&quot;img&quot;&gt;\n    &lt;/div&gt;\n    &lt;script&gt;\n        window.onload = function() &#123;\n            var imgCon = document.getElementById(&#39;imgCon&#39;)\n            var imgs = imgCon.getElementsByTagName(&#39;img&#39;)\n            for (var i = 0; i &lt; imgs.length; i++) &#123;\n                \n                (function(curImg) &#123;\n                    var tempImg = null;\n                    tempImg = document.createElement(&#39;img&#39;)\n                    console.log(curImg)\n                    tempImg.src = curImg.dataset.src;\n                    tempImg.onload = function(e) &#123;\n                        curImg.src = tempImg.src\n                        curImg.style.filter = &#39;blur(0px)&#39;\n                    &#125;\n                &#125;)(imgs[i])\n            &#125;\n        &#125;\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<pre><code class=\"CSS\">.img-con img &#123;\n    width: 100%;\n    height: 400px;\n    -webkit-transition: filter .3s ease-out 0s;\n    -moz-transition: filter .3s ease-out 0s;\n    transition: filter .3s ease-out 0s;\n    filter: blur(10px);\n    -ms-filter: blur(10px);\n    -webkit-filter: blur(10px);\n&#125;\n</code></pre>\n<h3><a href=\"#guan-jian-zhi-shi-dian\" class=\"header-anchor\"></a><span id=\"guan-jian-zhi-shi-dian\">关键知识点</span></h3><ul>\n<li>JS Image对象</li>\n<li>CSS3 filter blur 属性</li>\n</ul>\n<p><em>注意： Image对象读取图片的过程是异步的，需要弄清楚代码执行的时序问题</em></p>\n","site":{"data":{}},"excerpt":"<p>前些日子在逛知乎，发现有个效果挺不错的，就是当一开始页面上的图片是模糊的，过一会图片变清晰。突然感觉这种效果比传统的占位图效果要好的多，于是在好奇心的驱使下百度了一下效果，得出的实现常用可以分为图床和图片地址替换。下面简单叙述一下两个方案的实现思路：</p>\n<h3 id=\"图床\"><a href=\"#图床\" class=\"headerlink\" title=\"图床\"></a>图床</h3><p>就是在图片原来的地方放一个标签用来放模糊的照片，盖在原来清晰大图片的上方，当大图加载成功后，原来盖在上面的图片隐藏掉。图床可以是一个Div或者是Canvas等。</p>","more":"<h3 id=\"地址替换\"><a href=\"#地址替换\" class=\"headerlink\" title=\"地址替换\"></a>地址替换</h3><p>思路和上面差不多，一开始的时候先加载一张低清的图，把高清图片的地址存在某个属性里，等页面加载完成后，用JS取到高请图片的地址，然后用image对象加载，等加载完成后再把图片地址替换成高清的地址。</p>\n<p>本文介绍的是方法二用地址替换的方式来实现：</p>\n<h3 id=\"案例效果\"><a href=\"#案例效果\" class=\"headerlink\" title=\"案例效果\"></a>案例效果</h3><p><img src=\"/images/processing_image.gif\" alt=\"案例效果\"></p>\n<h3 id=\"案例代码\"><a href=\"#案例代码\" class=\"headerlink\" title=\"案例代码\"></a>案例代码</h3><pre><code class=\"HTML\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;\n    &lt;title&gt;Processing Image Effect Demo&lt;/title&gt;\n    &lt;link rel=&quot;stylesheet&quot; href=&quot;./css/index.css&quot;&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div class=&quot;img-con&quot; id=&quot;imgCon&quot;&gt;\n        &lt;img src=&quot;./img/1_small.jpg&quot; data-src=&quot;./img/1_big.jpeg&quot; alt=&quot;图片1&quot; id=&quot;img&quot;&gt;\n        &lt;img src=&quot;./img/2_small.jpg&quot; data-src=&quot;./img/2_big.jpg&quot; alt=&quot;图片2&quot; id=&quot;img&quot;&gt;\n        &lt;img src=&quot;./img/3_small.jpg&quot; data-src=&quot;./img/3_big.jpg&quot; alt=&quot;图片3&quot; id=&quot;img&quot;&gt;\n        &lt;img src=&quot;./img/4_small.jpg&quot; data-src=&quot;./img/4_big.jpg&quot; alt=&quot;图片4&quot; id=&quot;img&quot;&gt;\n        &lt;img src=&quot;./img/5_small.jpg&quot; data-src=&quot;./img/5_big.jpg&quot; alt=&quot;图片5&quot; id=&quot;img&quot;&gt;\n    &lt;/div&gt;\n    &lt;script&gt;\n        window.onload = function() &#123;\n            var imgCon = document.getElementById(&#39;imgCon&#39;)\n            var imgs = imgCon.getElementsByTagName(&#39;img&#39;)\n            for (var i = 0; i &lt; imgs.length; i++) &#123;\n                \n                (function(curImg) &#123;\n                    var tempImg = null;\n                    tempImg = document.createElement(&#39;img&#39;)\n                    console.log(curImg)\n                    tempImg.src = curImg.dataset.src;\n                    tempImg.onload = function(e) &#123;\n                        curImg.src = tempImg.src\n                        curImg.style.filter = &#39;blur(0px)&#39;\n                    &#125;\n                &#125;)(imgs[i])\n            &#125;\n        &#125;\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<pre><code class=\"CSS\">.img-con img &#123;\n    width: 100%;\n    height: 400px;\n    -webkit-transition: filter .3s ease-out 0s;\n    -moz-transition: filter .3s ease-out 0s;\n    transition: filter .3s ease-out 0s;\n    filter: blur(10px);\n    -ms-filter: blur(10px);\n    -webkit-filter: blur(10px);\n&#125;\n</code></pre>\n<h3 id=\"关键知识点\"><a href=\"#关键知识点\" class=\"headerlink\" title=\"关键知识点\"></a>关键知识点</h3><ul>\n<li>JS Image对象</li>\n<li>CSS3 filter blur 属性</li>\n</ul>\n<p><em>注意： Image对象读取图片的过程是异步的，需要弄清楚代码执行的时序问题</em></p>"},{"layout":"[post]","title":"单页面应用微信分享跳坑指南","date":"2018-08-01T11:18:00.000Z","_content":"\n## 前言\n\n最近在开发的时候遇到了一个微信分享的bug，就是无论你在哪个路径下的页面，发送给朋友后点开都只会跳到项目的首页。本来微信分享这个只算是一个小功能，也很好解决，但由于项目的特殊性，使得在这个bug解决起来并没有那么顺手，所以记录一下备以后翻阅。\n\n## 坑点\n\n- Vue单页面应用，前端通过Hash控制路由——iOS在微信中不能正常地改变浏览器的hash值，分享出去的页面地址被莫名其妙地添加了参数。\n\n- 微信的安全策略——由于存在js安全域名限制，使得在本地调试更难。\n\n- jssdk配置签名。\n\n## 跳坑方法\n\n### 分享地址被奇怪的被带上了参数\n\n在传统开发中，路由通常都是在后端完成的，但是在Vue单页面中，都是通过控制history interface来控制页面之间的跳转，在我们的项目中我们使用hash的方式，但是在分享给朋友后却发现分享地址被加上了一些参数，比如：\n\n我分享出去的地址是：`market.lenkuntang.cn/#/home`，分享后会变成了`market.lenkuntang.cn/?from=singlemessage#/home`。这到底会不会影响到我们的分享操作呢？这就要了解vue-router的工作原理了，翻看了一下vue-router的源码，发现如下代码：\n\n```\n// this is delayed until the app mounts\n  // to avoid the hashchange listener being fired too early\n  setupListeners () {\n    const router = this.router\n    const expectScroll = router.options.scrollBehavior\n    const supportsScroll = supportsPushState && expectScroll\n\n    if (supportsScroll) {\n      setupScroll()\n    }\n\n    window.addEventListener(supportsPushState ? 'popstate' : 'hashchange', () => {\n      const current = this.current\n      if (!ensureSlash()) {\n        return\n      }\n      this.transitionTo(getHash(), route => {\n        if (supportsScroll) {\n          handleScroll(this.router, route, current, true)\n        }\n        if (!supportsPushState) {\n          replaceHash(route.fullPath)\n        }\n      })\n    })\n  }\n```\n\n[hash.js](https://user-gold-cdn.xitu.io/2018/8/1/164f36e016b35048)\n\n原来在vue-router初始化的时候，会监听`window`对象的`hashchange`属性，如想发现浏览器的`hash`值发生变化了，就会调用`History.transitionTo`方法，关键就在这个方法会传入一个`getHash`方法为作参数，如果在这种地址`market.lenkuntang.cn/?from=singlemessage#/home`也能正确地拿到正确的`hash`的话，那我们就可以断定这种意外对我们的分享是没有影响的。当我们继续去看`getHash`方法，在`hash.js`往下翻点会找到这个方法的实现：\n\n```\nexport function getHash (): string {\n  // We can't use window.location.hash here because it's not\n  // consistent across browsers - Firefox will pre-decode it!\n  const href = window.location.href\n  const index = href.indexOf('#')\n  return index === -1 ? '' : href.slice(index + 1)\n}\n```\n\n我们可以清楚地知道，当这条地址`market.lenkuntang.cn/?from=singlemessage#/home`经过`getHash`之后会直接返回`#`号后面的字符串，也就是\n`/home`，所以可以得出是不会对我们分享的功能有影响的。\n\n### iOS在微信环境中浏览器地址不变\n\n在Vue-router实现前端控制路由都是通过HTML5 新增的History Interface接口来控制页面之间的跳转的，在跳转的同时通过修改`window`中`loaction`的`hash`属性反映回浏览器的地址，但是当遇到iOS时却意外地发现这个`hash`属性一直没有被改变，导致每次分享出去的地址都是首页，在网上一查发现这原来是个通病，解决的方法就是引入微信的JsSDK来手动控制分享的地址。\n\n### 引入JsSDK所带来的问题\n\n在引入了JsSDK后，首先要对它进行配置，相关配置项如下：\n\n```\nwx.config({\n    debug: true, // 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。\n    appId: '', // 必填，公众号的唯一标识\n    timestamp: , // 必填，生成签名的时间戳\n    nonceStr: '', // 必填，生成签名的随机串\n    signature: '',// 必填，签名\n    jsApiList: [] // 必填，需要使用的JS接口列表\n});\n```\n\n说明一下这里的参数分别从哪里来，appId是从微信公众号里获取的，`timestamp`和`nonceStr`还有`signature`是从服务器中返回的。jsApiList可以在[所有JS接口列表](https://mp.weixin.qq.com/wiki?action=doc&id=mp1421141115&t=0.11471355121805527#63)中找到。\n\n> 注：`timestamp`和`nonceStr`其实是可以在前端生成然后传给服务器再参与签名的计算的，但一般在考虑到安全原因，`timestamp`, `nonceStr`这些参数应该从服务器返回回来（因为它参与了签名的计算）。\n\n> 注意：这里的传入的随机字符串字段`nonceStr`是**驼峰命名！！！**\n\n然后就是引入JsSDK中遇到最大的问题——签名问题，要正确地实现使用JsSDK，在服务器端首先要集齐这四种元素：\n- noncestr（随机字符串）\n- jsapi_ticket（通过微信接口获得的ticket）\n- timestamp（时间戳）\n- url（当前网页的URL，不包含#及其后面部分）\n\n然后把这些元素按字典序（ASCII 码从小到大排序）排后使用URL键值对的格式（即key1=value1&key2=value2…）拼接成字符串，再对字符串进行sha1加密，字段名和字段值都采用原始值，不进行URL 转义，即可得到所谓的签名。\n\n> 注意：这里的传入的随机字符串字段`noncestr`是**全小写！！！**\n\n最后附上签名检验工具的地址：[http://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=jsapisign](http://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=jsapisign)\n\n还有示例代码：[http://demo.open.weixin.qq.com/jssdk/sample.zip](http://demo.open.weixin.qq.com/jssdk/sample.zip)\n\n\n得到签名后再把`timestamp`，`nonceStr`和`signature`传回给前端进行JsSDK的初始化配置。\n\n### 再说计算签名的URL\n\n这里再说说参与签名的url，因为这里传过去的是当前见面的URL且不包括#及其后面部分，这对于使用Hash模式的单页面应用来说是个好消息，这样就代表我们只需要在页面加载时初始化一次后便可以在所有页面上使用（对于传统的路径导航，因为URL变了所以要重新初始化，也就是说要在使用到的JsSDK功能的页面中都要重新请求后台接口拿签名再初始化！！）。所以，一般来说我们通常会在`App.vue`这个文件中作JsSDK的初始化操作，当初始化正确后便可在其它页面上直接使用JsSDK接口的功能。\n\n次外，由于微信存在对JsSDK的使用限定在微信公众号里所设置的JS接口安全域名范围里，所以对于本地调度用的`localhost`域名来说是不可行的，直接提示`invalid url domain`，在这里有两种方式可以解决这个问题，一种是通过修改`host`的方法来实现本地调试，方法如下：\n\n#### window系统：\n\n进入系统盘目录（通常是C盘）： `C:\\Windows\\System32\\drivers\\etc`，找到`hosts`文件，打开后文件末尾添加一条记录`127.0.0.1 market.lenkuntang.cn`,这条记录的意思是当你访问`market.lenkuntang.cn`这个地址的时候会重定向到`127.0.0.1`这个ip地址，从而实现本地调试的目的。\n\n##### mac系统\n\n打开一个finder，然后按快捷键command+shift+G，输入`private/etc/hosts`回车后就能找到对应的hosts文件，由于是权限问题，是无法直接在那个目录中修改hosts文件的，所以要把文件复制到桌面或者其它有修改权限的目录，然后打开后也是类似window一样在文件末尾添加一条记录`127.0.0.1 market.lenkuntang.cn`,保存后拖回原目录确定覆盖。\n\n另一种是使用腾讯云的开发者实验室的在线Web IDE来登录到测试服务器，然后直接在服务器上进行修改，线上验证。但是由于这个Web IDE目前不支持SSH密钥方式登录，只能用账号和密码的方式登录。所以也是有一定的局限性的。\n\n附上Web IDE工具地址：[https://cloud.tencent.com/developer/labs/gallery](https://cloud.tencent.com/developer/labs/gallery)\n\n点击其中一个教程，然后选择开始上机下方的*使用已有*云主机标签，在弹出的登录界面中正确填写你服务器的IP地址和账号密码便可直接登入服务器内进行相关操作。\n\n\n![登录界面](https://user-gold-cdn.xitu.io/2018/8/1/164f52d678022dc4?w=2550&h=1270&f=png&s=173339)\n\n* 登录界面\n\n![登录成功后的界面](https://user-gold-cdn.xitu.io/2018/8/1/164f52e11cd4a132?w=2556&h=1262&f=png&s=214551)\n\n* 登录成功后的界面\n\n### 使用微信开发者工具来本地调试\n\n当我们配置好了所有东西后，打开浏览器我们可以在控制台的输出中看到JsSDK的相关信息，但是我们却不知道是否可以正确分享，难道我们每次都要使用手机来访问本地服务来验证吗？而且在使用手机来访问本地服务的时候，使用的是本地电脑的ip地址，这样去拿到签名肯定是不对，会报`invalid url domain`错误，当然也可以改手机的`hosts`，但是这就不是那么容易改了，安卓的话要root，苹果的话...算了算了。还是换种方法，这个时候我们应该使用微信开发者工具来进行调试，微信开发者工具可以模拟微信环境，可以进行微信想着的操作，所以使用这个工具我们就可以愉快地在本地进行调试啦。\n\n而且，在遇到需要微信登录的页面时，如何是用普通的浏览器来打开就会跳到微信的授权登录页，而用开发者工具来打开则会像手机一样弹出授权页：\n\n![普通浏览器打开](https://user-gold-cdn.xitu.io/2018/8/1/164f519bbd68322e?w=334&h=583&f=png&s=11804)\n\n* 普通浏览器打开\n\n![微信开发者工具](https://user-gold-cdn.xitu.io/2018/8/1/164f51ebf2b165e6?w=380&h=698&f=png&s=30325)\n\n* 微信开发者工具\n\n### 总结\n\n通过这几天对微信分享的研究，总体对微信的JsSDK的使用有了大概的认识和了解，虽然其中也遇到不少的坑和麻烦的地方，但是既然问题出现就只能尽量地去简化问题再解决它。","source":"_posts/wechat-share-and-single-page-summary.md","raw":"layout: '[post]'\ntitle: 单页面应用微信分享跳坑指南\ntags:\n  - 个人总结\ncategories:\n  - 小程序\n  - ''\ndate: 2018-08-01 19:18:00\n---\n\n## 前言\n\n最近在开发的时候遇到了一个微信分享的bug，就是无论你在哪个路径下的页面，发送给朋友后点开都只会跳到项目的首页。本来微信分享这个只算是一个小功能，也很好解决，但由于项目的特殊性，使得在这个bug解决起来并没有那么顺手，所以记录一下备以后翻阅。\n\n## 坑点\n\n- Vue单页面应用，前端通过Hash控制路由——iOS在微信中不能正常地改变浏览器的hash值，分享出去的页面地址被莫名其妙地添加了参数。\n\n- 微信的安全策略——由于存在js安全域名限制，使得在本地调试更难。\n\n- jssdk配置签名。\n\n## 跳坑方法\n\n### 分享地址被奇怪的被带上了参数\n\n在传统开发中，路由通常都是在后端完成的，但是在Vue单页面中，都是通过控制history interface来控制页面之间的跳转，在我们的项目中我们使用hash的方式，但是在分享给朋友后却发现分享地址被加上了一些参数，比如：\n\n我分享出去的地址是：`market.lenkuntang.cn/#/home`，分享后会变成了`market.lenkuntang.cn/?from=singlemessage#/home`。这到底会不会影响到我们的分享操作呢？这就要了解vue-router的工作原理了，翻看了一下vue-router的源码，发现如下代码：\n\n```\n// this is delayed until the app mounts\n  // to avoid the hashchange listener being fired too early\n  setupListeners () {\n    const router = this.router\n    const expectScroll = router.options.scrollBehavior\n    const supportsScroll = supportsPushState && expectScroll\n\n    if (supportsScroll) {\n      setupScroll()\n    }\n\n    window.addEventListener(supportsPushState ? 'popstate' : 'hashchange', () => {\n      const current = this.current\n      if (!ensureSlash()) {\n        return\n      }\n      this.transitionTo(getHash(), route => {\n        if (supportsScroll) {\n          handleScroll(this.router, route, current, true)\n        }\n        if (!supportsPushState) {\n          replaceHash(route.fullPath)\n        }\n      })\n    })\n  }\n```\n\n[hash.js](https://user-gold-cdn.xitu.io/2018/8/1/164f36e016b35048)\n\n原来在vue-router初始化的时候，会监听`window`对象的`hashchange`属性，如想发现浏览器的`hash`值发生变化了，就会调用`History.transitionTo`方法，关键就在这个方法会传入一个`getHash`方法为作参数，如果在这种地址`market.lenkuntang.cn/?from=singlemessage#/home`也能正确地拿到正确的`hash`的话，那我们就可以断定这种意外对我们的分享是没有影响的。当我们继续去看`getHash`方法，在`hash.js`往下翻点会找到这个方法的实现：\n\n```\nexport function getHash (): string {\n  // We can't use window.location.hash here because it's not\n  // consistent across browsers - Firefox will pre-decode it!\n  const href = window.location.href\n  const index = href.indexOf('#')\n  return index === -1 ? '' : href.slice(index + 1)\n}\n```\n\n我们可以清楚地知道，当这条地址`market.lenkuntang.cn/?from=singlemessage#/home`经过`getHash`之后会直接返回`#`号后面的字符串，也就是\n`/home`，所以可以得出是不会对我们分享的功能有影响的。\n\n### iOS在微信环境中浏览器地址不变\n\n在Vue-router实现前端控制路由都是通过HTML5 新增的History Interface接口来控制页面之间的跳转的，在跳转的同时通过修改`window`中`loaction`的`hash`属性反映回浏览器的地址，但是当遇到iOS时却意外地发现这个`hash`属性一直没有被改变，导致每次分享出去的地址都是首页，在网上一查发现这原来是个通病，解决的方法就是引入微信的JsSDK来手动控制分享的地址。\n\n### 引入JsSDK所带来的问题\n\n在引入了JsSDK后，首先要对它进行配置，相关配置项如下：\n\n```\nwx.config({\n    debug: true, // 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。\n    appId: '', // 必填，公众号的唯一标识\n    timestamp: , // 必填，生成签名的时间戳\n    nonceStr: '', // 必填，生成签名的随机串\n    signature: '',// 必填，签名\n    jsApiList: [] // 必填，需要使用的JS接口列表\n});\n```\n\n说明一下这里的参数分别从哪里来，appId是从微信公众号里获取的，`timestamp`和`nonceStr`还有`signature`是从服务器中返回的。jsApiList可以在[所有JS接口列表](https://mp.weixin.qq.com/wiki?action=doc&id=mp1421141115&t=0.11471355121805527#63)中找到。\n\n> 注：`timestamp`和`nonceStr`其实是可以在前端生成然后传给服务器再参与签名的计算的，但一般在考虑到安全原因，`timestamp`, `nonceStr`这些参数应该从服务器返回回来（因为它参与了签名的计算）。\n\n> 注意：这里的传入的随机字符串字段`nonceStr`是**驼峰命名！！！**\n\n然后就是引入JsSDK中遇到最大的问题——签名问题，要正确地实现使用JsSDK，在服务器端首先要集齐这四种元素：\n- noncestr（随机字符串）\n- jsapi_ticket（通过微信接口获得的ticket）\n- timestamp（时间戳）\n- url（当前网页的URL，不包含#及其后面部分）\n\n然后把这些元素按字典序（ASCII 码从小到大排序）排后使用URL键值对的格式（即key1=value1&key2=value2…）拼接成字符串，再对字符串进行sha1加密，字段名和字段值都采用原始值，不进行URL 转义，即可得到所谓的签名。\n\n> 注意：这里的传入的随机字符串字段`noncestr`是**全小写！！！**\n\n最后附上签名检验工具的地址：[http://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=jsapisign](http://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=jsapisign)\n\n还有示例代码：[http://demo.open.weixin.qq.com/jssdk/sample.zip](http://demo.open.weixin.qq.com/jssdk/sample.zip)\n\n\n得到签名后再把`timestamp`，`nonceStr`和`signature`传回给前端进行JsSDK的初始化配置。\n\n### 再说计算签名的URL\n\n这里再说说参与签名的url，因为这里传过去的是当前见面的URL且不包括#及其后面部分，这对于使用Hash模式的单页面应用来说是个好消息，这样就代表我们只需要在页面加载时初始化一次后便可以在所有页面上使用（对于传统的路径导航，因为URL变了所以要重新初始化，也就是说要在使用到的JsSDK功能的页面中都要重新请求后台接口拿签名再初始化！！）。所以，一般来说我们通常会在`App.vue`这个文件中作JsSDK的初始化操作，当初始化正确后便可在其它页面上直接使用JsSDK接口的功能。\n\n次外，由于微信存在对JsSDK的使用限定在微信公众号里所设置的JS接口安全域名范围里，所以对于本地调度用的`localhost`域名来说是不可行的，直接提示`invalid url domain`，在这里有两种方式可以解决这个问题，一种是通过修改`host`的方法来实现本地调试，方法如下：\n\n#### window系统：\n\n进入系统盘目录（通常是C盘）： `C:\\Windows\\System32\\drivers\\etc`，找到`hosts`文件，打开后文件末尾添加一条记录`127.0.0.1 market.lenkuntang.cn`,这条记录的意思是当你访问`market.lenkuntang.cn`这个地址的时候会重定向到`127.0.0.1`这个ip地址，从而实现本地调试的目的。\n\n##### mac系统\n\n打开一个finder，然后按快捷键command+shift+G，输入`private/etc/hosts`回车后就能找到对应的hosts文件，由于是权限问题，是无法直接在那个目录中修改hosts文件的，所以要把文件复制到桌面或者其它有修改权限的目录，然后打开后也是类似window一样在文件末尾添加一条记录`127.0.0.1 market.lenkuntang.cn`,保存后拖回原目录确定覆盖。\n\n另一种是使用腾讯云的开发者实验室的在线Web IDE来登录到测试服务器，然后直接在服务器上进行修改，线上验证。但是由于这个Web IDE目前不支持SSH密钥方式登录，只能用账号和密码的方式登录。所以也是有一定的局限性的。\n\n附上Web IDE工具地址：[https://cloud.tencent.com/developer/labs/gallery](https://cloud.tencent.com/developer/labs/gallery)\n\n点击其中一个教程，然后选择开始上机下方的*使用已有*云主机标签，在弹出的登录界面中正确填写你服务器的IP地址和账号密码便可直接登入服务器内进行相关操作。\n\n\n![登录界面](https://user-gold-cdn.xitu.io/2018/8/1/164f52d678022dc4?w=2550&h=1270&f=png&s=173339)\n\n* 登录界面\n\n![登录成功后的界面](https://user-gold-cdn.xitu.io/2018/8/1/164f52e11cd4a132?w=2556&h=1262&f=png&s=214551)\n\n* 登录成功后的界面\n\n### 使用微信开发者工具来本地调试\n\n当我们配置好了所有东西后，打开浏览器我们可以在控制台的输出中看到JsSDK的相关信息，但是我们却不知道是否可以正确分享，难道我们每次都要使用手机来访问本地服务来验证吗？而且在使用手机来访问本地服务的时候，使用的是本地电脑的ip地址，这样去拿到签名肯定是不对，会报`invalid url domain`错误，当然也可以改手机的`hosts`，但是这就不是那么容易改了，安卓的话要root，苹果的话...算了算了。还是换种方法，这个时候我们应该使用微信开发者工具来进行调试，微信开发者工具可以模拟微信环境，可以进行微信想着的操作，所以使用这个工具我们就可以愉快地在本地进行调试啦。\n\n而且，在遇到需要微信登录的页面时，如何是用普通的浏览器来打开就会跳到微信的授权登录页，而用开发者工具来打开则会像手机一样弹出授权页：\n\n![普通浏览器打开](https://user-gold-cdn.xitu.io/2018/8/1/164f519bbd68322e?w=334&h=583&f=png&s=11804)\n\n* 普通浏览器打开\n\n![微信开发者工具](https://user-gold-cdn.xitu.io/2018/8/1/164f51ebf2b165e6?w=380&h=698&f=png&s=30325)\n\n* 微信开发者工具\n\n### 总结\n\n通过这几天对微信分享的研究，总体对微信的JsSDK的使用有了大概的认识和了解，虽然其中也遇到不少的坑和麻烦的地方，但是既然问题出现就只能尽量地去简化问题再解决它。","slug":"wechat-share-and-single-page-summary","published":1,"updated":"2023-04-11T03:30:27.142Z","comments":1,"photos":[],"link":"","_id":"clgbppebi001ybvch5kkce2n8","content":"<h2><a href=\"#qian-yan\" class=\"header-anchor\"></a><span id=\"qian-yan\">前言</span></h2><p>最近在开发的时候遇到了一个微信分享的bug，就是无论你在哪个路径下的页面，发送给朋友后点开都只会跳到项目的首页。本来微信分享这个只算是一个小功能，也很好解决，但由于项目的特殊性，使得在这个bug解决起来并没有那么顺手，所以记录一下备以后翻阅。</p>\n<h2><a href=\"#keng-dian\" class=\"header-anchor\"></a><span id=\"keng-dian\">坑点</span></h2><ul>\n<li><p>Vue单页面应用，前端通过Hash控制路由——iOS在微信中不能正常地改变浏览器的hash值，分享出去的页面地址被莫名其妙地添加了参数。</p>\n</li>\n<li><p>微信的安全策略——由于存在js安全域名限制，使得在本地调试更难。</p>\n</li>\n<li><p>jssdk配置签名。</p>\n</li>\n</ul>\n<h2><a href=\"#tiao-keng-fang-fa\" class=\"header-anchor\"></a><span id=\"tiao-keng-fang-fa\">跳坑方法</span></h2><h3><a href=\"#fen-xiang-di-zhi-bei-qi-guai-de-bei-dai-shang-liao-can-shu\" class=\"header-anchor\"></a><span id=\"fen-xiang-di-zhi-bei-qi-guai-de-bei-dai-shang-liao-can-shu\">分享地址被奇怪的被带上了参数</span></h3><p>在传统开发中，路由通常都是在后端完成的，但是在Vue单页面中，都是通过控制history interface来控制页面之间的跳转，在我们的项目中我们使用hash的方式，但是在分享给朋友后却发现分享地址被加上了一些参数，比如：</p>\n<p>我分享出去的地址是：<code>market.lenkuntang.cn/#/home</code>，分享后会变成了<code>market.lenkuntang.cn/?from=singlemessage#/home</code>。这到底会不会影响到我们的分享操作呢？这就要了解vue-router的工作原理了，翻看了一下vue-router的源码，发现如下代码：</p>\n<pre><code>// this is delayed until the app mounts\n  // to avoid the hashchange listener being fired too early\n  setupListeners () &#123;\n    const router = this.router\n    const expectScroll = router.options.scrollBehavior\n    const supportsScroll = supportsPushState &amp;&amp; expectScroll\n\n    if (supportsScroll) &#123;\n      setupScroll()\n    &#125;\n\n    window.addEventListener(supportsPushState ? &#39;popstate&#39; : &#39;hashchange&#39;, () =&gt; &#123;\n      const current = this.current\n      if (!ensureSlash()) &#123;\n        return\n      &#125;\n      this.transitionTo(getHash(), route =&gt; &#123;\n        if (supportsScroll) &#123;\n          handleScroll(this.router, route, current, true)\n        &#125;\n        if (!supportsPushState) &#123;\n          replaceHash(route.fullPath)\n        &#125;\n      &#125;)\n    &#125;)\n  &#125;\n</code></pre>\n<p><a href=\"https://user-gold-cdn.xitu.io/2018/8/1/164f36e016b35048\">hash.js</a></p>\n<p>原来在vue-router初始化的时候，会监听<code>window</code>对象的<code>hashchange</code>属性，如想发现浏览器的<code>hash</code>值发生变化了，就会调用<code>History.transitionTo</code>方法，关键就在这个方法会传入一个<code>getHash</code>方法为作参数，如果在这种地址<code>market.lenkuntang.cn/?from=singlemessage#/home</code>也能正确地拿到正确的<code>hash</code>的话，那我们就可以断定这种意外对我们的分享是没有影响的。当我们继续去看<code>getHash</code>方法，在<code>hash.js</code>往下翻点会找到这个方法的实现：</p>\n<pre><code>export function getHash (): string &#123;\n  // We can&#39;t use window.location.hash here because it&#39;s not\n  // consistent across browsers - Firefox will pre-decode it!\n  const href = window.location.href\n  const index = href.indexOf(&#39;#&#39;)\n  return index === -1 ? &#39;&#39; : href.slice(index + 1)\n&#125;\n</code></pre>\n<p>我们可以清楚地知道，当这条地址<code>market.lenkuntang.cn/?from=singlemessage#/home</code>经过<code>getHash</code>之后会直接返回<code>#</code>号后面的字符串，也就是<br><code>/home</code>，所以可以得出是不会对我们分享的功能有影响的。</p>\n<h3><a href=\"#ios-zai-wei-xin-huan-jing-zhong-liu-lan-qi-di-zhi-bu-bian\" class=\"header-anchor\"></a><span id=\"ios-zai-wei-xin-huan-jing-zhong-liu-lan-qi-di-zhi-bu-bian\">iOS在微信环境中浏览器地址不变</span></h3><p>在Vue-router实现前端控制路由都是通过HTML5 新增的History Interface接口来控制页面之间的跳转的，在跳转的同时通过修改<code>window</code>中<code>loaction</code>的<code>hash</code>属性反映回浏览器的地址，但是当遇到iOS时却意外地发现这个<code>hash</code>属性一直没有被改变，导致每次分享出去的地址都是首页，在网上一查发现这原来是个通病，解决的方法就是引入微信的JsSDK来手动控制分享的地址。</p>\n<h3><a href=\"#yin-ru-jssdk-suo-dai-lai-de-wen-ti\" class=\"header-anchor\"></a><span id=\"yin-ru-jssdk-suo-dai-lai-de-wen-ti\">引入JsSDK所带来的问题</span></h3><p>在引入了JsSDK后，首先要对它进行配置，相关配置项如下：</p>\n<pre><code>wx.config(&#123;\n    debug: true, // 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。\n    appId: &#39;&#39;, // 必填，公众号的唯一标识\n    timestamp: , // 必填，生成签名的时间戳\n    nonceStr: &#39;&#39;, // 必填，生成签名的随机串\n    signature: &#39;&#39;,// 必填，签名\n    jsApiList: [] // 必填，需要使用的JS接口列表\n&#125;);\n</code></pre>\n<p>说明一下这里的参数分别从哪里来，appId是从微信公众号里获取的，<code>timestamp</code>和<code>nonceStr</code>还有<code>signature</code>是从服务器中返回的。jsApiList可以在<a href=\"https://mp.weixin.qq.com/wiki?action=doc&id=mp1421141115&t=0.11471355121805527#63\">所有JS接口列表</a>中找到。</p>\n<blockquote>\n<p>注：<code>timestamp</code>和<code>nonceStr</code>其实是可以在前端生成然后传给服务器再参与签名的计算的，但一般在考虑到安全原因，<code>timestamp</code>, <code>nonceStr</code>这些参数应该从服务器返回回来（因为它参与了签名的计算）。</p>\n</blockquote>\n<blockquote>\n<p>注意：这里的传入的随机字符串字段<code>nonceStr</code>是<strong>驼峰命名！！！</strong></p>\n</blockquote>\n<p>然后就是引入JsSDK中遇到最大的问题——签名问题，要正确地实现使用JsSDK，在服务器端首先要集齐这四种元素：</p>\n<ul>\n<li>noncestr（随机字符串）</li>\n<li>jsapi_ticket（通过微信接口获得的ticket）</li>\n<li>timestamp（时间戳）</li>\n<li>url（当前网页的URL，不包含#及其后面部分）</li>\n</ul>\n<p>然后把这些元素按字典序（ASCII 码从小到大排序）排后使用URL键值对的格式（即key1&#x3D;value1&amp;key2&#x3D;value2…）拼接成字符串，再对字符串进行sha1加密，字段名和字段值都采用原始值，不进行URL 转义，即可得到所谓的签名。</p>\n<blockquote>\n<p>注意：这里的传入的随机字符串字段<code>noncestr</code>是<strong>全小写！！！</strong></p>\n</blockquote>\n<p>最后附上签名检验工具的地址：<a href=\"http://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=jsapisign\">http://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=jsapisign</a></p>\n<p>还有示例代码：<a href=\"http://demo.open.weixin.qq.com/jssdk/sample.zip\">http://demo.open.weixin.qq.com/jssdk/sample.zip</a></p>\n<p>得到签名后再把<code>timestamp</code>，<code>nonceStr</code>和<code>signature</code>传回给前端进行JsSDK的初始化配置。</p>\n<h3><a href=\"#zai-shuo-ji-suan-qian-ming-de-url\" class=\"header-anchor\"></a><span id=\"zai-shuo-ji-suan-qian-ming-de-url\">再说计算签名的URL</span></h3><p>这里再说说参与签名的url，因为这里传过去的是当前见面的URL且不包括#及其后面部分，这对于使用Hash模式的单页面应用来说是个好消息，这样就代表我们只需要在页面加载时初始化一次后便可以在所有页面上使用（对于传统的路径导航，因为URL变了所以要重新初始化，也就是说要在使用到的JsSDK功能的页面中都要重新请求后台接口拿签名再初始化！！）。所以，一般来说我们通常会在<code>App.vue</code>这个文件中作JsSDK的初始化操作，当初始化正确后便可在其它页面上直接使用JsSDK接口的功能。</p>\n<p>次外，由于微信存在对JsSDK的使用限定在微信公众号里所设置的JS接口安全域名范围里，所以对于本地调度用的<code>localhost</code>域名来说是不可行的，直接提示<code>invalid url domain</code>，在这里有两种方式可以解决这个问题，一种是通过修改<code>host</code>的方法来实现本地调试，方法如下：</p>\n<h4><a href=\"#window-xi-tong\" class=\"header-anchor\"></a><span id=\"window-xi-tong\">window系统：</span></h4><p>进入系统盘目录（通常是C盘）： <code>C:\\Windows\\System32\\drivers\\etc</code>，找到<code>hosts</code>文件，打开后文件末尾添加一条记录<code>127.0.0.1 market.lenkuntang.cn</code>,这条记录的意思是当你访问<code>market.lenkuntang.cn</code>这个地址的时候会重定向到<code>127.0.0.1</code>这个ip地址，从而实现本地调试的目的。</p>\n<h5><a href=\"#mac-xi-tong\" class=\"header-anchor\"></a><span id=\"mac-xi-tong\">mac系统</span></h5><p>打开一个finder，然后按快捷键command+shift+G，输入<code>private/etc/hosts</code>回车后就能找到对应的hosts文件，由于是权限问题，是无法直接在那个目录中修改hosts文件的，所以要把文件复制到桌面或者其它有修改权限的目录，然后打开后也是类似window一样在文件末尾添加一条记录<code>127.0.0.1 market.lenkuntang.cn</code>,保存后拖回原目录确定覆盖。</p>\n<p>另一种是使用腾讯云的开发者实验室的在线Web IDE来登录到测试服务器，然后直接在服务器上进行修改，线上验证。但是由于这个Web IDE目前不支持SSH密钥方式登录，只能用账号和密码的方式登录。所以也是有一定的局限性的。</p>\n<p>附上Web IDE工具地址：<a href=\"https://cloud.tencent.com/developer/labs/gallery\">https://cloud.tencent.com/developer/labs/gallery</a></p>\n<p>点击其中一个教程，然后选择开始上机下方的<em>使用已有</em>云主机标签，在弹出的登录界面中正确填写你服务器的IP地址和账号密码便可直接登入服务器内进行相关操作。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/8/1/164f52d678022dc4?w=2550&h=1270&f=png&s=173339\" alt=\"登录界面\"></p>\n<ul>\n<li>登录界面</li>\n</ul>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/8/1/164f52e11cd4a132?w=2556&h=1262&f=png&s=214551\" alt=\"登录成功后的界面\"></p>\n<ul>\n<li>登录成功后的界面</li>\n</ul>\n<h3><a href=\"#shi-yong-wei-xin-kai-fa-zhe-gong-ju-lai-ben-di-diao-shi\" class=\"header-anchor\"></a><span id=\"shi-yong-wei-xin-kai-fa-zhe-gong-ju-lai-ben-di-diao-shi\">使用微信开发者工具来本地调试</span></h3><p>当我们配置好了所有东西后，打开浏览器我们可以在控制台的输出中看到JsSDK的相关信息，但是我们却不知道是否可以正确分享，难道我们每次都要使用手机来访问本地服务来验证吗？而且在使用手机来访问本地服务的时候，使用的是本地电脑的ip地址，这样去拿到签名肯定是不对，会报<code>invalid url domain</code>错误，当然也可以改手机的<code>hosts</code>，但是这就不是那么容易改了，安卓的话要root，苹果的话…算了算了。还是换种方法，这个时候我们应该使用微信开发者工具来进行调试，微信开发者工具可以模拟微信环境，可以进行微信想着的操作，所以使用这个工具我们就可以愉快地在本地进行调试啦。</p>\n<p>而且，在遇到需要微信登录的页面时，如何是用普通的浏览器来打开就会跳到微信的授权登录页，而用开发者工具来打开则会像手机一样弹出授权页：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/8/1/164f519bbd68322e?w=334&h=583&f=png&s=11804\" alt=\"普通浏览器打开\"></p>\n<ul>\n<li>普通浏览器打开</li>\n</ul>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/8/1/164f51ebf2b165e6?w=380&h=698&f=png&s=30325\" alt=\"微信开发者工具\"></p>\n<ul>\n<li>微信开发者工具</li>\n</ul>\n<h3><a href=\"#zong-jie\" class=\"header-anchor\"></a><span id=\"zong-jie\">总结</span></h3><p>通过这几天对微信分享的研究，总体对微信的JsSDK的使用有了大概的认识和了解，虽然其中也遇到不少的坑和麻烦的地方，但是既然问题出现就只能尽量地去简化问题再解决它。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>最近在开发的时候遇到了一个微信分享的bug，就是无论你在哪个路径下的页面，发送给朋友后点开都只会跳到项目的首页。本来微信分享这个只算是一个小功能，也很好解决，但由于项目的特殊性，使得在这个bug解决起来并没有那么顺手，所以记录一下备以后翻阅。</p>\n<h2 id=\"坑点\"><a href=\"#坑点\" class=\"headerlink\" title=\"坑点\"></a>坑点</h2><ul>\n<li><p>Vue单页面应用，前端通过Hash控制路由——iOS在微信中不能正常地改变浏览器的hash值，分享出去的页面地址被莫名其妙地添加了参数。</p>\n</li>\n<li><p>微信的安全策略——由于存在js安全域名限制，使得在本地调试更难。</p>\n</li>\n<li><p>jssdk配置签名。</p>\n</li>\n</ul>\n<h2 id=\"跳坑方法\"><a href=\"#跳坑方法\" class=\"headerlink\" title=\"跳坑方法\"></a>跳坑方法</h2><h3 id=\"分享地址被奇怪的被带上了参数\"><a href=\"#分享地址被奇怪的被带上了参数\" class=\"headerlink\" title=\"分享地址被奇怪的被带上了参数\"></a>分享地址被奇怪的被带上了参数</h3><p>在传统开发中，路由通常都是在后端完成的，但是在Vue单页面中，都是通过控制history interface来控制页面之间的跳转，在我们的项目中我们使用hash的方式，但是在分享给朋友后却发现分享地址被加上了一些参数，比如：</p>\n<p>我分享出去的地址是：<code>market.lenkuntang.cn/#/home</code>，分享后会变成了<code>market.lenkuntang.cn/?from=singlemessage#/home</code>。这到底会不会影响到我们的分享操作呢？这就要了解vue-router的工作原理了，翻看了一下vue-router的源码，发现如下代码：</p>\n<pre><code>// this is delayed until the app mounts\n  // to avoid the hashchange listener being fired too early\n  setupListeners () &#123;\n    const router = this.router\n    const expectScroll = router.options.scrollBehavior\n    const supportsScroll = supportsPushState &amp;&amp; expectScroll\n\n    if (supportsScroll) &#123;\n      setupScroll()\n    &#125;\n\n    window.addEventListener(supportsPushState ? &#39;popstate&#39; : &#39;hashchange&#39;, () =&gt; &#123;\n      const current = this.current\n      if (!ensureSlash()) &#123;\n        return\n      &#125;\n      this.transitionTo(getHash(), route =&gt; &#123;\n        if (supportsScroll) &#123;\n          handleScroll(this.router, route, current, true)\n        &#125;\n        if (!supportsPushState) &#123;\n          replaceHash(route.fullPath)\n        &#125;\n      &#125;)\n    &#125;)\n  &#125;\n</code></pre>\n<p><a href=\"https://user-gold-cdn.xitu.io/2018/8/1/164f36e016b35048\">hash.js</a></p>\n<p>原来在vue-router初始化的时候，会监听<code>window</code>对象的<code>hashchange</code>属性，如想发现浏览器的<code>hash</code>值发生变化了，就会调用<code>History.transitionTo</code>方法，关键就在这个方法会传入一个<code>getHash</code>方法为作参数，如果在这种地址<code>market.lenkuntang.cn/?from=singlemessage#/home</code>也能正确地拿到正确的<code>hash</code>的话，那我们就可以断定这种意外对我们的分享是没有影响的。当我们继续去看<code>getHash</code>方法，在<code>hash.js</code>往下翻点会找到这个方法的实现：</p>\n<pre><code>export function getHash (): string &#123;\n  // We can&#39;t use window.location.hash here because it&#39;s not\n  // consistent across browsers - Firefox will pre-decode it!\n  const href = window.location.href\n  const index = href.indexOf(&#39;#&#39;)\n  return index === -1 ? &#39;&#39; : href.slice(index + 1)\n&#125;\n</code></pre>\n<p>我们可以清楚地知道，当这条地址<code>market.lenkuntang.cn/?from=singlemessage#/home</code>经过<code>getHash</code>之后会直接返回<code>#</code>号后面的字符串，也就是<br><code>/home</code>，所以可以得出是不会对我们分享的功能有影响的。</p>\n<h3 id=\"iOS在微信环境中浏览器地址不变\"><a href=\"#iOS在微信环境中浏览器地址不变\" class=\"headerlink\" title=\"iOS在微信环境中浏览器地址不变\"></a>iOS在微信环境中浏览器地址不变</h3><p>在Vue-router实现前端控制路由都是通过HTML5 新增的History Interface接口来控制页面之间的跳转的，在跳转的同时通过修改<code>window</code>中<code>loaction</code>的<code>hash</code>属性反映回浏览器的地址，但是当遇到iOS时却意外地发现这个<code>hash</code>属性一直没有被改变，导致每次分享出去的地址都是首页，在网上一查发现这原来是个通病，解决的方法就是引入微信的JsSDK来手动控制分享的地址。</p>\n<h3 id=\"引入JsSDK所带来的问题\"><a href=\"#引入JsSDK所带来的问题\" class=\"headerlink\" title=\"引入JsSDK所带来的问题\"></a>引入JsSDK所带来的问题</h3><p>在引入了JsSDK后，首先要对它进行配置，相关配置项如下：</p>\n<pre><code>wx.config(&#123;\n    debug: true, // 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。\n    appId: &#39;&#39;, // 必填，公众号的唯一标识\n    timestamp: , // 必填，生成签名的时间戳\n    nonceStr: &#39;&#39;, // 必填，生成签名的随机串\n    signature: &#39;&#39;,// 必填，签名\n    jsApiList: [] // 必填，需要使用的JS接口列表\n&#125;);\n</code></pre>\n<p>说明一下这里的参数分别从哪里来，appId是从微信公众号里获取的，<code>timestamp</code>和<code>nonceStr</code>还有<code>signature</code>是从服务器中返回的。jsApiList可以在<a href=\"https://mp.weixin.qq.com/wiki?action=doc&id=mp1421141115&t=0.11471355121805527#63\">所有JS接口列表</a>中找到。</p>\n<blockquote>\n<p>注：<code>timestamp</code>和<code>nonceStr</code>其实是可以在前端生成然后传给服务器再参与签名的计算的，但一般在考虑到安全原因，<code>timestamp</code>, <code>nonceStr</code>这些参数应该从服务器返回回来（因为它参与了签名的计算）。</p>\n</blockquote>\n<blockquote>\n<p>注意：这里的传入的随机字符串字段<code>nonceStr</code>是<strong>驼峰命名！！！</strong></p>\n</blockquote>\n<p>然后就是引入JsSDK中遇到最大的问题——签名问题，要正确地实现使用JsSDK，在服务器端首先要集齐这四种元素：</p>\n<ul>\n<li>noncestr（随机字符串）</li>\n<li>jsapi_ticket（通过微信接口获得的ticket）</li>\n<li>timestamp（时间戳）</li>\n<li>url（当前网页的URL，不包含#及其后面部分）</li>\n</ul>\n<p>然后把这些元素按字典序（ASCII 码从小到大排序）排后使用URL键值对的格式（即key1&#x3D;value1&amp;key2&#x3D;value2…）拼接成字符串，再对字符串进行sha1加密，字段名和字段值都采用原始值，不进行URL 转义，即可得到所谓的签名。</p>\n<blockquote>\n<p>注意：这里的传入的随机字符串字段<code>noncestr</code>是<strong>全小写！！！</strong></p>\n</blockquote>\n<p>最后附上签名检验工具的地址：<a href=\"http://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=jsapisign\">http://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=jsapisign</a></p>\n<p>还有示例代码：<a href=\"http://demo.open.weixin.qq.com/jssdk/sample.zip\">http://demo.open.weixin.qq.com/jssdk/sample.zip</a></p>\n<p>得到签名后再把<code>timestamp</code>，<code>nonceStr</code>和<code>signature</code>传回给前端进行JsSDK的初始化配置。</p>\n<h3 id=\"再说计算签名的URL\"><a href=\"#再说计算签名的URL\" class=\"headerlink\" title=\"再说计算签名的URL\"></a>再说计算签名的URL</h3><p>这里再说说参与签名的url，因为这里传过去的是当前见面的URL且不包括#及其后面部分，这对于使用Hash模式的单页面应用来说是个好消息，这样就代表我们只需要在页面加载时初始化一次后便可以在所有页面上使用（对于传统的路径导航，因为URL变了所以要重新初始化，也就是说要在使用到的JsSDK功能的页面中都要重新请求后台接口拿签名再初始化！！）。所以，一般来说我们通常会在<code>App.vue</code>这个文件中作JsSDK的初始化操作，当初始化正确后便可在其它页面上直接使用JsSDK接口的功能。</p>\n<p>次外，由于微信存在对JsSDK的使用限定在微信公众号里所设置的JS接口安全域名范围里，所以对于本地调度用的<code>localhost</code>域名来说是不可行的，直接提示<code>invalid url domain</code>，在这里有两种方式可以解决这个问题，一种是通过修改<code>host</code>的方法来实现本地调试，方法如下：</p>\n<h4 id=\"window系统：\"><a href=\"#window系统：\" class=\"headerlink\" title=\"window系统：\"></a>window系统：</h4><p>进入系统盘目录（通常是C盘）： <code>C:\\Windows\\System32\\drivers\\etc</code>，找到<code>hosts</code>文件，打开后文件末尾添加一条记录<code>127.0.0.1 market.lenkuntang.cn</code>,这条记录的意思是当你访问<code>market.lenkuntang.cn</code>这个地址的时候会重定向到<code>127.0.0.1</code>这个ip地址，从而实现本地调试的目的。</p>\n<h5 id=\"mac系统\"><a href=\"#mac系统\" class=\"headerlink\" title=\"mac系统\"></a>mac系统</h5><p>打开一个finder，然后按快捷键command+shift+G，输入<code>private/etc/hosts</code>回车后就能找到对应的hosts文件，由于是权限问题，是无法直接在那个目录中修改hosts文件的，所以要把文件复制到桌面或者其它有修改权限的目录，然后打开后也是类似window一样在文件末尾添加一条记录<code>127.0.0.1 market.lenkuntang.cn</code>,保存后拖回原目录确定覆盖。</p>\n<p>另一种是使用腾讯云的开发者实验室的在线Web IDE来登录到测试服务器，然后直接在服务器上进行修改，线上验证。但是由于这个Web IDE目前不支持SSH密钥方式登录，只能用账号和密码的方式登录。所以也是有一定的局限性的。</p>\n<p>附上Web IDE工具地址：<a href=\"https://cloud.tencent.com/developer/labs/gallery\">https://cloud.tencent.com/developer/labs/gallery</a></p>\n<p>点击其中一个教程，然后选择开始上机下方的<em>使用已有</em>云主机标签，在弹出的登录界面中正确填写你服务器的IP地址和账号密码便可直接登入服务器内进行相关操作。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/8/1/164f52d678022dc4?w=2550&h=1270&f=png&s=173339\" alt=\"登录界面\"></p>\n<ul>\n<li>登录界面</li>\n</ul>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/8/1/164f52e11cd4a132?w=2556&h=1262&f=png&s=214551\" alt=\"登录成功后的界面\"></p>\n<ul>\n<li>登录成功后的界面</li>\n</ul>\n<h3 id=\"使用微信开发者工具来本地调试\"><a href=\"#使用微信开发者工具来本地调试\" class=\"headerlink\" title=\"使用微信开发者工具来本地调试\"></a>使用微信开发者工具来本地调试</h3><p>当我们配置好了所有东西后，打开浏览器我们可以在控制台的输出中看到JsSDK的相关信息，但是我们却不知道是否可以正确分享，难道我们每次都要使用手机来访问本地服务来验证吗？而且在使用手机来访问本地服务的时候，使用的是本地电脑的ip地址，这样去拿到签名肯定是不对，会报<code>invalid url domain</code>错误，当然也可以改手机的<code>hosts</code>，但是这就不是那么容易改了，安卓的话要root，苹果的话…算了算了。还是换种方法，这个时候我们应该使用微信开发者工具来进行调试，微信开发者工具可以模拟微信环境，可以进行微信想着的操作，所以使用这个工具我们就可以愉快地在本地进行调试啦。</p>\n<p>而且，在遇到需要微信登录的页面时，如何是用普通的浏览器来打开就会跳到微信的授权登录页，而用开发者工具来打开则会像手机一样弹出授权页：</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/8/1/164f519bbd68322e?w=334&h=583&f=png&s=11804\" alt=\"普通浏览器打开\"></p>\n<ul>\n<li>普通浏览器打开</li>\n</ul>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/8/1/164f51ebf2b165e6?w=380&h=698&f=png&s=30325\" alt=\"微信开发者工具\"></p>\n<ul>\n<li>微信开发者工具</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>通过这几天对微信分享的研究，总体对微信的JsSDK的使用有了大概的认识和了解，虽然其中也遇到不少的坑和麻烦的地方，但是既然问题出现就只能尽量地去简化问题再解决它。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"clgbppeb10001bvchhjlx7uhv","category_id":"clgbppeb30004bvchb0d121wq","_id":"clgbppeb9000ibvchgogr6dzo"},{"post_id":"clgbppeb30003bvchfpwjchwf","category_id":"clgbppeb30004bvchb0d121wq","_id":"clgbppeba000obvch4tn40qhk"},{"post_id":"clgbppeb50007bvch2hcz1hve","category_id":"clgbppeb8000hbvchfcsoflcu","_id":"clgbppebc000vbvchbhuve6yw"},{"post_id":"clgbppeb60009bvch05742uss","category_id":"clgbppeba000qbvchb56h6stl","_id":"clgbppebd0014bvch39q55isx"},{"post_id":"clgbppeb6000abvch5yu5c9rh","category_id":"clgbppeba000qbvchb56h6stl","_id":"clgbppebf001abvchbu45akfs"},{"post_id":"clgbppeb7000ebvchbig1bvaw","category_id":"clgbppebd0013bvche7eu11jm","_id":"clgbppebg001gbvchggca6y51"},{"post_id":"clgbppeb8000gbvch8btybupi","category_id":"clgbppebf001bbvch7miggylh","_id":"clgbppebh001obvch32xs2ib2"},{"post_id":"clgbppeb9000lbvche3r61ye7","category_id":"clgbppebg001ibvch21vhax8c","_id":"clgbppebi001wbvchhlja2hi9"},{"post_id":"clgbppebh001rbvch3uwq2jnq","category_id":"clgbppeb30004bvchb0d121wq","_id":"clgbppebj0021bvchb0r81p5h"},{"post_id":"clgbppeba000nbvch2vvr3b9n","category_id":"clgbppebg001ibvch21vhax8c","_id":"clgbppebj0024bvch247wg544"},{"post_id":"clgbppebb000sbvcheqx8b03q","category_id":"clgbppebd0013bvche7eu11jm","_id":"clgbppebj0028bvch4bhobmlf"},{"post_id":"clgbppebb000ubvch42h8a5tp","category_id":"clgbppebg001ibvch21vhax8c","_id":"clgbppebj002bbvchffa770o7"},{"post_id":"clgbppebc000zbvchfvi99rqy","category_id":"clgbppebj0027bvchf2m21lyf","_id":"clgbppebk002hbvch5khq7qsv"},{"post_id":"clgbppebc0011bvchhe6jgcso","category_id":"clgbppebj0027bvchf2m21lyf","_id":"clgbppebk002mbvch7kg0ex1h"},{"post_id":"clgbppebd0016bvchgw0fcoyz","category_id":"clgbppebj0027bvchf2m21lyf","_id":"clgbppebl002nbvchhld6f2wf"},{"post_id":"clgbppebf001cbvchf47g7x0l","category_id":"clgbppebk002lbvch7lo1b13r","_id":"clgbppebl002sbvchbswo4c60"},{"post_id":"clgbppebf001ebvcheu7z45wh","category_id":"clgbppebk002lbvch7lo1b13r","_id":"clgbppebl002tbvchc2qt23df"},{"post_id":"clgbppebg001kbvch4z6b7q2k","category_id":"clgbppebl002rbvch2b172l0n","_id":"clgbppebm002wbvchevfn6wg1"},{"post_id":"clgbppebg001nbvch90yf8txr","category_id":"clgbppebj0027bvchf2m21lyf","_id":"clgbppebm002xbvchdscg41fb"},{"post_id":"clgbppebi001ybvch5kkce2n8","category_id":"clgbppebm002vbvch7fj9ejkl","_id":"clgbppebm002ybvchecs69gng"}],"PostTag":[{"post_id":"clgbppeb60009bvch05742uss","tag_id":"clgbppeb40005bvch8vkd47ev","_id":"clgbppeb7000dbvch37vhaih6"},{"post_id":"clgbppeb10001bvchhjlx7uhv","tag_id":"clgbppeb40005bvch8vkd47ev","_id":"clgbppeb8000fbvch7flmd8p0"},{"post_id":"clgbppeb6000abvch5yu5c9rh","tag_id":"clgbppeb40005bvch8vkd47ev","_id":"clgbppeb9000kbvch0zv426jp"},{"post_id":"clgbppeb30003bvchfpwjchwf","tag_id":"clgbppeb40005bvch8vkd47ev","_id":"clgbppeb9000mbvch9sepgbjp"},{"post_id":"clgbppeb8000gbvch8btybupi","tag_id":"clgbppeb40005bvch8vkd47ev","_id":"clgbppebb000rbvcha5j90pje"},{"post_id":"clgbppeb50007bvch2hcz1hve","tag_id":"clgbppeb40005bvch8vkd47ev","_id":"clgbppebb000tbvch592j32t3"},{"post_id":"clgbppebb000sbvcheqx8b03q","tag_id":"clgbppeba000pbvch86428e99","_id":"clgbppebc000ybvch1zvyhr9x"},{"post_id":"clgbppeb7000ebvchbig1bvaw","tag_id":"clgbppeba000pbvch86428e99","_id":"clgbppebc0010bvch810v7cpl"},{"post_id":"clgbppebb000ubvch42h8a5tp","tag_id":"clgbppeba000pbvch86428e99","_id":"clgbppebd0015bvchg3nbhxwk"},{"post_id":"clgbppeb9000lbvche3r61ye7","tag_id":"clgbppeba000pbvch86428e99","_id":"clgbppebd0017bvch1kjk0viq"},{"post_id":"clgbppeba000nbvch2vvr3b9n","tag_id":"clgbppeba000pbvch86428e99","_id":"clgbppebf001dbvchdzgq13y8"},{"post_id":"clgbppebc000zbvchfvi99rqy","tag_id":"clgbppebf0019bvch0mo7aoxu","_id":"clgbppebg001jbvch9wcf8p0y"},{"post_id":"clgbppebf001ebvcheu7z45wh","tag_id":"clgbppeb40005bvch8vkd47ev","_id":"clgbppebg001lbvchajif0ozv"},{"post_id":"clgbppebc0011bvchhe6jgcso","tag_id":"clgbppebf0019bvch0mo7aoxu","_id":"clgbppebh001qbvchefys687x"},{"post_id":"clgbppebg001kbvch4z6b7q2k","tag_id":"clgbppeba000pbvch86428e99","_id":"clgbppebh001sbvch5jbb8p2y"},{"post_id":"clgbppebg001nbvch90yf8txr","tag_id":"clgbppeb40005bvch8vkd47ev","_id":"clgbppebi001xbvchefhucitv"},{"post_id":"clgbppebd0016bvchgw0fcoyz","tag_id":"clgbppebf0019bvch0mo7aoxu","_id":"clgbppebi001zbvcheaem5e8n"},{"post_id":"clgbppebd0018bvch12ng2v9i","tag_id":"clgbppebf0019bvch0mo7aoxu","_id":"clgbppebj0023bvchcvbx5nt0"},{"post_id":"clgbppebi001ybvch5kkce2n8","tag_id":"clgbppeb40005bvch8vkd47ev","_id":"clgbppebj0025bvch44nrgxzx"},{"post_id":"clgbppebf001cbvchf47g7x0l","tag_id":"clgbppebj0020bvch34662yci","_id":"clgbppebj0029bvch1g6l4wwu"},{"post_id":"clgbppebg001hbvch5qrx6rp1","tag_id":"clgbppebj0026bvch4e7mes3c","_id":"clgbppebj002dbvch89yt9xeb"},{"post_id":"clgbppebg001hbvch5qrx6rp1","tag_id":"clgbppeba000pbvch86428e99","_id":"clgbppebj002ebvch42szcl9q"},{"post_id":"clgbppebh001rbvch3uwq2jnq","tag_id":"clgbppebj0026bvch4e7mes3c","_id":"clgbppebk002ibvch02l3dowk"},{"post_id":"clgbppebh001rbvch3uwq2jnq","tag_id":"clgbppeba000pbvch86428e99","_id":"clgbppebk002jbvch97j48t1r"},{"post_id":"clgbppebi001ubvchfzb0dvyf","tag_id":"clgbppebj0020bvch34662yci","_id":"clgbppebl002pbvch1q3ffk0q"},{"post_id":"clgbppebi001ubvchfzb0dvyf","tag_id":"clgbppebk002kbvcha89z6pko","_id":"clgbppebl002qbvch39dqdnpj"}],"Tag":[{"name":"个人总结","_id":"clgbppeb40005bvch8vkd47ev"},{"name":"备忘翻阅","_id":"clgbppeba000pbvch86428e99"},{"name":"读书笔记","_id":"clgbppebf0019bvch0mo7aoxu"},{"name":"每周一练","_id":"clgbppebj0020bvch34662yci"},{"name":"转载","_id":"clgbppebj0026bvch4e7mes3c"},{"name":"最佳实践","_id":"clgbppebk002kbvcha89z6pko"}]}}